<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>React 模拟面试题 | HearLingの博客</title><meta name="keywords" content="React，面试"><meta name="author" content="HearLing"><meta name="copyright" content="HearLing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="React 模拟面试题 之前总结了 Vue 相关的面试题，看的人没想到挺多的，但是也为我带来了不小的争议。虽然我有明确写出答案《仅供参考》但是还是有同学照抄呀，这么说呢就是你完全没有思考直接跟面试官对答，就算你没说错但也经不起细问的呀。  废话不多说，俺还是比较关心大伙的春秋招面试准备得咋样了，面试的 React 复习得怎么样了呢？ 如果你感觉在 React 这方面还比较薄弱的话，不如来做一做这套">
<meta property="og:type" content="article">
<meta property="og:title" content="React 模拟面试题">
<meta property="og:url" content="https://yangchaoyi.vip/posts/20505/index.html">
<meta property="og:site_name" content="HearLingの博客">
<meta property="og:description" content="React 模拟面试题 之前总结了 Vue 相关的面试题，看的人没想到挺多的，但是也为我带来了不小的争议。虽然我有明确写出答案《仅供参考》但是还是有同学照抄呀，这么说呢就是你完全没有思考直接跟面试官对答，就算你没说错但也经不起细问的呀。  废话不多说，俺还是比较关心大伙的春秋招面试准备得咋样了，面试的 React 复习得怎么样了呢？ 如果你感觉在 React 这方面还比较薄弱的话，不如来做一做这套">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2022-05-04T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-03T12:56:33.984Z">
<meta property="article:author" content="HearLing">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://yangchaoyi.vip/posts/20505/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-03 20:56:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/kang-static@latest/Hexo/css/iconfont.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Rr210/Lantern@2.4/dl.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Chocolate1999/cdn@master/img/202110311156644.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HearLingの博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">React 模拟面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-04T16:00:00.000Z" title="发表于 2022-05-05 00:00:00">2022-05-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-03T12:56:33.984Z" title="更新于 2023-04-03 20:56:33">2023-04-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/React/">React</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/React/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="React-模拟面试题"><a href="#React-模拟面试题" class="headerlink" title="React 模拟面试题"></a>React 模拟面试题</h2><blockquote>
<p>之前总结了 Vue 相关的面试题，看的人没想到挺多的，但是也为我带来了不小的争议。虽然我有明确写出答案《仅供参考》但是还是有同学照抄呀，这么说呢就是你完全没有思考直接跟面试官对答，就算你没说错但也经不起细问的呀。</p>
</blockquote>
<p>废话不多说，俺还是比较关心大伙的春秋招面试准备得咋样了，面试的 React 复习得怎么样了呢？</p>
<p>如果你感觉在 React 这方面还比较薄弱的话，不如来做一做这套模拟面试吧，看看大伙能不能打个满分，祝你顺利~</p>
<p>🌸🌸🌸🌸🌸<strong>答案仅供参考</strong>🌸🌸🌸🌸🌸</p>
<p>欢迎访问<a target="_blank" rel="noopener" href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes/issues">GitHub 仓库</a>，目前已经有 <code>552</code> 道大厂真题了，涵盖各类前端的真题。也可以访问我的 <a target="_blank" rel="noopener" href="https://chodocs.cn/interview/">面试专栏</a> ，我的文章会第一时间更新在这。</p>
<h2 id="免杠声明"><a href="#免杠声明" class="headerlink" title="免杠声明"></a>免杠声明</h2><p>1、咱们是 <strong>模拟面试</strong> 并且是 <strong>React</strong> 专题 ，不是你真实面试的场景，咱们是把 React 面试题集中到了这场模拟面试中了。</p>
<p>2、因为是模拟面试，所以会有一些 <strong>情景导入</strong> 以及模拟面试官（也就是我）的 <strong>心理活动</strong>。目的是能让你有点被面试的感觉，以及让你了解一些面试官在想些什么。当然如果觉得啰嗦的话，直接点目录就可以到你想看的题了。</p>
<p>3、<font color="red"><strong>答案仅供参考</strong></font> <strong>答案会详略得当，不会面面俱到</strong>。我更偏向于告诉你，这个题第一层你可以怎么展开，第二层在你展开的这几点各自下面的重要点又是什么。至于你要不要扩充各个层级的点，以及要不要更深入增加层级，就是需要自己去思考和研究的了。</p>
<h2 id="—-进入正题化身为面试官-—"><a href="#—-进入正题化身为面试官-—" class="headerlink" title="—- 进入正题化身为面试官 —-"></a>—- 进入正题化身为面试官 —-</h2><p>📞📞 电话拨通中，喂～，听得到吗，听得到是吧 😊，那我们面试开始了，你先做个自我介绍吧。。。</p>
<blockquote>
<p>在你自我介绍的时候呢，我就看看你做过的项目，技术栈什么的。</p>
</blockquote>
<p>看你的项目经历写的是 React 项目，有写过其他项目嘛？你觉得 React 好在哪里呢？或者为什么选择 React 呢？</p>
<h2 id="1、简述一下-React？"><a href="#1、简述一下-React？" class="headerlink" title="1、简述一下 React？"></a>1、简述一下 React？</h2><p>首先要明确的是这是一个开发性的问题，他没有标准答案，目的其实更偏向于打开你的话匣子，所以这里可以尽量分维度的多说一些。同时这里要避免几个坑：第一是陷入一个点一直说（除非面试官显得很有兴趣），第二是说不到点子，第三是对比框架踩一捧一。</p>
<details><summary><b>参考答案</b></summary>

<p>(我这里写的比较全哦，比较概况，可以根据自己掌握情况做适当拓展)</p>
<p>1、一句话解释技术本质：React 是一个用于构建用户界面的 JavaScript 库。</p>
<p>2、核心概念：核心概念有三点，分别是声明式、组件化与 通用性。声明式-直观与组合。组件化-视图的拆分与模块复用，高内聚低耦合。通用性-一次学习，随处编写。</p>
<p>3、对比/优缺点：首先对比其他库比如 vue、jQuery，React 没有引入模板，而是通过 jsx 的语法编写组件化的 ui，代码更为简洁。其次 React 在减少操作 dom 等性能优化上采用的了虚拟 dom 的技术，现在这个技术被广泛的学习和认可。在者，React 提供的各种 hook，能让开发者编写更高效稳定的代码。最后，当然 React 也有缺点， 由于 React 并不是一个一揽子框架，所以导致在技术选型与学习使用上有比较高的成本。</p>
</details>

<blockquote>
<p>😶 至于为啥问这个问题，其实也是有点私心哈哈，毕竟这个问题你可以自己说出一些你认为 react 核心的东西，往往可能是 hook、虚拟 dom、组件化、jsx 等等，这种你说出来的我更乐意问，不然真的就像考试一样，拿着面试题一个个问了。这里可能我会顺着你说的 react 区别其他组件的点，顺着说，比如下面的这几个例子。</p>
</blockquote>
<p>诶，你刚刚说到了 JSX，那你说说什么是 JSX 呗？为什么 React 要使用 JSX？</p>
<h2 id="2、什么是-JSX，为什么要使用-JSX？"><a href="#2、什么是-JSX，为什么要使用-JSX？" class="headerlink" title="2、什么是 JSX，为什么要使用 JSX？"></a>2、什么是 JSX，为什么要使用 JSX？</h2><details><summary><b>参考答案</b></summary>
是什么？：

<p>JSX 是一个 JavaScript 的语法扩展，结构类似 XML。JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。</p>
<p>为什么？：</p>
<p>1、JSX 是一个 JavaScript 的语法扩展，没有引入新概念，上手简单</p>
<p>2、JavaScript 的语法扩展+结构类似 XML，代码变得更为简洁，而且代码结构层次更为清晰。</p>
<p>3、结构类似 XML，React 需要将组件转化为虚拟 DOM 树，所以在编写代码时，实际上是在手写一棵结构树。而 XML 在树结构的描述上天生具有可读性强的优势。</p>
</details>

<p>听你有说到 hooks，我们公司现在项目基本都是用 hooks，那你自己有写过 hooks 嘛？说一下 useRef 的实际使用场景吧？</p>
<h2 id="3、详细说说某某-hook？"><a href="#3、详细说说某某-hook？" class="headerlink" title="3、详细说说某某 hook？"></a>3、详细说说某某 hook？</h2><blockquote>
<p>可能第一个问题你有说到 hooks 以及他的好处什么的，那么这下面这道题就是看看你对是不是只是停留在会说。这类问题主要考察你对 hooks 的熟练程度，至少需要答到，它什么时候用，以及需要注意的点。</p>
</blockquote>
<p>这里我就不一个个的列出 hook 了，就以 useRef 为例吧：</p>
<details><summary><b>参考答案</b></summary>
useRef 的应用场景主要是：函数组件需有访问 dom 元素的场景，以及保持可变变量的场景。
需要知道的是：ref.current 发生变化并不会造成 re-render; useRef 和 useState 不同，如果一个状态或者数据会影响 DOM 的渲染结果，一定要避免使用 useRef 来保持引用
</details>

<h2 id="4、React-组件通信"><a href="#4、React-组件通信" class="headerlink" title="4、React 组件通信"></a>4、React 组件通信</h2><details><summary><b>参考答案</b></summary>
父组件 => 子组件：

<ul>
<li>Props</li>
<li>Instance Methods</li>
</ul>
<p>子组件 =&gt; 父组件：</p>
<ul>
<li>Callback Functions</li>
<li>Event Bubbling</li>
</ul>
<p>兄弟组件之间：</p>
<ul>
<li>Parent Component</li>
</ul>
<p>不太相关的组件之间：</p>
<ul>
<li>Context</li>
<li>Portals</li>
<li>Observer Pattern</li>
<li>Redux 等</li>
</ul>
</details>

<h2 id="——-源码考察分界线-——"><a href="#——-源码考察分界线-——" class="headerlink" title="—— 源码考察分界线 ——"></a>—— 源码考察分界线 ——</h2><blockquote>
<p>第三题也能聊到源码哈，下面的几道题是关于 React 核心的 架构 和虚拟 DOM 的。</p>
</blockquote>
<h2 id="5、setState-是同步更新还是异步更新？"><a href="#5、setState-是同步更新还是异步更新？" class="headerlink" title="5、setState 是同步更新还是异步更新？"></a>5、setState 是同步更新还是异步更新？</h2><details><summary><b>参考答案</b></summary>
在源码中，通过 isBatchingUpdates 来判断 setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。一般认为，做异步设计是为了性能优化、减少渲染次数。

<p>一般会被追问（也可以自己说）：在什么情况下 isBatchingUpdates 会为 true 呢？</p>
<ul>
<li><p>在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</p>
</li>
<li><p>在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</p>
</li>
</ul>
</details>

<p>有看过 React 的源码嘛？可以简单的向我描述一下 Fiber 架构吗</p>
<h2 id="6、简述-fiber-架构"><a href="#6、简述-fiber-架构" class="headerlink" title="6、简述 fiber 架构"></a>6、简述 fiber 架构</h2><details><summary><b>参考答案</b></summary>
React16 开始的fiber架构可以分为三层，相较于React15，新增了Scheduler（调度器），Reconciler从递归处理虚拟DOM变为可中断的循环过程，：

<ul>
<li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler</li>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<p>官方也推荐了 <a target="_blank" rel="noopener" href="https://github.com/acdlite/react-fiber-architecture">答案 1</a> 和 <a target="_blank" rel="noopener" href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e">答案 2</a> ，我这里基于此题，简单描述一下，什么是 Fiber ，以及解决了什么问题，怎么解决的（进阶）。</p>
<p><strong>是什么？</strong></p>
<p>Fiber 是 React 16 中采用的新协调（reconciliation）引擎，主要目标是支持虚拟 DOM 的渐进式渲染。</p>
<p><strong>解决了什么问题？</strong></p>
<p>Fiber 将原有的 Stack Reconciler 替换为 Fiber Reconciler，提高了复杂应用的可响应性和性能。</p>
<p><strong>怎么解决的</strong></p>
<ul>
<li>对大型复杂任务的分片。</li>
<li>对任务划分优先级，优先调度高优先级的任务。</li>
<li>调度过程中，可以对任务进行挂起、恢复、终止等操作。</li>
</ul>
<p>::: warning TODO 简述可能错在错误理解，后续会更新详细文章解答。 :::</p>
</details>

<h2 id="7、虚拟-DOM-的工作原理"><a href="#7、虚拟-DOM-的工作原理" class="headerlink" title="7、虚拟 DOM 的工作原理"></a>7、虚拟 DOM 的工作原理</h2><details><summary><b>参考答案</b></summary>
这个问题可能就会让你摸不着头脑，要讲清一个技术的原理，我们只要从三大方面着手就行，是什么、为什么、怎么做。这个问题可能不会问的这么泛，可能会问更细一点，比如：什么是虚拟DOM，他有什么优缺点，如何实现虚拟DOM。

<p><strong>什么是虚拟 DOM</strong></p>
<p>虚拟 DOM 实际上它只是一层对真实 DOM 的抽象，以 JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上。</p>
<p><strong>虚拟 DOM 优缺点</strong></p>
<p>优点：改善大规模 DOM 操作的性能、规避 XSS 风险、能以较低的成本实现跨平台开发。</p>
<p>缺点：内存占用较高，因为需要模拟整个网页的真实 DOM。高性能应用场景存在难以优化的情况，类似像 Google Earth 一类的高性能前端应用在技术选型上往往不会选择 React。</p>
<p><strong>如何实现虚拟 DOM</strong></p>
<p>1、h 函数，用 JS 对象模拟 DOM 树</p>
<p>2、render 函数，实现渲染，从 Virtual DOM 映射到真实 DOM</p>
<p>3、mount 函数，实现挂载</p>
<p>4、diff 算法:比较两棵虚拟 DOM 树的差异</p>
</details>

<p>那你再说说 React 的 Diff 算法是怎么实现的吧</p>
<h2 id="8、React-的-diff-算法"><a href="#8、React-的-diff-算法" class="headerlink" title="8、React 的 diff 算法"></a>8、React 的 diff 算法</h2><details><summary><b>参考答案</b></summary>

<p>diff 算法是一种对比两个树差异的一种算法，那在 React 里就是对比新旧树的差异了。那么我们可以说 React 中 Diff 算法的本质是：</p>
<p>对比 current Fiber</p>
<blockquote>
<p>如果该 DOM 节点已在页面中，current Fiber 代表该 DOM 节点对应的 Fiber 节点。</p>
</blockquote>
<p>和 JSX 对象</p>
<blockquote>
<p>即 ClassComponent 的 render 方法的返回结果，或 FunctionComponent 的调用结果。JSX 对象中包含描述 DOM 节点的信息。</p>
</blockquote>
<p>并且生成 workInProgress Fiber。</p>
<blockquote>
<p>如果该 DOM 节点将在本次更新中渲染到页面中，workInProgress Fiber 代表该 DOM 节点对应的 Fiber 节点。</p>
</blockquote>
<p>React 对 diff 算法的优化，毕竟要完全对比两棵树的复杂度是很大的，所以 React 的 diff 算法预设了三个限制：</p>
<ul>
<li><p>只对同级元素进行 Diff。如果一个 DOM 节点在前后两次更新中跨越了层级，那么 React 不会尝试复用他。</p>
</li>
<li><p>两个不同类型的元素会产生出不同的树。如果元素由 div 变为 p，React 会销毁 div 及其子孙节点，并新建 p 及其子孙节点。</p>
</li>
<li><p>开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定。</p>
</li>
</ul>
</details>

<h2 id="——-技术栈分界线-——"><a href="#——-技术栈分界线-——" class="headerlink" title="—— 技术栈分界线 ——"></a>—— 技术栈分界线 ——</h2><p>以上都是多少都可以问一问的题，下面的就涉及技术栈了。你可以理解为根据公司技术栈出题。也可以理解为和 React 强相关的技术栈出题。</p>
<p>::: tip 篇幅原因，只是挑选了一些面试中和 React 相关性比较强，且比较常见的问题。 :::</p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>下面两道问题一般是公司存在 class 语法代码可能会问的题。打个比方：公司项目旧代码是用 class 写的，希望你来了能维护或者重构就会问一些 class 的知识。</p>
<h2 id="9、class-与-hooks-的区别-优劣"><a href="#9、class-与-hooks-的区别-优劣" class="headerlink" title="9、class 与 hooks 的区别/优劣"></a>9、class 与 hooks 的区别/优劣</h2><details><summary><b>参考答案</b></summary>

<ul>
<li><p>共同点是两者的功能和效果都是一样的，类组件和函数组件都可以作为基础组件展示 UI。</p>
</li>
<li><p>他们的设计理念不一样，一个是面向对象，一个是函数式。面向对象的核心是继承、生命周期等这些。而函数式 immutable（不变）、没有副作用、引用透明等这些特点。</p>
</li>
<li><p>Hooks 更优的原因： Hooks 有确定的输入输出，没有 this 指向问题，也不用 renderprops 或者 Hoc 去解决复用状态逻辑的问题，它是一个组合的思想，组合更优于继承。class 组件业务逻辑散落在生命周期中，Hooks 则淡化了生命周期的概念。Hooks 的函数组件可以提供比原先更细粒度的逻辑组织与复用，且能更好地适用于时间切片与并发模式。</p>
</li>
</ul>
</details>

<h2 id="10、聊聊-class-与-hook-的生命周期"><a href="#10、聊聊-class-与-hook-的生命周期" class="headerlink" title="10、聊聊 class 与 hook 的生命周期"></a>10、聊聊 class 与 hook 的生命周期</h2><details><summary><b>参考答案</b></summary>
分为三个阶段 挂载->更新-> 卸载 （Error）

<p>详细请看表格，其中标注 UNSAFE_ 的都是被弃用的，通过这个表格可知道各方法所处的时期：</p>
<table>
<thead>
<tr>
<th></th>
<th>Mount</th>
<th>Update</th>
<th>Unmount</th>
<th>Error</th>
</tr>
</thead>
<tbody><tr>
<td>Render 阶段</td>
<td>construct、getDerivedStateFromProps、UNSAFE_componentWillMount、Render</td>
<td>UNSAFE_componentWillReceiveProps、getDerivedStateFromProps、shouldComponentUpdate、UNSAFE_componentWillUpdate、Render</td>
<td></td>
<td>getDerivedStateFromError</td>
</tr>
<tr>
<td>commit 阶段</td>
<td>componentDidMount、getSnapshotBeforeUpdate</td>
<td>componentDidUpdate</td>
<td>componentWillUnmount</td>
<td>componentDidCatch</td>
</tr>
</tbody></table>
<ul>
<li><p>对于异步请求，应该放在 componentDidMount 中去操作。</p>
<blockquote>
<p>constructor：可以放，但从设计上而言不推荐。constructor 主要用于初始化 state 与函数绑定，不承载业务逻辑且现在已经很少使用了。componentWillMount：已被标记废弃，在新的异步渲染架构下会触发多次渲染，容易引发 Bug。</p>
</blockquote>
</li>
<li><p>getDerivedStateFromProps 容易编写反模式代码，使受控组件与非受控组件区分模糊。</p>
</li>
<li><p>UNSAFE_componentWillMount 被标记弃用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount 中。</p>
</li>
<li><p>UNSAFE_componentWillReceiveProps 被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。</p>
</li>
<li><p>shouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化。</p>
</li>
<li><p>UNSAFE_componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。</p>
</li>
<li><p>如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug。</p>
</li>
<li><p>如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。</p>
</li>
</ul>
</details>

<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>还有的公司 React 和 Vue 技术栈都有，你过来可能主要还是写 React 但是也希望你会一些 Vue。那么下面几道题你很可能会遇到。</p>
<p>情景导入：如果简历没写我可能会问，之前有写过 Vue 项目嘛？（有写过啊，就直接问，没写过就跳过这个技术栈）简历有写的话我就会说，我看你的 xxx 项目是用 Vue 写的，那。。。</p>
<h2 id="11、你觉得-React-与-Vue-的区别主要在哪呢？"><a href="#11、你觉得-React-与-Vue-的区别主要在哪呢？" class="headerlink" title="11、你觉得 React 与 Vue 的区别主要在哪呢？"></a>11、你觉得 React 与 Vue 的区别主要在哪呢？</h2><details><summary><b>参考答案</b></summary>

<p><strong>1、各自推崇的/核心思想</strong></p>
<ul>
<li><p>React 推崇函数式编程（纯组件），数据不可变以及单向数据流。函数式编程最大的好处是其无副作用（稳定性）和确定的输入输出（可测试性），所以通常说 React 适合大型应用。</p>
</li>
<li><p>Vue 推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定。尽可能的降低了前端开发的门槛。</p>
</li>
</ul>
<p><strong>2、写法差异</strong></p>
<ul>
<li><p>React 没有太多的概念和 api，推崇 all in js，使用 JSX 和 部分 hook 就能开发。通过原生 JS 实现模板中的常见语法，比如插值，条件，循环等，都是通过 JS 语法实现的。更加原生。要求更高的 js 能力，以及对设计模式（也可以说开发经验）的掌握。</p>
</li>
<li><p>Vue 是基于 template 模板 + options API。引入了较多的概念和 api，需要理解或记住大部分概念和 api 才能编写。更要求熟练使用官方概念和 api。</p>
</li>
</ul>
<p><strong>3、数据流</strong></p>
<ul>
<li><p>React 提倡的是单向数据流，数据不可变，需要 setState 驱动新的 State 替换老的 State。</p>
</li>
<li><p>Vue 数据被观测是双向绑定的，省去了数据手动处理更加便捷。</p>
</li>
</ul>
<p><strong>4、Render（渲染过程）</strong></p>
<ul>
<li><p>React 在应用的状态被改变时，全部子组件都会重新渲染。通过 shouldComponentUpdate 这个生命周期方法可以进行控制，但 Vue 将此视为默认的优化。</p>
</li>
<li><p>Vue 可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p>
</li>
</ul>
<p><strong>5、事件机制</strong></p>
<ul>
<li><p>React 原生事件被包装，所有事件都冒泡到顶层 document 监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和 Web DOM 强绑定。React 组件上无事件，父子组件通信使用 props。</p>
</li>
<li><p>Vue 原生事件使用标准 Web 事件，Vue 组件自定义事件机制，是父子组件通信基础，Vue 合理利用了 snabbdom 库的模块插件</p>
</li>
</ul>
<p>6、<font color=gray>diff 算法实现</font></p>
<ul>
<li><p>React 主要使用 diff 队列保存需要更新哪些 DOM，得到 patch 树，再统一操作批量更新 DOM。</p>
</li>
<li><p>Vue Diff 使用双向链表，边对比，边更新 DOM。</p>
</li>
</ul>
<p>7、<font color=gray>社区和未来发展</font></p>
<blockquote>
<p>注意两者处于不同赛道，不存在谁取代谁这一说法，别踩一捧一。</p>
</blockquote>
<ul>
<li><p>React 只关注底层，上层应用解决方案交给社区，造就了 React 社区繁荣，同时 React 团队有更多时间专注底层。未来 React 的发展依然会在 函数式编程 这个核心思想的下进行升级。</p>
</li>
<li><p>Vue 提供了一揽子全家桶解决方案，比如 Vuex、Vue-Router、Vue-CLI、Vutur 工具等。减少选择困难症，只需认准官方给出的解决方案即可。Vue 依然会定位简单易上手（渐进式开发），依然是考虑通过依赖收集来实现数据可变。</p>
</li>
</ul>
</details>

<h2 id="12、vuex-与-redux-的区别"><a href="#12、vuex-与-redux-的区别" class="headerlink" title="12、vuex 与 redux 的区别"></a>12、vuex 与 redux 的区别</h2><details><summary><b>参考答案</b></summary>

<p><strong>从使用上来说</strong></p>
<ul>
<li><p>在 Vuex 中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store 来读取数据。</p>
</li>
<li><p>在 Redux 中，我们每一个组件都需要显式的用 connect 把需要的 props 和 dispatch 连接起来。</p>
</li>
<li><p>Vuex 更加灵活一些，组件中既可以 dispatch action，也可以 commit updates，而 Redux 中只能进行 dispatch，不能直接调用 reducer 进行修改。</p>
</li>
</ul>
<p><strong>从实现原理来说</strong></p>
<ul>
<li><p>Redux 使用的是不可变数据，而 Vuex 的数据是可变的。</p>
</li>
<li><p>Redux 每次都是用新 state 替换旧 state，而 Vuex 是直接修改。</p>
</li>
<li><p>Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过 getter/setter 来比较的。</p>
</li>
</ul>
</details>

<h2 id="状态-路由"><a href="#状态-路由" class="headerlink" title="状态/路由"></a>状态/路由</h2><h2 id="13、flux-状态管理"><a href="#13、flux-状态管理" class="headerlink" title="13、flux 状态管理"></a>13、flux 状态管理</h2><details><summary><b>参考答案</b></summary>

<p>Flux 是一种基于单向数据流的架构。架构如图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4876bf2f94ee4bc2a9a68a0e75e360bf~tplv-k3u1fbpfcp-watermark.image?" alt="flux.png"></p>
<p>具体流程：Store 存储了视图层所有的数据，当 Store 变化后会引起 View 层的更新。如果在视图层触发 Action，比如点击一个按钮，当前的页面数据值会发生变化。Action 会被 Dispatcher 进行统一的收发处理，传递给 Store 层。由于 Store 层已经注册过相关 Action 的处理逻辑，处理对应的内部状态变化后，会触发 View 层更新。</p>
</details>

<h2 id="14、简述-redux-状态管理"><a href="#14、简述-redux-状态管理" class="headerlink" title="14、简述 redux 状态管理"></a>14、简述 redux 状态管理</h2><details><summary><b>参考答案</b></summary>

<p><strong>核心设计</strong></p>
<p>包含了三大原则：单一数据源、纯函数 Reducer、State 是只读的。</p>
<p>一个核心点是处理“副作用”。</p>
<ul>
<li>第一类是在 Dispatch 的时候会有一个 middleware 中间件层，拦截分发的 Action 并添加额外的复杂行为，还可以添加副作用。</li>
<li>第二类是允许 Reducer 层中直接处理副作用，采取该方案的有 React Loop，React Loop 在实现中采用了 Elm 中分形的思想，使代码具备更强的组合能力。</li>
</ul>
<blockquote>
<p>AJAX 请求等异步工作，或不是纯函数产生的第三方的交互都被认为是 “副作用”</p>
</blockquote>
<p><strong>数据流</strong></p>
<p>Redux  中整个数据流的方案与 Flux 大同小异。</p>
<p>首先是 dispatch 一个 action。然后 reducer 会收到这个 action, 根据这个 action 对状态进行修改。状态修改以后会被处理容器捕捉到。从而对相关的界面进行更新。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/24/1642fe4239346286~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="redux.png"></p>
<p><font color=gray>另外一些需要知道的</font></p>
<ul>
<li>Store，Store 存放应用程序的状态，并且有帮助函数来访问这些状态。Store 可以用来聆听变化和发送 action。Store 只有一个。</li>
<li>Reducers，数据的状态是通过 reducer 函数来改变的。</li>
<li>Actions，Actions 代表的是一个对象。有两部分，一个是 action 本身，另一个就是它的 payload。简单说就是对哪些数据进行哪些操作。</li>
<li>React-Redux，Redux 本身和 React 没有关系，只是数据处理中心，是 React-Redux 让他们联系在一起。React-rRedux 提供两个方法：connect 和 Provider。</li>
</ul>
</details>

<h2 id="15、mobx-和-redux-有什么区别？"><a href="#15、mobx-和-redux-有什么区别？" class="headerlink" title="15、mobx 和 redux 有什么区别？"></a>15、mobx 和 redux 有什么区别？</h2><details><summary><b>参考答案</b></summary>

<ul>
<li>核心的差异：Redux 是单向数据流，Mobx 则是通过监听数据的属性变化，直接在数据上更改来触发 UI 的渲染。</li>
<li>redux 是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数。mobx 中的状态是可变的，可以直接对其进行修改。</li>
<li>mobx 结果也难以预测，调试会比较困难。redux 提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li>
</ul>
</details>

<h2 id="16、React-Router-的实现原理是什么？"><a href="#16、React-Router-的实现原理是什么？" class="headerlink" title="16、React-Router 的实现原理是什么？"></a>16、React-Router 的实现原理是什么？</h2><details><summary><b>参考答案</b></summary>

<p>基于 history 库来实现不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知。</p>
<blockquote>
<p>不同的客户端路由实现思想:1、基于 hash 的路由：通过监听 hashchange 事件，感知 &gt; hash 的变化。通过 location.hash=xxx 改变 hash 。2、基于 H5 history 路由：通过自定义事件触发实现监听 url 的变化。可以通过 history.pushState 和 resplaceState 等改变 url ，会将 URL 压入堆栈，同时能够应用 history.go() 等 API。</p>
</blockquote>
<p>通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render。</p>
</details>

<h2 id="17、React-Router-实现路由切换"><a href="#17、React-Router-实现路由切换" class="headerlink" title="17、React-Router 实现路由切换"></a>17、React-Router 实现路由切换</h2><details><summary><b>参考答案</b></summary>
有几种方式：

<ul>
<li><p>使用 <code>&lt;Route&gt;</code> ，会比较 <code>&lt;Route&gt;</code> 的 path 属性和当前地址的 pathname 实现路由切换。</p>
</li>
<li><p>使用 <code>&lt;Switch&gt;</code> 会遍历其所有的子 <code>&lt;Route&gt;</code> 元素，并仅渲染与当前地址匹配的第一个元素。</p>
</li>
<li><p>使用<code>&lt;Link&gt;</code>、 <code>&lt;NavLink&gt;</code>、<code>&lt;Redirect&gt;</code>，会在你的应用程序中创建链接，通过 to 属性与当前地址匹配。</p>
</li>
</ul>
</details>

<h2 id="18、React-Router-如何获取-URL-的参数和历史对象？"><a href="#18、React-Router-如何获取-URL-的参数和历史对象？" class="headerlink" title="18、React-Router 如何获取 URL 的参数和历史对象？"></a>18、React-Router 如何获取 URL 的参数和历史对象？</h2><details><summary><b>参考答案</b></summary>

<ul>
<li>get 传值：通过 location.search 获取 url 获取到一个字符串’?id=’1111’，通过浏览器的 URLSearchParams api 或自封装字符串解析方法解析出 id 的值。</li>
<li>动态路由传值：通过 match.params.id 或者 useParams（Hooks）取得 url 中的动态路由 id 部分的值</li>
<li>通过 query 或 state 传值：to 属性传递对象或数组时，通过 location.state 或 location.query 来获取即可，但是存在缺点就是，只要刷新页面参数就会丢失。</details>

</li>
</ul>
<h2 id="——-设计模式-代码优化-——"><a href="#——-设计模式-代码优化-——" class="headerlink" title="—— 设计模式/代码优化 ——"></a>—— 设计模式/代码优化 ——</h2><p>React 是对设计模式的能力很有要求的，这里只列举和 React 强相关的设计模式。</p>
<p>::: warning TODO 更详细的设计模式文章，待更新至设计模式专栏 :::</p>
<h2 id="19、HOC"><a href="#19、HOC" class="headerlink" title="19、HOC"></a>19、HOC</h2><details><summary><b>参考答案</b></summary>

<blockquote>
<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>
</blockquote>
<p>在我们的应用程序中，我们经常希望在多个组件中使用相同的逻辑。此逻辑可以包括将特定样式应用于组件、要求授权或添加全局状态。</p>
<p>能够在多个组件中重用相同逻辑的一种方法就是使用高阶组件模式。这种模式允许我们在整个应用程序中重用组件逻辑。</p>
<p>具体而言，高阶组件是参数为组件，返回值为新组件的函数。HOC 包含我们想要应用于作为参数传递的组件的某些逻辑。应用该逻辑后，HOC 返回带有附加逻辑的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOC模式例子</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withStyles</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> style = &#123; <span class="attr">padding</span>: <span class="string">&quot;0.2rem&quot;</span>, <span class="attr">margin</span>: <span class="string">&quot;1rem&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Text</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StyledButton</span> = <span class="title function_">withStyles</span>(<span class="title class_">Button</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StyledText</span> = <span class="title function_">withStyles</span>(<span class="title class_">Text</span>);</span><br></pre></td></tr></table></figure>

</details>

<h2 id="20、Render-Props"><a href="#20、Render-Props" class="headerlink" title="20、Render Props"></a>20、Render Props</h2><details><summary><b>参考答案</b></summary>

<blockquote>
<p>术语 “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p>
</blockquote>
<p>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Render Props模式例子</span></span><br><span class="line">&lt;<span class="title class_">DataProvider</span> render=&#123;<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;data.target&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="21、非受控组件"><a href="#21、非受控组件" class="headerlink" title="21、非受控组件"></a>21、非受控组件</h2><details><summary><b>参考答案</b></summary>

<blockquote>
<p>在大多数情况下，推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。</p>
</blockquote>
<p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非受控组件例子</span><br><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">    this.input = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&#x27;A name was submitted: &#x27; + this.input.current.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=&quot;text&quot; ref=&#123;this.input&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="——-性能优化-——"><a href="#——-性能优化-——" class="headerlink" title="—— 性能优化 ——"></a>—— 性能优化 ——</h2><h2 id="22、如何发现以及分析性能问题"><a href="#22、如何发现以及分析性能问题" class="headerlink" title="22、如何发现以及分析性能问题"></a>22、如何发现以及分析性能问题</h2><details><summary><b>参考答案</b></summary>
肉眼可见的性能问题，如白屏、卡顿、加载时间很长，一般是要答带数据的优化。

<ol>
<li><p>lightHouse 的评分，可以作为优化依据。</p>
</li>
<li><p>React 性能检测的一些工具也可以：Profiler 能测出 reRender 的耗时，平常对数据要求不严也就是不需要准确测出 rerender 的时间的话可以使用 ReactDevtool。</p>
</li>
<li><p>浏览器开发者工具可以检测到大部分的性能数据：</p>
</li>
</ol>
<ul>
<li><p>网络面板的一些优化方案：</p>
<ol>
<li>阻塞或者排队，由于一个域名最多维护 6 个链接，可以做域名分片或者多个域名。</li>
<li>网络原因可以用 CDN 缓存</li>
<li>下载时间过长可以压缩或者 webpack 打包优化。</li>
</ol>
</li>
<li><p>performance：</p>
<ol>
<li>FPS （Frames Per Second）每秒传输帧数，发现页面帧速图表出现红色块，代表一帧所需时间过长-&gt;卡顿。</li>
<li>CPU 图表显示占得面积太大，可能某个 js 占用太多主线程时间</li>
<li>V8 内存使用凸显一直上升，内存泄漏可能存在</li>
</ol>
</li>
</ul>
</details>

<h2 id="23、怎么做性能优化"><a href="#23、怎么做性能优化" class="headerlink" title="23、怎么做性能优化"></a>23、怎么做性能优化</h2><details><summary><b>参考答案</b></summary>

<p><strong>1、写 React 代码的优化</strong></p>
<p>减少计算</p>
<ol>
<li>增加 key</li>
<li>commit 阶段减少耗时操作</li>
<li>一些 hook ： useMemo、useCallback、React.Memo 4. setState 将多个合并，或者用 ustable_batchedUpdate 批量更新</li>
</ol>
<p>精细化渲染</p>
<ol>
<li>优先用户响应，耗时任务放到下一个宏任务。“关闭弹窗类似的场景”</li>
<li>usecontext 跳过中间组件 ，发布订阅模式，redux</li>
<li>useMemo 也可以跳过 render</li>
</ol>
<p>控制范围</p>
<ol>
<li>防抖节流</li>
<li>懒渲染（”虚拟列表”）、懒加载（webPack）</li>
<li>避免在 didMount 或 didUpdate 中更新 state</li>
</ol>
<p><strong>2、webpack 的优化（除去开发环境的优化）</strong></p>
<p>打包速度</p>
<ol>
<li>onOf、external 可以跳过 loader 的查找，除去一些不打包</li>
<li>babel 缓存，可以对运行结果缓存</li>
<li>多进程打包 thread-loader</li>
</ol>
<p>运行性能</p>
<ol>
<li>文件资源缓存 hash、chunkhash、contenthash，这几个的区别也要明白</li>
<li>treeShacking</li>
<li>code split</li>
<li>懒加载、预加载（某些浏览器不支持）</li>
<li>离线可访问 pwa （也是一种优化，但用的不多）</li>
</ol>
<p><strong>3、网络等优化</strong></p>
<ol>
<li>CDN 缓存</li>
<li>域名分片</li>
<li>文件压缩</li>
<li>DNS 预解析，提前解析之后可能会用到的域名</li>
</ol>
</details>

<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>⭐️ 虽然说现在大环境不好，工作难找但还是衷心希望各位准备面试的小伙伴面试顺利~，收割 offer，我们一起加油吧 🤝！还有就是新年快乐 ❤️ ~</p>
<p>🚀 文章还有不足，如果你有意向，很欢迎你可以加入我们，文章后续会持续更新~</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">HearLing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yangchaoyi.vip/posts/20505/">https://yangchaoyi.vip/posts/20505/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yangchaoyi.vip" target="_blank">HearLingの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/30403/"><img class="prev-cover" data-lazy-src="https://user-images.githubusercontent.com/51811652/227833231-3b91552a-618f-41de-bbc1-fc6f68177a7d.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Vue3 开源项目】后台管理系统（Vue3 + TypeScript + Pinia）</div></div></a></div><div class="next-post pull-right"><a href="/posts/20127/"><img class="next-cover" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d43e8725e22844b9992670da4b70555d~tplv-k3u1fbpfcp-watermark.image?" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「辩论」应不应该多使用 useCallback 和 useMemo</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/643/" title="「计算机网络」前端必备知识，看到就是赚到系列（上）"><img class="cover" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13305ad3e9b446529a5adac0cd1c63ef~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-03</div><div class="title">「计算机网络」前端必备知识，看到就是赚到系列（上）</div></div></a></div><div><a href="/posts/10201/" title="「面试」前端高频CSS面试题及答案"><img class="cover" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1332aad308904d34b8c5879f09732e48~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-01</div><div class="title">「面试」前端高频CSS面试题及答案</div></div></a></div><div><a href="/posts/10205/" title="JS手撕，经典面试题"><img class="cover" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5f0fcdc24f648ea924a3e88686a4d44~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-05</div><div class="title">JS手撕，经典面试题</div></div></a></div><div><a href="/posts/31403/" title="🐮化身面试官出30+Vue面试题，超级干货（附答案）"><img class="cover" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/859f73c9260b4dc0abafafc85ad64907~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-19</div><div class="title">🐮化身面试官出30+Vue面试题，超级干货（附答案）</div></div></a></div><div><a href="/posts/521/" title="「计算机网络」前端必备知识，看到就是赚到系列（上）"><img class="cover" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1eec5dd801c4fdaab80812297b69d6e~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-11</div><div class="title">「计算机网络」前端必备知识，看到就是赚到系列（上）</div></div></a></div><div><a href="/posts/10112/" title="「计算机网络」前端必备知识，看到就是赚到系列（下）"><img class="cover" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1eec5dd801c4fdaab80812297b69d6e~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-12</div><div class="title">「计算机网络」前端必备知识，看到就是赚到系列（下）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Chocolate1999/cdn@master/img/202110311156644.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">HearLing</div><div class="author-info__description">不爱巧克力爱 Chocolate</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/201738571"><i class="iconfont icon-bilibili"></i><span>关注</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://juejin.cn/user/3922690515936312/posts" target="_blank" title=""><i class="iconfont icon-juejin"></i></a><a class="social-icon" href="https://github.com/HearLing" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/201738571" target="_blank" title=""><i class="iconfont icon-bilibili1"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>简介</span></div><div class="announcement_content">一枚前端程序媛，分享知识，我们一起进步吖～<br/> <a target="_blank" rel="noopener" href="https://space.bilibili.com/201738571"><img src="https://img.shields.io/badge/dynamic/json?labelColor=FE7398&logo=bilibili&logoColor=white&label=bilibili%20fans&color=00aeec&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dbilibili%26queryKey%3D201738571" /></a><br/>我的技术栈：<br/><img src="https://img.shields.io/badge/-React-282c34?logo=react"/>&nbsp<img src="https://img.shields.io/badge/-TypeScript-blue?logo=typescript&logoColor=white"/>&nbsp<img src="https://img.shields.io/badge/-JavaScript-yellow?logo=javascript&logoColor=white"/><br/>博客内容同步于 <a target="_blank" rel="noopener" href="https://space.bilibili.com/201738571">B 站：HearLing</a><br/> QQ交流群：666151691</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">React 模拟面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%8D%E6%9D%A0%E5%A3%B0%E6%98%8E"><span class="toc-number">2.</span> <span class="toc-text">免杠声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94-%E8%BF%9B%E5%85%A5%E6%AD%A3%E9%A2%98%E5%8C%96%E8%BA%AB%E4%B8%BA%E9%9D%A2%E8%AF%95%E5%AE%98-%E2%80%94"><span class="toc-number">3.</span> <span class="toc-text">—- 进入正题化身为面试官 —-</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-React%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">1、简述一下 React？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-JSX%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-JSX%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">2、什么是 JSX，为什么要使用 JSX？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E6%9F%90%E6%9F%90-hook%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">3、详细说说某某 hook？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">7.</span> <span class="toc-text">4、React 组件通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94-%E6%BA%90%E7%A0%81%E8%80%83%E5%AF%9F%E5%88%86%E7%95%8C%E7%BA%BF-%E2%80%94%E2%80%94"><span class="toc-number">8.</span> <span class="toc-text">—— 源码考察分界线 ——</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81setState-%E6%98%AF%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">5、setState 是同步更新还是异步更新？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%AE%80%E8%BF%B0-fiber-%E6%9E%B6%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text">6、简述 fiber 架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">7、虚拟 DOM 的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81React-%E7%9A%84-diff-%E7%AE%97%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">8、React 的 diff 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94-%E6%8A%80%E6%9C%AF%E6%A0%88%E5%88%86%E7%95%8C%E7%BA%BF-%E2%80%94%E2%80%94"><span class="toc-number">13.</span> <span class="toc-text">—— 技术栈分界线 ——</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-number">14.</span> <span class="toc-text">class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81class-%E4%B8%8E-hooks-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BC%98%E5%8A%A3"><span class="toc-number">15.</span> <span class="toc-text">9、class 与 hooks 的区别&#x2F;优劣</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E8%81%8A%E8%81%8A-class-%E4%B8%8E-hook-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">16.</span> <span class="toc-text">10、聊聊 class 与 hook 的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue"><span class="toc-number">17.</span> <span class="toc-text">vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E4%BD%A0%E8%A7%89%E5%BE%97-React-%E4%B8%8E-Vue-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%BB%E8%A6%81%E5%9C%A8%E5%93%AA%E5%91%A2%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">11、你觉得 React 与 Vue 的区别主要在哪呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81vuex-%E4%B8%8E-redux-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">12、vuex 与 redux 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81-%E8%B7%AF%E7%94%B1"><span class="toc-number">20.</span> <span class="toc-text">状态&#x2F;路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81flux-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">21.</span> <span class="toc-text">13、flux 状态管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E7%AE%80%E8%BF%B0-redux-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">22.</span> <span class="toc-text">14、简述 redux 状态管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81mobx-%E5%92%8C-redux-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">15、mobx 和 redux 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81React-Router-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">16、React-Router 的实现原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81React-Router-%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2"><span class="toc-number">25.</span> <span class="toc-text">17、React-Router 实现路由切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81React-Router-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-URL-%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E5%8E%86%E5%8F%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">18、React-Router 如何获取 URL 的参数和历史对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-%E2%80%94%E2%80%94"><span class="toc-number">27.</span> <span class="toc-text">—— 设计模式&#x2F;代码优化 ——</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81HOC"><span class="toc-number">28.</span> <span class="toc-text">19、HOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81Render-Props"><span class="toc-number">29.</span> <span class="toc-text">20、Render Props</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">30.</span> <span class="toc-text">21、非受控组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E2%80%94%E2%80%94"><span class="toc-number">31.</span> <span class="toc-text">—— 性能优化 ——</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">32.</span> <span class="toc-text">22、如何发现以及分析性能问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E6%80%8E%E4%B9%88%E5%81%9A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">33.</span> <span class="toc-text">23、怎么做性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E7%9A%84%E8%AF%9D"><span class="toc-number">34.</span> <span class="toc-text">最后的话</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/30403/" title="【Vue3 开源项目】后台管理系统（Vue3 + TypeScript + Pinia）"><img data-lazy-src="https://user-images.githubusercontent.com/51811652/227833231-3b91552a-618f-41de-bbc1-fc6f68177a7d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Vue3 开源项目】后台管理系统（Vue3 + TypeScript + Pinia）"/></a><div class="content"><a class="title" href="/posts/30403/" title="【Vue3 开源项目】后台管理系统（Vue3 + TypeScript + Pinia）">【Vue3 开源项目】后台管理系统（Vue3 + TypeScript + Pinia）</a><time datetime="2023-04-02T16:00:00.000Z" title="发表于 2023-04-03 00:00:00">2023-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20505/" title="React 模拟面试题"><img data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React 模拟面试题"/></a><div class="content"><a class="title" href="/posts/20505/" title="React 模拟面试题">React 模拟面试题</a><time datetime="2022-05-04T16:00:00.000Z" title="发表于 2022-05-05 00:00:00">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20127/" title="「辩论」应不应该多使用 useCallback 和 useMemo"><img data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d43e8725e22844b9992670da4b70555d~tplv-k3u1fbpfcp-watermark.image?" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「辩论」应不应该多使用 useCallback 和 useMemo"/></a><div class="content"><a class="title" href="/posts/20127/" title="「辩论」应不应该多使用 useCallback 和 useMemo">「辩论」应不应该多使用 useCallback 和 useMemo</a><time datetime="2022-01-26T16:00:00.000Z" title="发表于 2022-01-27 00:00:00">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11112/" title="React Redux写一个todoList"><img data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/926f63809e6a4c39b6a3d64474ca6a79~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp?" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React Redux写一个todoList"/></a><div class="content"><a class="title" href="/posts/11112/" title="React Redux写一个todoList">React Redux写一个todoList</a><time datetime="2021-11-11T16:00:00.000Z" title="发表于 2021-11-12 00:00:00">2021-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11102/" title="「Redux Toolkit」 是个好东西 💗"><img data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a810362049134e91ae0ddda33e4ef989~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp?" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Redux Toolkit」 是个好东西 💗"/></a><div class="content"><a class="title" href="/posts/11102/" title="「Redux Toolkit」 是个好东西 💗">「Redux Toolkit」 是个好东西 💗</a><time datetime="2021-11-01T16:00:00.000Z" title="发表于 2021-11-02 00:00:00">2021-11-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> HearLing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/"><img class="icp-icon" src="/img/icp.png"/><span>湘ICP备20002952号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@master/xkTool/v3.1.1/xkTool.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>