<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>低代码编辑器 demo</title>
      <link href="/posts/31024/"/>
      <url>/posts/31024/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此低代码编辑器 demo，实现用意是让用户可以通过拖拉拽的形式，自行配置页面展示。</p><p>再做一下区分，由于业务性，不涉及到生成结构性代码生成，而是生成描述形式的 JSON，交由负责展示的项目或者模块翻译表达。</p><h2 id="产品需求确认"><a href="#产品需求确认" class="headerlink" title="产品需求确认"></a>产品需求确认</h2><p>我列出来的这些都需要和产品确认，如果有的话，没有产品，我们在开发前也需要明确：</p><p>二级页面、滚动页拖拽、悬浮重叠组件、组件内交互、参数量级、校验。</p><p>明确我们要做的大致内容，以及面临的挑战，这样在开发中才不会迷失方向。</p><p>接下来就是调研工作，低代码产品，不是一个新东西，很多公司都做过，我们可以取取经。</p><p>这里我一笔带过了~</p><h2 id="技术路线-技术实现"><a href="#技术路线-技术实现" class="headerlink" title="技术路线/技术实现"></a>技术路线/技术实现</h2><p>实现一个 demo，效果为左侧拖拽组件，中间预览，右侧编辑 form。</p><h3 id="左侧拖拽至右侧"><a href="#左侧拖拽至右侧" class="headerlink" title="左侧拖拽至右侧"></a>左侧拖拽至右侧</h3><p>左侧主要是组件的展示预览区域，一般会简要告诉用户该组件是做什么的，用户可以通过点击或拖拽添加至中间预览区编辑。其中涉及相对困难的点在于：</p><p>左侧拖拽至右侧，实现方案：</p><blockquote><p>基于原生 drag 实现，没有找到合适的第三方支持</p></blockquote><ul><li>由于左侧本身应该不支持拖拽排序，而只是允许拖拽至右侧，并且组件并不会消失,这与多拖拽组件设计之初相违背，使用原生则会简单可拓展一些。</li></ul><p>涉及难点：拖拽至中间时，存在多个组件，显示正确的预放置 drophere 站位符位置。</p><p>解决思路：由于每个 dragitem 都会有一个唯一值，在拖拽进入 dragOverItem 时可以获取到对应的 id，从而显示占位符。</p><h3 id="预览主体"><a href="#预览主体" class="headerlink" title="预览主体"></a>预览主体</h3><p>这里需要区分一下需要 y 轴排列拖拽滚动的长页面，和需要叠层任意拖拽的海报 h5 类的页面。</p><p><strong>y 轴排列拖拽滚动的长页面：</strong></p><p>主体拖拽实现，可以采用 @dnd-kit/core 或者 react-beautiful-dnd，我这里用的是 dnd-kit 对比 react-beautiful-dnd 暂时没有性能上的差距。</p><p>遇到的一些小 bug 的记录：</p><ul><li>拖拽遮挡</li></ul><p>问题原因：是未设置拖拽时 zindex 更高</p><ul><li>非一致高度时，replace 高度继承 hoverItem 高度，导致拖动一个高度大的组件到高度小的组件位置时，空出的高度是小的，不容易看出来。</li></ul><p>问题原因：CSS.Transform.toString(transform)会在移动元素时应用缩放到 X 和 Y 轴的变换。相反，使用 transform: CSS.Translate.toString(transform)可以解决这个问题。这是因为 CSS.Translate.toString(transform)会应用平移变换，而不会应用缩放变换。这样可以确保在拖动元素时不会出现缩放问题。</p><p><strong>叠层任意拖拽的 h5 类的页面</strong></p><p>主体拖拽实现，使用的第三方库 react-rnd，支持 resize 和 drag 控制。</p><p>主要功能实现在于其 onDragStop 时更新对应 id 的 x 与 y 值，onResizeStop 时更新 width 和 height。</p><p>还需优化的点：</p><p>前置功能需要完成多语言后台配置，而非后端配置。需要重新制定一套多语言方案。</p><h3 id="右侧-form"><a href="#右侧-form" class="headerlink" title="右侧 form"></a>右侧 form</h3><p>可以对组件的样式, 逻辑, 交互进行配置，设计上主要在于数据存储和数据校验。</p><p>在数据结构设计和数据流这一块，单独放在后续文章中详细讲解。使用的是 zustand 存储数据，由 store 统一处理数据。</p><p>校验设计，简要概括：</p><ol><li>submit 提交时循环 value 触发对应的 validate 回调</li><li>找到所有校验不通过的 form，记录 id 和 cKey（组件唯一键）</li><li>切换到对应的组件 form</li><li>触发 form 的 onInit 触发 validateFields 保证 form 正确标红</li></ol><p>待优化的点：</p><p>实际编写时，比较麻烦的是需要写两套校验，1 是 form 中的 rules，2 是 from 对应的校验回调函数，考虑是否可以合二为一。</p><p>产品设计上的优化，应保存奖品库或商品库，用时只需要添加并判断有无添加即可，而不需要判断其中的各种复杂的校验。</p><h3 id="顶部功能区"><a href="#顶部功能区" class="headerlink" title="顶部功能区"></a>顶部功能区</h3><p>功能包括：放回，页面名称，保存，预览（手机预览，需要校验数据），调试用 json 看板。</p><p>预览支持需要注意：需要验证数据，走保存逻辑，由后端生成的预览链接进行显示。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="公共组件库-OR-独立开发"><a href="#公共组件库-OR-独立开发" class="headerlink" title="公共组件库 OR 独立开发"></a>公共组件库 OR 独立开发</h3><p>公共组件库</p><ul><li>优势：<ul><li>单一源头</li><li>减少重复工作</li><li>方便进行组件的更新和维护</li></ul></li><li>劣势：<ul><li>维护成本高</li><li>开发成本高，需要考虑更多维情况</li><li>相对增加更多的代码体积</li><li>相对增加页面加载速度</li></ul></li></ul><p>独立开发，与公共组件库优劣相反</p><p>从开发成本与以用户优先角度，最终还是选择*<em>独立开发 *</em>的方式。</p><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><ul><li>Dashboard 编辑处理速度<ul><li><strong>资源占用过高：</strong> 可视化开发平台通常提供了大量的可视化组件和功能，这些组件和功能可能会消耗大量的内存和计算资源。如果应用程序在内存高的情况下运行，可能会导致系统资源不足，从而影响平台的运行速度或导致假死。</li><li><strong>复杂性和层次嵌套：</strong> 低代码平台通常支持复杂的应用程序开发，这可能导致应用程序的层次结构复杂，组件之间的嵌套层次深。当应用程序的层次嵌套非常深时，平台需要处理大量的组件和数据关系，这可能导致性能下降和假死现象。</li><li><strong>数据量过大：</strong> 如果应用程序处理大量的数据，例如大型数据集或复杂的数据操作，这可能会占用大量的内存和计算资源。在内存高的情况下，系统可能无法有效地处理这些大量的数据，导致性能下降或假死。</li></ul></li><li>可能的解决方案</li><li><strong>优化资源使用：</strong> 确保应用程序和平台在设计和实现时充分优化资源的使用，避免资源的浪费和不必要的占用。</li><li><strong>简化层次结构：</strong> 尽量简化应用程序的层次结构和组件嵌套，减少复杂性，提高性能。</li><li><strong>处理大数据量：</strong> 对于大数据量的情况，采取适当的数据处理策略，如分页加载、服务器端数据处理等，以减轻客户端的资源压力。</li><li>H5 渲染速度<ul><li>图片资源压缩</li><li>动态组件加载</li></ul></li></ul><h2 id="组件描述文件-json⭐"><a href="#组件描述文件-json⭐" class="headerlink" title="组件描述文件 json⭐"></a><strong>组件描述文件 json⭐</strong></h2><p>Item 数据类型：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">cKey</span>: <span class="title class_">CKey</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">formValue</span>: <span class="title class_">FormValueType</span>&lt;<span class="title class_">CKey</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">pageId</span>: <span class="built_in">string</span> <span class="comment">//增加：记录所在页面</span></span><br><span class="line">  <span class="attr">state</span>: &#123; width?: <span class="built_in">string</span>, height?: <span class="built_in">string</span>, <span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span> &#125; <span class="comment">//增加：记录长宽&amp;位置</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">cKey</span>: <span class="title class_">CKey</span></span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">formValue</span>: <span class="title class_">FormValueType</span>&lt;<span class="title class_">CKey</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>store：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">State</span> = &#123;</span><br><span class="line">  <span class="attr">items</span>: <span class="title class_">Item</span>[]</span><br><span class="line">  <span class="attr">activeItem</span>: <span class="title class_">Item</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="attr">errorIds</span>: &#123; <span class="attr">id</span>: <span class="built_in">string</span>; <span class="attr">cKey</span>: <span class="title class_">CKey</span> &#125;[]</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Actions</span> = &#123;</span><br><span class="line">  <span class="attr">setActiveItem</span>: <span class="function">(<span class="params">item: Item | <span class="literal">undefined</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">changeFormValues</span>: <span class="function">(<span class="params">value: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">setErrorIds</span>: <span class="function">(<span class="params">item: &#123; id: <span class="built_in">string</span>; cKey: CKey &#125;</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// from 初始数据和对应类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">defaultFormValue</span>: &#123; [K <span class="keyword">in</span> <span class="title class_">CKey</span>]: <span class="title class_">FormValueMap</span>[K] &#125; = &#123;...&#125;</span><br><span class="line"><span class="comment">// 左侧图文列表</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">cItems</span>: &#123; <span class="attr">icon</span>: <span class="title class_">ReactNode</span>; <span class="attr">cKey</span>: <span class="title class_">CKey</span>; <span class="attr">title</span>: <span class="built_in">string</span> &#125;[] = [...]</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="梳理字段"><a href="#梳理字段" class="headerlink" title="梳理字段"></a>梳理字段</h3><p>header 头：</p><ul><li>pageId：唯一</li><li>pageName：用于标识编辑页面</li></ul><p>左侧组件列需要数据：</p><ul><li>iconName： 用于图标显示，无需存元素</li><li>title：描述组件标题</li><li>cKey：唯一，通过 key 确定指向其对应组件</li></ul><p>主体预览部分数据： key-value：cKey-component</p><ul><li>id：唯一，后端 id 或使用 uuid 生成的 id 值，唯一确定组件，一定要有不然排序和性能会有问题。</li><li>cKey：组件对应 key 值，可能不唯一，添加相同组件。</li><li>formValue：表单数据（实时改变）</li><li>className：样式数据（实时改变）</li></ul><p>配置区数据： key-value：cKey-from</p><ul><li>title（可能需要）</li><li>initFormValue：表单初始数据</li><li>initClassName：初始样式数据</li></ul><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><p>要求能规范到 key 和对应的 formValue，实例参考：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type CKey = &quot;CKEY1&quot; | &quot;CKEY2&quot; | &quot;CKEY3&quot;</span><br><span class="line"></span><br><span class="line">  type FormValueMap = &#123;</span><br><span class="line">    CKEY1: &#123; title: string &#125;</span><br><span class="line">    CKEY2: number</span><br><span class="line">    CKEY3: boolean</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  type FormData&lt;K extends CKey&gt; = &#123;</span><br><span class="line">    id: string</span><br><span class="line">    cKey: K</span><br><span class="line">    formValue: FormValueMap[K]</span><br><span class="line">    className: string</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const formData: FormData&lt;&quot;CKEY1&quot;&gt; = &#123;</span><br><span class="line">    id: &quot;1&quot;,</span><br><span class="line">    cKey: &quot;CKEY1&quot;,</span><br><span class="line">    formValue: &#123; title: &quot;Hello World&quot; &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零到一搭建一个React企业级项目</title>
      <link href="/posts/30410/"/>
      <url>/posts/30410/</url>
      
        <content type="html"><![CDATA[<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>文章中涉及的技术栈大致包含以下：</p><ul><li>React18：UI 框架</li><li>TypeScript：类型语言</li><li>Vite4：构建工具</li><li>ReactRouter：路由</li><li><a href="https://github.com/pmndrs/zustand">zustand：状态管理</a></li><li>ESlint,Prettier：代码规范</li><li>Axios：请求</li><li>antd：组件库</li><li>TailwindCSS3：css 解决方案</li><li>i18next，i18n-ally：多语言</li><li>ahooks：工具方法库</li><li>pnpm: 依赖管理</li></ul><p>由于项目的规模、复杂性和要求都有所不一样，在技术选型上都会有所差异，我这边指出的是常见的后台管理类项目的需求架构。</p><p>技术选型是项目架构中占比比较大的一部分，下面简述一下，我是如何对比选择的技术栈：</p><h3 id="React-vs-Vue"><a href="#React-vs-Vue" class="headerlink" title="React vs Vue"></a>React vs Vue</h3><p>两者并没有谁好谁差的说法，一些论坛上吵来吵去谁也没办法说服谁。如果是个人项目，当然可以主观用哪个都是不错的，但从团队的角度，可能就需要考虑以下这些点了：</p><ul><li><p>对 React 的掌握程度：至少要有一个核心成员熟练 React，避免出现有问题不知道问谁的情况。</p></li><li><p>前端团队成员的意向 or 招聘需求</p></li><li><p>设计趋向 antd or element，能复用就能提高开发效率</p></li><li><p>社区生态，例如你想要使用的必要的库只支持 React</p></li></ul><h3 id="TypeScript-vs-JavaScript"><a href="#TypeScript-vs-JavaScript" class="headerlink" title="TypeScript vs JavaScript"></a>TypeScript vs JavaScript</h3><p>其实本质就是看对类型看不看重；</p><p>TypeScript 相对于 JavaScript 的优势在于它引入了静态类型检查，使得代码更加健壮和易于维护。</p><h3 id="vite-vs-webpack"><a href="#vite-vs-webpack" class="headerlink" title="vite vs webpack"></a>vite vs webpack</h3><p>我个人有个项目是从 webpack 升级到 vite 的，升级成本并不高，一些项目甚至直接复制社区的最佳实践代码，稍加修改就能有不错的效果。</p><p>使用成本只是一个入门要求，只要能解决痛点，稍微学习一下当然值得。</p><p>vite 解决了什么问题呢？ webpack 的启动速度慢，热更新速度慢的问题。</p><ul><li><p>webpack 为什么慢：webpack 的运行原理导致的，在使用 webpack 启动项目时，webpack 会根据我们配置文件（webpack.config.js） 中的入口文件（entry），分析出项目项目所有依赖关系，然后打包成一个文件（bundle.js），交给浏览器去加载渲染。</p></li><li><p>vite 为什么快：利用了 ES module <strong>浏览器遇到内部的 import 引用时，会自动发起 http 请求，去加载对应的模块</strong> 的特性，使用 vite 运行项目时，首先会用 esbuild 进行预构建，将所有模块转换为 es module，不需要对我们整个项目进行编译打包，而是在浏览器需要加载某个模块时，拦截浏览器发出的请求，根据请求进行按需编译，然后返回给浏览器。</p></li></ul><h3 id="redux-vs-zustand"><a href="#redux-vs-zustand" class="headerlink" title="redux vs zustand"></a>redux vs zustand</h3><p>这里对比 redux 的最佳实践 Redux Toolkit 与 zustand。</p><p>其实两者都是不错的选择，我从我的角度来讲讲为什么我选择 zustand。</p><ul><li><p>简单易用：Zustand 使用 React 的钩子机制作为状态管理的基础，通过创建自定义 Hook 来提供对状态的访问和更新，与函数式组件和钩子的编程模型紧密配合，使得状态管理变得非常自然和无缝。</p></li><li><p>轻量级的状态管理库：对比 redux 体积，Redux 的体积相对较大，通常在几十 KB 到 100KB 左右，Zustand 的体积非常小，压缩后不到 1KB。</p></li><li><p>Zustand 提供了中间件 (middleware) 的概念，允许你通过插件的方式扩展其功能。中间件可以用于处理日志记录、持久化存储、异步操作等需求，使得状态管理更加灵活和可扩展。</p></li></ul><blockquote><p>Redux Toolkit 是官方推荐的编写 Redux 逻辑的方法。</p></blockquote><p>Zustand 的优点包括：</p><p>轻量级，使用起来更简单，适用于中小型应用或者对于快速原型开发。无需繁琐的配置，减少了样板代码，提高了开发效率。 Zustand 的缺点包括：</p><p>可能不适用于大型复杂的应用程序，对于更多的状态管理需求可能不够灵活。社区资源和文档相对较少，可能需要更多的自行探索和摸索。</p><p>最后再对比一下写法（以持久化存储语言为例）：</p><p>zustand：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; create &#125; <span class="keyword">from</span> <span class="string">&#x27;zustand&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; persist &#125; <span class="keyword">from</span> <span class="string">&#x27;zustand/middleware&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">LngType</span> = <span class="string">&#x27;zh-CN&#x27;</span> | <span class="string">&#x27;en&#x27;</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">LngState</span> &#123;</span><br><span class="line">  <span class="attr">lng</span>: <span class="title class_">LngType</span></span><br><span class="line">  <span class="attr">setLng</span>: <span class="function">(<span class="params">value: LngType</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useLngStore = create&lt;<span class="title class_">LngState</span>&gt;()(</span><br><span class="line">  <span class="title function_">persist</span>(</span><br><span class="line">    <span class="function">(<span class="params">set</span>) =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">lng</span>: <span class="string">&#x27;zh-CN&#x27;</span>,</span><br><span class="line">      <span class="attr">setLng</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="title function_">set</span>(<span class="function">() =&gt;</span> (&#123; <span class="attr">lng</span>: value &#125;))</span><br><span class="line">    &#125;),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;lng&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useLngStore</span><br></pre></td></tr></table></figure><p>redux：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore, createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; persistReducer, persistStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux-persist&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span> <span class="string">&quot;redux-persist/lib/storage&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Redux Toolkit 的 slice</span></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore, createSlice, <span class="title class_">PayloadAction</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; persistReducer, persistStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux-persist&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span> <span class="string">&quot;redux-persist/lib/storage&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Redux Toolkit 的 slice</span></span><br><span class="line">interface <span class="title class_">LngState</span> &#123;</span><br><span class="line">  <span class="attr">lng</span>: <span class="string">&quot;zh-CN&quot;</span> | <span class="string">&quot;en&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">initialState</span>: <span class="title class_">LngState</span> = &#123;</span><br><span class="line">  <span class="attr">lng</span>: <span class="string">&quot;zh-CN&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lngSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lng&quot;</span>,</span><br><span class="line">  initialState,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="attr">setLng</span>: <span class="function">(<span class="params">state, action: PayloadAction&lt;<span class="string">&quot;zh-CN&quot;</span> | <span class="string">&quot;en&quot;</span>&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">lng</span> = action.<span class="property">payload</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建持久化配置</span></span><br><span class="line"><span class="keyword">const</span> persistConfig = &#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;lng&quot;</span>,</span><br><span class="line">  storage,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建持久化 reducer</span></span><br><span class="line"><span class="keyword">const</span> persistedReducer = <span class="title function_">persistReducer</span>(persistConfig, lngSlice.<span class="property">reducer</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Redux store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: persistedReducer,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建持久化存储</span></span><br><span class="line"><span class="keyword">let</span> persistor = <span class="title function_">persistStore</span>(store);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 action creators 和 store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; setLng &#125; = lngSlice.<span class="property">actions</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; store, persistor &#125;;</span><br></pre></td></tr></table></figure><h3 id="pnpm-vs-npm-和-yarn"><a href="#pnpm-vs-npm-和-yarn" class="headerlink" title="pnpm vs npm 和 yarn"></a>pnpm vs npm 和 yarn</h3><p>pnpm 对比 npm 和 yarn 的优势在于：包安装速度快和磁盘空间利用高效。</p><p>主要原因：npm/yarn 在不同项目依赖同一个包的情况下，会将这个包安装多次在每个项目中，而 pnpm 安装的包会存储在可寻址的磁盘中，在多个项目同时引用时，只需要用一个硬链接指向该地址就可以使用，大大节约了磁盘空间</p><h4 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h4><p>pnpm 采用硬链接和符号链接到全局磁盘上的内容可寻址存储来管理 node_modules，从而减少磁盘空间使用，同时保持项目的 node_modules 目录整洁。</p><blockquote><p>关于什么是 hard link（硬链接），这里简单说下，在 Linux 文件系统中，磁盘中的文件都有一个索引编号（Inode Index），在 Linux 中，可以多个文件名指向同一索引节点，这种就是硬链接。</p></blockquote><p>硬链接的机制可以让多个不同的位置寻址到相同的空间，也就说硬链接文件和原始文件其实是同一份文件，所以在 pnpm 管理的项目，100 个项目的相同依赖只需占用一份依赖的空间。</p><p>而且后续安装依赖时，如果该依赖之前已经安装过了，在 store 中已经有了该依赖，这时候就会直接使用 hard link，大大减少安装时间。</p><p>所以，总的来说，pnpm 比起 npm 和 yarn 不仅节省了磁盘空间，并且安装速度更快。</p><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p>在早期的 npm1 和 npm2 中 node_modules 的目录结构是嵌套的结构，例如有三个包结构，a 包，b 包引用 a 包，c 包引用 b 包，则会出现嵌套结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">└─ kai_npm_test_c</span><br><span class="line">   ├─ index.js</span><br><span class="line">   ├─ package.json</span><br><span class="line">   └─ node_modules</span><br><span class="line">      └─ kai_npm_test_b</span><br><span class="line">         ├─ index.js</span><br><span class="line">         ├─ package.json</span><br><span class="line">         └─ node_modules</span><br><span class="line">      └─ kai_npm_test_a</span><br><span class="line">         ├─ index.js</span><br><span class="line">         └─ package.json</span><br></pre></td></tr></table></figure><p>带来的问题：</p><ul><li><p>windows 系统文件路径名限制：嵌套结构非常深的情况下，越深层的依赖的文件路径就越长，这会带来很多麻烦，在 window 系统下，很多程序无法处理超过 260 个字符的文件路径名。</p></li><li><p>相同的依赖会重复安装造成浪费：比如上面的例子在安装了 C 包后又再安装了其他依赖包（例如叫它 D 包），假如 D 包也引用了测试 B 包，则 B 包会重复安装，并出现在 C 包和 D 包下的 node_modules 中。、</p></li></ul><p>npm 从版本 3 和 yarn 一样开始维护一个扁平化的依赖树，这导致了更少的磁盘空间膨胀，但会导致 node_modules 目录混乱。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">├─ kai_npm_test_a</span><br><span class="line">│  ├─ index.js</span><br><span class="line">│  └─ package.json</span><br><span class="line">│</span><br><span class="line">├─ kai_npm_test_b</span><br><span class="line">│  ├─ index.js</span><br><span class="line">│  └─ package.json</span><br><span class="line">│</span><br><span class="line">└─ kai_npm_test_c</span><br><span class="line">   ├─ index.js</span><br><span class="line">   └─ package.json</span><br></pre></td></tr></table></figure><h4 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h4><ul><li>使用 yarn.lock 文件解决那时候 npm 安装的不确定性（那时候 npm 还没有 lock 文件，npm5 才有）</li><li>yarn 并行安装的机制比 npm 的顺序安装速度更快，</li><li>带来了可以从缓存中获取的离线模式。</li><li>更简洁的命令行输出</li><li>更好的语义化命令，比如 yarn add/remove 等</li></ul><h2 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─ public                     # 静态资源</span><br><span class="line">│   ├─ favicon.ico            # favicon图标</span><br><span class="line">├─ src                        # 项目源代码</span><br><span class="line">│   ├─ components             # 全局公用组件</span><br><span class="line">│   ├─ layout                 # 布局组件</span><br><span class="line">│   ├─ pages                  # pages所有页面</span><br><span class="line">│   ├─ routers                # 路由配置</span><br><span class="line">│   ├─ services               # api接口</span><br><span class="line">│   ├─ static                 # 静态资源</span><br><span class="line">│   ├─ stores                 # 全局 store管理</span><br><span class="line">│   ├─ utils                  # 全局公用方法</span><br><span class="line">│   ├─ App.tsx                # 入口页面</span><br><span class="line">│   ├─ global.d.ts            # 全局声明文件</span><br><span class="line">│   └─ index.tsx              # 源码入口</span><br><span class="line">└── .eslintignore             # eslint忽略文件</span><br><span class="line">└── .eslintrc.js              # eslint配置</span><br><span class="line">└── .gitignore.js             # git忽略文件</span><br><span class="line">└── .prettierrc.js            # prettier配置</span><br><span class="line">└── index.html                # html模板</span><br><span class="line">└── package.json              # package.json</span><br><span class="line">└── tailwind.config.js        # tailwind配置</span><br><span class="line">└── vite.config.js            # vite打包配置</span><br></pre></td></tr></table></figure><p>注意名称规范：文件小写（小驼峰），组件大驼峰，index</p><h2 id="CSS-解决方案"><a href="#CSS-解决方案" class="headerlink" title="CSS 解决方案"></a>CSS 解决方案</h2><ul><li>tailwindcss 更高效好用的原子化的 CSS</li><li>CSS Modules 局部作用域 CSS</li><li>Sass/Less CSS 预处理器</li><li>Styled Components CSS in JS</li></ul><h2 id="路由方案"><a href="#路由方案" class="headerlink" title="路由方案"></a>路由方案</h2><ul><li>React Router DOM 路由</li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ul><li>命名规范</li><li>文件组织规范</li><li>css 规范</li><li>js 规范</li></ul><h2 id="Git-管理"><a href="#Git-管理" class="headerlink" title="Git 管理"></a>Git 管理</h2><ul><li>GitFlow 分支管理策略</li><li>Commit message 规范</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue3 开源项目】后台管理系统（Vue3 + TypeScript + Pinia）</title>
      <link href="/posts/30403/"/>
      <url>/posts/30403/</url>
      
        <content type="html"><![CDATA[<h2 id="【Vue3-开源项目】后台管理系统（Vue3-TypeScript-Pinia）"><a href="#【Vue3-开源项目】后台管理系统（Vue3-TypeScript-Pinia）" class="headerlink" title="【Vue3 开源项目】后台管理系统（Vue3 + TypeScript + Pinia）"></a>【Vue3 开源项目】后台管理系统（Vue3 + TypeScript + Pinia）</h2><p>基于 Vue3 全家桶开发的后台管理系统，<a href="https://vue3-management-system.vercel.app/login">线上地址在这</a>。适用于自学 Vue3 的同学，以及外包项目快速交付。</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>该项目使用技术栈如下：</p><ul><li><input checked="" disabled="" type="checkbox"> Vue 3：前端框架</li><li><input checked="" disabled="" type="checkbox"> TypeScript：语言</li><li><input checked="" disabled="" type="checkbox"> Vite：打包工具</li><li><input checked="" disabled="" type="checkbox"> Pinia：状态管理</li><li><input checked="" disabled="" type="checkbox"> Vue Router：路由管理</li><li><input checked="" disabled="" type="checkbox"> Element Plus：UI 组件库</li><li><input checked="" disabled="" type="checkbox"> Echarts：图表</li><li><input checked="" disabled="" type="checkbox"> Axios：网络请求</li></ul><h2 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h2><p>登录页： <img src= "/img/loading.gif" data-lazy-src="https://user-images.githubusercontent.com/51811652/227832497-7bc46908-d818-48ce-8ecd-bac57c3d9855.png" alt="image"></p><p>首页： <img src= "/img/loading.gif" data-lazy-src="https://user-images.githubusercontent.com/51811652/227833231-3b91552a-618f-41de-bbc1-fc6f68177a7d.png" alt="image"></p><p>表格： <img src= "/img/loading.gif" data-lazy-src="https://user-images.githubusercontent.com/51811652/227835053-4d680143-b165-4bbf-9f04-97c4a5422635.png" alt="image"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 克隆项目</span><br><span class="line">git clone https://github.com/HearLing/vue3-management-system.git</span><br><span class="line"></span><br><span class="line"># 进入项目目录</span><br><span class="line">cd vue3-management-system</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"># 本地开发，启动服务</span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"># 打包构建</span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"># ESLint修复</span><br><span class="line">npm run lint</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://preview.pro.ant.design/dashboard/analysis">参考项目</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://cn.vuejs.org">Vue3 中文文档</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://router.vuejs.org/zh/">Vue Router 中文文档</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://pinia.vuejs.org/zh/">Pinia 中文文档</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://element-plus.gitee.io/zh-CN/guide/quickstart.html">Element Plus 中文文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 模拟面试题</title>
      <link href="/posts/21007/"/>
      <url>/posts/21007/</url>
      
        <content type="html"><![CDATA[<h2 id="React-模拟面试题"><a href="#React-模拟面试题" class="headerlink" title="React 模拟面试题"></a>React 模拟面试题</h2><blockquote><p>之前总结了 Vue 相关的面试题，看的人没想到挺多的，但是也为我带来了不小的争议。虽然我有明确写出答案《仅供参考》但是还是有同学照抄呀，这么说呢就是你完全没有思考直接跟面试官对答，就算你没说错但也经不起细问的呀。</p></blockquote><p>废话不多说，俺还是比较关心大伙的春秋招面试准备得咋样了，面试的 React 复习得怎么样了呢？</p><p>如果你感觉在 React 这方面还比较薄弱的话，不如来做一做这套模拟面试吧，看看大伙能不能打个满分，祝你顺利~</p><p>🌸🌸🌸🌸🌸<strong>答案仅供参考</strong>🌸🌸🌸🌸🌸</p><p>欢迎访问<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes/issues">GitHub 仓库</a>，目前已经有 <code>552</code> 道大厂真题了，涵盖各类前端的真题。也可以访问我的 <a href="https://chodocs.cn/interview/">面试专栏</a> ，我的文章会第一时间更新在这。</p><h2 id="免杠声明"><a href="#免杠声明" class="headerlink" title="免杠声明"></a>免杠声明</h2><p>1、咱们是 <strong>模拟面试</strong> 并且是 <strong>React</strong> 专题 ，不是你真实面试的场景，咱们是把 React 面试题集中到了这场模拟面试中了。</p><p>2、因为是模拟面试，所以会有一些 <strong>情景导入</strong> 以及模拟面试官（也就是我）的 <strong>心理活动</strong>。目的是能让你有点被面试的感觉，以及让你了解一些面试官在想些什么。当然如果觉得啰嗦的话，直接点目录就可以到你想看的题了。</p><p>3、<font color="red"><strong>答案仅供参考</strong></font> <strong>答案会详略得当，不会面面俱到</strong>。我更偏向于告诉你，这个题第一层你可以怎么展开，第二层在你展开的这几点各自下面的重要点又是什么。至于你要不要扩充各个层级的点，以及要不要更深入增加层级，就是需要自己去思考和研究的了。</p><h2 id="—-进入正题化身为面试官-—"><a href="#—-进入正题化身为面试官-—" class="headerlink" title="—- 进入正题化身为面试官 —-"></a>—- 进入正题化身为面试官 —-</h2><p>📞📞 电话拨通中，喂～，听得到吗，听得到是吧 😊，那我们面试开始了，你先做个自我介绍吧。。。</p><blockquote><p>在你自我介绍的时候呢，我就看看你做过的项目，技术栈什么的。</p></blockquote><p>看你的项目经历写的是 React 项目，有写过其他项目嘛？你觉得 React 好在哪里呢？或者为什么选择 React 呢？</p><h2 id="1、简述一下-React？"><a href="#1、简述一下-React？" class="headerlink" title="1、简述一下 React？"></a>1、简述一下 React？</h2><p>首先要明确的是这是一个开发性的问题，他没有标准答案，目的其实更偏向于打开你的话匣子，所以这里可以尽量分维度的多说一些。同时这里要避免几个坑：第一是陷入一个点一直说（除非面试官显得很有兴趣），第二是说不到点子，第三是对比框架踩一捧一。</p><details><summary><b>参考答案</b></summary><p>(我这里写的比较全哦，比较概况，可以根据自己掌握情况做适当拓展)</p><p>1、一句话解释技术本质：React 是一个用于构建用户界面的 JavaScript 库。</p><p>2、核心概念：核心概念有三点，分别是声明式、组件化与 通用性。声明式-直观与组合。组件化-视图的拆分与模块复用，高内聚低耦合。通用性-一次学习，随处编写。</p><p>3、对比/优缺点：首先对比其他库比如 vue、jQuery，React 没有引入模板，而是通过 jsx 的语法编写组件化的 ui，代码更为简洁。其次 React 在减少操作 dom 等性能优化上采用的了虚拟 dom 的技术，现在这个技术被广泛的学习和认可。在者，React 提供的各种 hook，能让开发者编写更高效稳定的代码。最后，当然 React 也有缺点， 由于 React 并不是一个一揽子框架，所以导致在技术选型与学习使用上有比较高的成本。</p></details><blockquote><p>😶 至于为啥问这个问题，其实也是有点私心哈哈，毕竟这个问题你可以自己说出一些你认为 react 核心的东西，往往可能是 hook、虚拟 dom、组件化、jsx 等等，这种你说出来的我更乐意问，不然真的就像考试一样，拿着面试题一个个问了。这里可能我会顺着你说的 react 区别其他组件的点，顺着说，比如下面的这几个例子。</p></blockquote><p>诶，你刚刚说到了 JSX，那你说说什么是 JSX 呗？为什么 React 要使用 JSX？</p><h2 id="2、什么是-JSX，为什么要使用-JSX？"><a href="#2、什么是-JSX，为什么要使用-JSX？" class="headerlink" title="2、什么是 JSX，为什么要使用 JSX？"></a>2、什么是 JSX，为什么要使用 JSX？</h2><details><summary><b>参考答案</b></summary>是什么？：<p>JSX 是一个 JavaScript 的语法扩展，结构类似 XML。JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。</p><p>为什么？：</p><p>1、JSX 是一个 JavaScript 的语法扩展，没有引入新概念，上手简单</p><p>2、JavaScript 的语法扩展+结构类似 XML，代码变得更为简洁，而且代码结构层次更为清晰。</p><p>3、结构类似 XML，React 需要将组件转化为虚拟 DOM 树，所以在编写代码时，实际上是在手写一棵结构树。而 XML 在树结构的描述上天生具有可读性强的优势。</p></details><p>听你有说到 hooks，我们公司现在项目基本都是用 hooks，那你自己有写过 hooks 嘛？说一下 useRef 的实际使用场景吧？</p><h2 id="3、详细说说某某-hook？"><a href="#3、详细说说某某-hook？" class="headerlink" title="3、详细说说某某 hook？"></a>3、详细说说某某 hook？</h2><blockquote><p>可能第一个问题你有说到 hooks 以及他的好处什么的，那么这下面这道题就是看看你对是不是只是停留在会说。这类问题主要考察你对 hooks 的熟练程度，至少需要答到，它什么时候用，以及需要注意的点。</p></blockquote><p>这里我就不一个个的列出 hook 了，就以 useRef 为例吧：</p><details><summary><b>参考答案</b></summary>useRef 的应用场景主要是：函数组件需有访问 dom 元素的场景，以及保持可变变量的场景。需要知道的是：ref.current 发生变化并不会造成 re-render; useRef 和 useState 不同，如果一个状态或者数据会影响 DOM 的渲染结果，一定要避免使用 useRef 来保持引用</details><h2 id="4、React-组件通信"><a href="#4、React-组件通信" class="headerlink" title="4、React 组件通信"></a>4、React 组件通信</h2><details><summary><b>参考答案</b></summary>父组件 => 子组件：<ul><li>Props</li><li>Instance Methods</li></ul><p>子组件 =&gt; 父组件：</p><ul><li>Callback Functions</li><li>Event Bubbling</li></ul><p>兄弟组件之间：</p><ul><li>Parent Component</li></ul><p>不太相关的组件之间：</p><ul><li>Context</li><li>Portals</li><li>Observer Pattern</li><li>Redux 等</li></ul></details><h2 id="——-源码考察分界线-——"><a href="#——-源码考察分界线-——" class="headerlink" title="—— 源码考察分界线 ——"></a>—— 源码考察分界线 ——</h2><blockquote><p>第三题也能聊到源码哈，下面的几道题是关于 React 核心的 架构 和虚拟 DOM 的。</p></blockquote><h2 id="5、setState-是同步更新还是异步更新？"><a href="#5、setState-是同步更新还是异步更新？" class="headerlink" title="5、setState 是同步更新还是异步更新？"></a>5、setState 是同步更新还是异步更新？</h2><details><summary><b>参考答案</b></summary>在源码中，通过 isBatchingUpdates 来判断 setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。一般认为，做异步设计是为了性能优化、减少渲染次数。<p>一般会被追问（也可以自己说）：在什么情况下 isBatchingUpdates 会为 true 呢？</p><ul><li><p>在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</p></li><li><p>在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</p></li></ul></details><p>有看过 React 的源码嘛？可以简单的向我描述一下 Fiber 架构吗</p><h2 id="6、简述-fiber-架构"><a href="#6、简述-fiber-架构" class="headerlink" title="6、简述 fiber 架构"></a>6、简述 fiber 架构</h2><details><summary><b>参考答案</b></summary>React16 开始的fiber架构可以分为三层，相较于React15，新增了Scheduler（调度器），Reconciler从递归处理虚拟DOM变为可中断的循环过程，：<ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler</li><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><p>官方也推荐了 <a href="https://github.com/acdlite/react-fiber-architecture">答案 1</a> 和 <a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e">答案 2</a> ，我这里基于此题，简单描述一下，什么是 Fiber ，以及解决了什么问题，怎么解决的（进阶）。</p><p><strong>是什么？</strong></p><p>Fiber 是 React 16 中采用的新协调（reconciliation）引擎，主要目标是支持虚拟 DOM 的渐进式渲染。</p><p><strong>解决了什么问题？</strong></p><p>Fiber 将原有的 Stack Reconciler 替换为 Fiber Reconciler，提高了复杂应用的可响应性和性能。</p><p><strong>怎么解决的</strong></p><ul><li>对大型复杂任务的分片。</li><li>对任务划分优先级，优先调度高优先级的任务。</li><li>调度过程中，可以对任务进行挂起、恢复、终止等操作。</li></ul><p>::: warning TODO 简述可能错在错误理解，后续会更新详细文章解答。 :::</p></details><h2 id="7、虚拟-DOM-的工作原理"><a href="#7、虚拟-DOM-的工作原理" class="headerlink" title="7、虚拟 DOM 的工作原理"></a>7、虚拟 DOM 的工作原理</h2><details><summary><b>参考答案</b></summary>这个问题可能就会让你摸不着头脑，要讲清一个技术的原理，我们只要从三大方面着手就行，是什么、为什么、怎么做。这个问题可能不会问的这么泛，可能会问更细一点，比如：什么是虚拟DOM，他有什么优缺点，如何实现虚拟DOM。<p><strong>什么是虚拟 DOM</strong></p><p>虚拟 DOM 实际上它只是一层对真实 DOM 的抽象，以 JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上。</p><p><strong>虚拟 DOM 优缺点</strong></p><p>优点：改善大规模 DOM 操作的性能、规避 XSS 风险、能以较低的成本实现跨平台开发。</p><p>缺点：内存占用较高，因为需要模拟整个网页的真实 DOM。高性能应用场景存在难以优化的情况，类似像 Google Earth 一类的高性能前端应用在技术选型上往往不会选择 React。</p><p><strong>如何实现虚拟 DOM</strong></p><p>1、h 函数，用 JS 对象模拟 DOM 树</p><p>2、render 函数，实现渲染，从 Virtual DOM 映射到真实 DOM</p><p>3、mount 函数，实现挂载</p><p>4、diff 算法:比较两棵虚拟 DOM 树的差异</p></details><p>那你再说说 React 的 Diff 算法是怎么实现的吧</p><h2 id="8、React-的-diff-算法"><a href="#8、React-的-diff-算法" class="headerlink" title="8、React 的 diff 算法"></a>8、React 的 diff 算法</h2><details><summary><b>参考答案</b></summary><p>diff 算法是一种对比两个树差异的一种算法，那在 React 里就是对比新旧树的差异了。那么我们可以说 React 中 Diff 算法的本质是：</p><p>对比 current Fiber</p><blockquote><p>如果该 DOM 节点已在页面中，current Fiber 代表该 DOM 节点对应的 Fiber 节点。</p></blockquote><p>和 JSX 对象</p><blockquote><p>即 ClassComponent 的 render 方法的返回结果，或 FunctionComponent 的调用结果。JSX 对象中包含描述 DOM 节点的信息。</p></blockquote><p>并且生成 workInProgress Fiber。</p><blockquote><p>如果该 DOM 节点将在本次更新中渲染到页面中，workInProgress Fiber 代表该 DOM 节点对应的 Fiber 节点。</p></blockquote><p>React 对 diff 算法的优化，毕竟要完全对比两棵树的复杂度是很大的，所以 React 的 diff 算法预设了三个限制：</p><ul><li><p>只对同级元素进行 Diff。如果一个 DOM 节点在前后两次更新中跨越了层级，那么 React 不会尝试复用他。</p></li><li><p>两个不同类型的元素会产生出不同的树。如果元素由 div 变为 p，React 会销毁 div 及其子孙节点，并新建 p 及其子孙节点。</p></li><li><p>开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定。</p></li></ul></details><h2 id="——-技术栈分界线-——"><a href="#——-技术栈分界线-——" class="headerlink" title="—— 技术栈分界线 ——"></a>—— 技术栈分界线 ——</h2><p>以上都是多少都可以问一问的题，下面的就涉及技术栈了。你可以理解为根据公司技术栈出题。也可以理解为和 React 强相关的技术栈出题。</p><p>::: tip 篇幅原因，只是挑选了一些面试中和 React 相关性比较强，且比较常见的问题。 :::</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>下面两道问题一般是公司存在 class 语法代码可能会问的题。打个比方：公司项目旧代码是用 class 写的，希望你来了能维护或者重构就会问一些 class 的知识。</p><h2 id="9、class-与-hooks-的区别-优劣"><a href="#9、class-与-hooks-的区别-优劣" class="headerlink" title="9、class 与 hooks 的区别/优劣"></a>9、class 与 hooks 的区别/优劣</h2><details><summary><b>参考答案</b></summary><ul><li><p>共同点是两者的功能和效果都是一样的，类组件和函数组件都可以作为基础组件展示 UI。</p></li><li><p>他们的设计理念不一样，一个是面向对象，一个是函数式。面向对象的核心是继承、生命周期等这些。而函数式 immutable（不变）、没有副作用、引用透明等这些特点。</p></li><li><p>Hooks 更优的原因： Hooks 有确定的输入输出，没有 this 指向问题，也不用 renderprops 或者 Hoc 去解决复用状态逻辑的问题，它是一个组合的思想，组合更优于继承。class 组件业务逻辑散落在生命周期中，Hooks 则淡化了生命周期的概念。Hooks 的函数组件可以提供比原先更细粒度的逻辑组织与复用，且能更好地适用于时间切片与并发模式。</p></li></ul></details><h2 id="10、聊聊-class-与-hook-的生命周期"><a href="#10、聊聊-class-与-hook-的生命周期" class="headerlink" title="10、聊聊 class 与 hook 的生命周期"></a>10、聊聊 class 与 hook 的生命周期</h2><details><summary><b>参考答案</b></summary>分为三个阶段 挂载->更新-> 卸载 （Error）<p>详细请看表格，其中标注 UNSAFE_ 的都是被弃用的，通过这个表格可知道各方法所处的时期：</p><table><thead><tr><th></th><th>Mount</th><th>Update</th><th>Unmount</th><th>Error</th></tr></thead><tbody><tr><td>Render 阶段</td><td>construct、getDerivedStateFromProps、UNSAFE_componentWillMount、Render</td><td>UNSAFE_componentWillReceiveProps、getDerivedStateFromProps、shouldComponentUpdate、UNSAFE_componentWillUpdate、Render</td><td></td><td>getDerivedStateFromError</td></tr><tr><td>commit 阶段</td><td>componentDidMount、getSnapshotBeforeUpdate</td><td>componentDidUpdate</td><td>componentWillUnmount</td><td>componentDidCatch</td></tr></tbody></table><ul><li><p>对于异步请求，应该放在 componentDidMount 中去操作。</p><blockquote><p>constructor：可以放，但从设计上而言不推荐。constructor 主要用于初始化 state 与函数绑定，不承载业务逻辑且现在已经很少使用了。componentWillMount：已被标记废弃，在新的异步渲染架构下会触发多次渲染，容易引发 Bug。</p></blockquote></li><li><p>getDerivedStateFromProps 容易编写反模式代码，使受控组件与非受控组件区分模糊。</p></li><li><p>UNSAFE_componentWillMount 被标记弃用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount 中。</p></li><li><p>UNSAFE_componentWillReceiveProps 被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。</p></li><li><p>shouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化。</p></li><li><p>UNSAFE_componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。</p></li><li><p>如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug。</p></li><li><p>如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。</p></li></ul></details><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>还有的公司 React 和 Vue 技术栈都有，你过来可能主要还是写 React 但是也希望你会一些 Vue。那么下面几道题你很可能会遇到。</p><p>情景导入：如果简历没写我可能会问，之前有写过 Vue 项目嘛？（有写过啊，就直接问，没写过就跳过这个技术栈）简历有写的话我就会说，我看你的 xxx 项目是用 Vue 写的，那。。。</p><h2 id="11、你觉得-React-与-Vue-的区别主要在哪呢？"><a href="#11、你觉得-React-与-Vue-的区别主要在哪呢？" class="headerlink" title="11、你觉得 React 与 Vue 的区别主要在哪呢？"></a>11、你觉得 React 与 Vue 的区别主要在哪呢？</h2><details><summary><b>参考答案</b></summary><p><strong>1、各自推崇的/核心思想</strong></p><ul><li><p>React 推崇函数式编程（纯组件），数据不可变以及单向数据流。函数式编程最大的好处是其无副作用（稳定性）和确定的输入输出（可测试性），所以通常说 React 适合大型应用。</p></li><li><p>Vue 推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定。尽可能的降低了前端开发的门槛。</p></li></ul><p><strong>2、写法差异</strong></p><ul><li><p>React 没有太多的概念和 api，推崇 all in js，使用 JSX 和 部分 hook 就能开发。通过原生 JS 实现模板中的常见语法，比如插值，条件，循环等，都是通过 JS 语法实现的。更加原生。要求更高的 js 能力，以及对设计模式（也可以说开发经验）的掌握。</p></li><li><p>Vue 是基于 template 模板 + options API。引入了较多的概念和 api，需要理解或记住大部分概念和 api 才能编写。更要求熟练使用官方概念和 api。</p></li></ul><p><strong>3、数据流</strong></p><ul><li><p>React 提倡的是单向数据流，数据不可变，需要 setState 驱动新的 State 替换老的 State。</p></li><li><p>Vue 数据被观测是双向绑定的，省去了数据手动处理更加便捷。</p></li></ul><p><strong>4、Render（渲染过程）</strong></p><ul><li><p>React 在应用的状态被改变时，全部子组件都会重新渲染。通过 shouldComponentUpdate 这个生命周期方法可以进行控制，但 Vue 将此视为默认的优化。</p></li><li><p>Vue 可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p></li></ul><p><strong>5、事件机制</strong></p><ul><li><p>React 原生事件被包装，所有事件都冒泡到顶层 document 监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和 Web DOM 强绑定。React 组件上无事件，父子组件通信使用 props。</p></li><li><p>Vue 原生事件使用标准 Web 事件，Vue 组件自定义事件机制，是父子组件通信基础，Vue 合理利用了 snabbdom 库的模块插件</p></li></ul><p>6、<font color=gray>diff 算法实现</font></p><ul><li><p>React 主要使用 diff 队列保存需要更新哪些 DOM，得到 patch 树，再统一操作批量更新 DOM。</p></li><li><p>Vue Diff 使用双向链表，边对比，边更新 DOM。</p></li></ul><p>7、<font color=gray>社区和未来发展</font></p><blockquote><p>注意两者处于不同赛道，不存在谁取代谁这一说法，别踩一捧一。</p></blockquote><ul><li><p>React 只关注底层，上层应用解决方案交给社区，造就了 React 社区繁荣，同时 React 团队有更多时间专注底层。未来 React 的发展依然会在 函数式编程 这个核心思想的下进行升级。</p></li><li><p>Vue 提供了一揽子全家桶解决方案，比如 Vuex、Vue-Router、Vue-CLI、Vutur 工具等。减少选择困难症，只需认准官方给出的解决方案即可。Vue 依然会定位简单易上手（渐进式开发），依然是考虑通过依赖收集来实现数据可变。</p></li></ul></details><h2 id="12、vuex-与-redux-的区别"><a href="#12、vuex-与-redux-的区别" class="headerlink" title="12、vuex 与 redux 的区别"></a>12、vuex 与 redux 的区别</h2><details><summary><b>参考答案</b></summary><p><strong>从使用上来说</strong></p><ul><li><p>在 Vuex 中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store 来读取数据。</p></li><li><p>在 Redux 中，我们每一个组件都需要显式的用 connect 把需要的 props 和 dispatch 连接起来。</p></li><li><p>Vuex 更加灵活一些，组件中既可以 dispatch action，也可以 commit updates，而 Redux 中只能进行 dispatch，不能直接调用 reducer 进行修改。</p></li></ul><p><strong>从实现原理来说</strong></p><ul><li><p>Redux 使用的是不可变数据，而 Vuex 的数据是可变的。</p></li><li><p>Redux 每次都是用新 state 替换旧 state，而 Vuex 是直接修改。</p></li><li><p>Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过 getter/setter 来比较的。</p></li></ul></details><h2 id="状态-路由"><a href="#状态-路由" class="headerlink" title="状态/路由"></a>状态/路由</h2><h2 id="13、flux-状态管理"><a href="#13、flux-状态管理" class="headerlink" title="13、flux 状态管理"></a>13、flux 状态管理</h2><details><summary><b>参考答案</b></summary><p>Flux 是一种基于单向数据流的架构。架构如图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4876bf2f94ee4bc2a9a68a0e75e360bf~tplv-k3u1fbpfcp-watermark.image?" alt="flux.png"></p><p>具体流程：Store 存储了视图层所有的数据，当 Store 变化后会引起 View 层的更新。如果在视图层触发 Action，比如点击一个按钮，当前的页面数据值会发生变化。Action 会被 Dispatcher 进行统一的收发处理，传递给 Store 层。由于 Store 层已经注册过相关 Action 的处理逻辑，处理对应的内部状态变化后，会触发 View 层更新。</p></details><h2 id="14、简述-redux-状态管理"><a href="#14、简述-redux-状态管理" class="headerlink" title="14、简述 redux 状态管理"></a>14、简述 redux 状态管理</h2><details><summary><b>参考答案</b></summary><p><strong>核心设计</strong></p><p>包含了三大原则：单一数据源、纯函数 Reducer、State 是只读的。</p><p>一个核心点是处理“副作用”。</p><ul><li>第一类是在 Dispatch 的时候会有一个 middleware 中间件层，拦截分发的 Action 并添加额外的复杂行为，还可以添加副作用。</li><li>第二类是允许 Reducer 层中直接处理副作用，采取该方案的有 React Loop，React Loop 在实现中采用了 Elm 中分形的思想，使代码具备更强的组合能力。</li></ul><blockquote><p>AJAX 请求等异步工作，或不是纯函数产生的第三方的交互都被认为是 “副作用”</p></blockquote><p><strong>数据流</strong></p><p>Redux  中整个数据流的方案与 Flux 大同小异。</p><p>首先是 dispatch 一个 action。然后 reducer 会收到这个 action, 根据这个 action 对状态进行修改。状态修改以后会被处理容器捕捉到。从而对相关的界面进行更新。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/24/1642fe4239346286~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="redux.png"></p><p><font color=gray>另外一些需要知道的</font></p><ul><li>Store，Store 存放应用程序的状态，并且有帮助函数来访问这些状态。Store 可以用来聆听变化和发送 action。Store 只有一个。</li><li>Reducers，数据的状态是通过 reducer 函数来改变的。</li><li>Actions，Actions 代表的是一个对象。有两部分，一个是 action 本身，另一个就是它的 payload。简单说就是对哪些数据进行哪些操作。</li><li>React-Redux，Redux 本身和 React 没有关系，只是数据处理中心，是 React-Redux 让他们联系在一起。React-rRedux 提供两个方法：connect 和 Provider。</li></ul></details><h2 id="15、mobx-和-redux-有什么区别？"><a href="#15、mobx-和-redux-有什么区别？" class="headerlink" title="15、mobx 和 redux 有什么区别？"></a>15、mobx 和 redux 有什么区别？</h2><details><summary><b>参考答案</b></summary><ul><li>核心的差异：Redux 是单向数据流，Mobx 则是通过监听数据的属性变化，直接在数据上更改来触发 UI 的渲染。</li><li>redux 是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数。mobx 中的状态是可变的，可以直接对其进行修改。</li><li>mobx 结果也难以预测，调试会比较困难。redux 提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li></ul></details><h2 id="16、React-Router-的实现原理是什么？"><a href="#16、React-Router-的实现原理是什么？" class="headerlink" title="16、React-Router 的实现原理是什么？"></a>16、React-Router 的实现原理是什么？</h2><details><summary><b>参考答案</b></summary><p>基于 history 库来实现不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知。</p><blockquote><p>不同的客户端路由实现思想:1、基于 hash 的路由：通过监听 hashchange 事件，感知 &gt; hash 的变化。通过 location.hash=xxx 改变 hash 。2、基于 H5 history 路由：通过自定义事件触发实现监听 url 的变化。可以通过 history.pushState 和 resplaceState 等改变 url ，会将 URL 压入堆栈，同时能够应用 history.go() 等 API。</p></blockquote><p>通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render。</p></details><h2 id="17、React-Router-实现路由切换"><a href="#17、React-Router-实现路由切换" class="headerlink" title="17、React-Router 实现路由切换"></a>17、React-Router 实现路由切换</h2><details><summary><b>参考答案</b></summary>有几种方式：<ul><li><p>使用 <code>&lt;Route&gt;</code> ，会比较 <code>&lt;Route&gt;</code> 的 path 属性和当前地址的 pathname 实现路由切换。</p></li><li><p>使用 <code>&lt;Switch&gt;</code> 会遍历其所有的子 <code>&lt;Route&gt;</code> 元素，并仅渲染与当前地址匹配的第一个元素。</p></li><li><p>使用<code>&lt;Link&gt;</code>、 <code>&lt;NavLink&gt;</code>、<code>&lt;Redirect&gt;</code>，会在你的应用程序中创建链接，通过 to 属性与当前地址匹配。</p></li></ul></details><h2 id="18、React-Router-如何获取-URL-的参数和历史对象？"><a href="#18、React-Router-如何获取-URL-的参数和历史对象？" class="headerlink" title="18、React-Router 如何获取 URL 的参数和历史对象？"></a>18、React-Router 如何获取 URL 的参数和历史对象？</h2><details><summary><b>参考答案</b></summary><ul><li>get 传值：通过 location.search 获取 url 获取到一个字符串’?id=’1111’，通过浏览器的 URLSearchParams api 或自封装字符串解析方法解析出 id 的值。</li><li>动态路由传值：通过 match.params.id 或者 useParams（Hooks）取得 url 中的动态路由 id 部分的值</li><li>通过 query 或 state 传值：to 属性传递对象或数组时，通过 location.state 或 location.query 来获取即可，但是存在缺点就是，只要刷新页面参数就会丢失。</details></li></ul><h2 id="——-设计模式-代码优化-——"><a href="#——-设计模式-代码优化-——" class="headerlink" title="—— 设计模式/代码优化 ——"></a>—— 设计模式/代码优化 ——</h2><p>React 是对设计模式的能力很有要求的，这里只列举和 React 强相关的设计模式。</p><p>::: warning TODO 更详细的设计模式文章，待更新至设计模式专栏 :::</p><h2 id="19、HOC"><a href="#19、HOC" class="headerlink" title="19、HOC"></a>19、HOC</h2><details><summary><b>参考答案</b></summary><blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p></blockquote><p>在我们的应用程序中，我们经常希望在多个组件中使用相同的逻辑。此逻辑可以包括将特定样式应用于组件、要求授权或添加全局状态。</p><p>能够在多个组件中重用相同逻辑的一种方法就是使用高阶组件模式。这种模式允许我们在整个应用程序中重用组件逻辑。</p><p>具体而言，高阶组件是参数为组件，返回值为新组件的函数。HOC 包含我们想要应用于作为参数传递的组件的某些逻辑。应用该逻辑后，HOC 返回带有附加逻辑的元素。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOC模式例子</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withStyles</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> style = &#123; <span class="attr">padding</span>: <span class="string">&quot;0.2rem&quot;</span>, <span class="attr">margin</span>: <span class="string">&quot;1rem&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Text</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StyledButton</span> = <span class="title function_">withStyles</span>(<span class="title class_">Button</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StyledText</span> = <span class="title function_">withStyles</span>(<span class="title class_">Text</span>);</span><br></pre></td></tr></table></figure></details><h2 id="20、Render-Props"><a href="#20、Render-Props" class="headerlink" title="20、Render Props"></a>20、Render Props</h2><details><summary><b>参考答案</b></summary><blockquote><p>术语 “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p></blockquote><p>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Render Props模式例子</span></span><br><span class="line">&lt;<span class="title class_">DataProvider</span> render=&#123;<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;data.target&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure></details><h2 id="21、非受控组件"><a href="#21、非受控组件" class="headerlink" title="21、非受控组件"></a>21、非受控组件</h2><details><summary><b>参考答案</b></summary><blockquote><p>在大多数情况下，推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。</p></blockquote><p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非受控组件例子</span><br><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">    this.input = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&#x27;A name was submitted: &#x27; + this.input.current.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=&quot;text&quot; ref=&#123;this.input&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="——-性能优化-——"><a href="#——-性能优化-——" class="headerlink" title="—— 性能优化 ——"></a>—— 性能优化 ——</h2><h2 id="22、如何发现以及分析性能问题"><a href="#22、如何发现以及分析性能问题" class="headerlink" title="22、如何发现以及分析性能问题"></a>22、如何发现以及分析性能问题</h2><details><summary><b>参考答案</b></summary>肉眼可见的性能问题，如白屏、卡顿、加载时间很长，一般是要答带数据的优化。<ol><li><p>lightHouse 的评分，可以作为优化依据。</p></li><li><p>React 性能检测的一些工具也可以：Profiler 能测出 reRender 的耗时，平常对数据要求不严也就是不需要准确测出 rerender 的时间的话可以使用 ReactDevtool。</p></li><li><p>浏览器开发者工具可以检测到大部分的性能数据：</p></li></ol><ul><li><p>网络面板的一些优化方案：</p><ol><li>阻塞或者排队，由于一个域名最多维护 6 个链接，可以做域名分片或者多个域名。</li><li>网络原因可以用 CDN 缓存</li><li>下载时间过长可以压缩或者 webpack 打包优化。</li></ol></li><li><p>performance：</p><ol><li>FPS （Frames Per Second）每秒传输帧数，发现页面帧速图表出现红色块，代表一帧所需时间过长-&gt;卡顿。</li><li>CPU 图表显示占得面积太大，可能某个 js 占用太多主线程时间</li><li>V8 内存使用凸显一直上升，内存泄漏可能存在</li></ol></li></ul></details><h2 id="23、怎么做性能优化"><a href="#23、怎么做性能优化" class="headerlink" title="23、怎么做性能优化"></a>23、怎么做性能优化</h2><details><summary><b>参考答案</b></summary><p><strong>1、写 React 代码的优化</strong></p><p>减少计算</p><ol><li>增加 key</li><li>commit 阶段减少耗时操作</li><li>一些 hook ： useMemo、useCallback、React.Memo 4. setState 将多个合并，或者用 ustable_batchedUpdate 批量更新</li></ol><p>精细化渲染</p><ol><li>优先用户响应，耗时任务放到下一个宏任务。“关闭弹窗类似的场景”</li><li>usecontext 跳过中间组件 ，发布订阅模式，redux</li><li>useMemo 也可以跳过 render</li></ol><p>控制范围</p><ol><li>防抖节流</li><li>懒渲染（”虚拟列表”）、懒加载（webPack）</li><li>避免在 didMount 或 didUpdate 中更新 state</li></ol><p><strong>2、webpack 的优化（除去开发环境的优化）</strong></p><p>打包速度</p><ol><li>onOf、external 可以跳过 loader 的查找，除去一些不打包</li><li>babel 缓存，可以对运行结果缓存</li><li>多进程打包 thread-loader</li></ol><p>运行性能</p><ol><li>文件资源缓存 hash、chunkhash、contenthash，这几个的区别也要明白</li><li>treeShacking</li><li>code split</li><li>懒加载、预加载（某些浏览器不支持）</li><li>离线可访问 pwa （也是一种优化，但用的不多）</li></ol><p><strong>3、网络等优化</strong></p><ol><li>CDN 缓存</li><li>域名分片</li><li>文件压缩</li><li>DNS 预解析，提前解析之后可能会用到的域名</li></ol></details><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>⭐️ 虽然说现在大环境不好，工作难找但还是衷心希望各位准备面试的小伙伴面试顺利~，收割 offer，我们一起加油吧 🤝！还有就是新年快乐 ❤️ ~</p><p>🚀 文章还有不足，如果你有意向，很欢迎你可以加入我们，文章后续会持续更新~</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「前端设计模式」- 中介模式深入理解</title>
      <link href="/posts/20709/"/>
      <url>/posts/20709/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底搞懂了异步场景面试题，多种题解</title>
      <link href="/posts/20406/"/>
      <url>/posts/20406/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写这篇文章，是因为在最近一次字节的面试中，一道异步题，我写不出来，并且没什么思路。于是我痛定思痛，必须搞明白，才有了这篇文章。如果觉得有用，点赞支持一下，抚慰我我受伤的心灵 ~~</p><p>本文我将尽量使用 <code>setTimeout、promise、async/await</code> 这三种方式写出题解。</p><h2 id="实现每隔-1-秒输出-1-2-3"><a href="#实现每隔-1-秒输出-1-2-3" class="headerlink" title="实现每隔 1 秒输出 1,2,3"></a>实现每隔 1 秒输出 1,2,3</h2><p>不要看这道题简单，其实有很多可以考察。我们从简单开始理解再到复杂。</p><p>此题的变形有：实现每隔<code>1</code>秒请求接口，实现每隔几秒刷新时间，或者换个间隔时间等等，换汤不换药，为了更好适应变形写出其他题，这里用数组<code>arr</code>存数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共代码</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="setTimeout-实现"><a href="#setTimeout-实现" class="headerlink" title="setTimeout 实现"></a>setTimeout 实现</h3><p>使用回调嵌套，注意记录 <code>count</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">count = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (count === arr.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[count]);</span><br><span class="line">    <span class="title function_">timeout</span>(++count);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">timeout</span>();</span><br></pre></td></tr></table></figure><h3 id="promise-实现"><a href="#promise-实现" class="headerlink" title="promise 实现"></a>promise 实现</h3><p>通过不停的在 <code>promise</code> 后面叠加 <code>.then</code> ，实现间隔输出，这里也可以用 <code>for</code>，但是就相当于用 <code>for</code> 实现 <code>reduce</code> 了，所以这里直接用 <code>reduce</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">r</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br></pre></td></tr></table></figure><h3 id="async-实现"><a href="#async-实现" class="headerlink" title="async 实现"></a>async 实现</h3><p>在 <code>setTimeout</code> 实现的基础上改，需要将函数包装为 <code>async</code> 函数，<code>await</code> 后跟的函数应该返回 <code>promise</code>，在 <code>promise</code> 里间隔一秒再 <code>resolve</code> ，这样就实现了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title function_">_promise</span>(arr[i]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_promise</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">timer</span>();</span><br></pre></td></tr></table></figure><h2 id="红绿灯交替重复亮"><a href="#红绿灯交替重复亮" class="headerlink" title="红绿灯交替重复亮"></a>红绿灯交替重复亮</h2><p>也是一道经典的面试题了，显然这里要递归调用，还需要确保顺序执行：我把这道题抽象一下：“有几个函数，我希望按顺序每间隔一定时间链式执行，如此循环”</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">red</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">green</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setTimeout-实现-1"><a href="#setTimeout-实现-1" class="headerlink" title="setTimeout 实现"></a>setTimeout 实现</h3><p>显然面试官并不想看到你这样写，我也不打算写的~~ ，但是想起一位伟人说过的话：“只要能做出来，总比屁都憋不出的好”，于是我写了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">red</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">green</span>();</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">yellow</span>();</span><br><span class="line">        <span class="title function_">light</span>();</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">light</span>();</span><br></pre></td></tr></table></figure><p>效果是确实三秒 <code>red</code> 、两秒 <code>green</code> 和一秒 <code>yellow</code> ，诶，还能递归，我愿称之为“暴力”，当然它还有一个响亮的名字“回调地狱”。</p><p>好了，应该不用我多说回调地狱的坏处吧，来看 <code>Promise</code> 的实现：</p><h3 id="promise-实现-1"><a href="#promise-实现-1" class="headerlink" title="promise 实现"></a>promise 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="keyword">function</span> (<span class="params">cb, time</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cb</span>();</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> step = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">light</span>(red, <span class="number">3000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">light</span>(green, <span class="number">2000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">light</span>(yellow, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">step</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">step</span>();</span><br></pre></td></tr></table></figure><h3 id="async-实现-1"><a href="#async-实现-1" class="headerlink" title="async 实现"></a>async 实现</h3><p>用 <code>Promise</code> 写会发现我们的代码长度很长，要是有十个灯就要写 <code>10</code> 个 <code>then</code> ，那有没有更简洁优雅的写法呢？当然、<code>promise</code> 能写出来，换成 <code>async</code> 来写更是轻轻松松咯：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">light</span>(<span class="params">cb, timer</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cb</span>();</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">light</span>(red, <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">light</span>(green, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">light</span>(yellow, <span class="number">1000</span>);</span><br><span class="line">  <span class="title function_">step</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">step</span>();</span><br></pre></td></tr></table></figure><p>以下三个题目就不用 <code>setTimeout</code> 实现了，技术价值不大，或者有哪位友人有想法，可以评论留言给我~~</p><h2 id="链式异步请求"><a href="#链式异步请求" class="headerlink" title="链式异步请求"></a>链式异步请求</h2><p>有一个请求数组，要求按序执行并保存数据。类似于，先干一件事，这件事干完再干另一件事，我把这类题概括为链式请求。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">time, val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="title function_">resolve</span>(), time);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax1</span> = (<span class="params"></span>) =&gt; <span class="title function_">test</span>(<span class="number">1000</span>, <span class="number">1</span>),</span><br><span class="line">  ajax2 = <span class="function">() =&gt;</span> <span class="title function_">test</span>(<span class="number">3000</span>, <span class="number">2</span>),</span><br><span class="line">  ajax3 = <span class="function">() =&gt;</span> <span class="title function_">test</span>(<span class="number">2000</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="promise-实现-2"><a href="#promise-实现-2" class="headerlink" title="promise 实现"></a>promise 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergePromise</span>(<span class="params">ajaxArray</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">  ajaxArray.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ajax</span>) =&gt;</span> &#123;</span><br><span class="line">    promise = promise.<span class="title function_">then</span>(ajax).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      data.<span class="title function_">push</span>(res);</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergePromise</span>([ajax1, ajax2, ajax3]).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="async-实现-2"><a href="#async-实现-2" class="headerlink" title="async 实现"></a>async 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">mergePromise</span>(<span class="params">ajaxArray</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  ajaxArray.<span class="title function_">forEach</span>(<span class="keyword">async</span> (ajax) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">ajax</span>();</span><br><span class="line">    data.<span class="title function_">push</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发调度"><a href="#并发调度" class="headerlink" title="并发调度"></a>并发调度</h2><p>这类题目有很多，核心考察就是 <strong>限制运行任务的数量</strong>。</p><p>为了能快速理解，我先讲一个通俗的例子：首先要限制数量，我们可以用一个栈，栈不能超过两格（假设限制数量为<code>2</code>），当放进去的两个任务，一个快一些先执行完，那么弹出该任务，接下一个，如此类推。。。</p><blockquote><p>进阶：两个请求一直占着位置，没有请求回数据，因为它们没执行完成导致后面的请求也进不来，导致阻塞，怎么办呢。。。第一肯定是要判断阻塞，两个请求占的时间过久。第二记录这两个请求并清空栈，允许其他链接请求。最后根据场景，对数据进行处理，比如你需要对没请求的数据再重新请求，或者提示等。</p></blockquote><p>为了展示更加直观，我选了最经典的一道面试题：</p><h3 id="setTimeout-实现-2"><a href="#setTimeout-实现-2" class="headerlink" title="setTimeout 实现"></a>setTimeout 实现</h3><p>用 <code>setTimeout</code> 实现需要 <strong>注意</strong> 的是它是直接 <code>add</code> 的 <code>time</code> 和 <code>val</code> ，而不是返回 <code>promise</code> 的函数，所以可以在 <code>add</code> 里实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设计并发调度器， 最多允许两个任务运行</span></span><br><span class="line"><span class="keyword">const</span> scheduler = <span class="keyword">new</span> <span class="title class_">Scheduler</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//这里的timer有的会写1有的会直接写1000，需要灵活解题</span></span><br><span class="line">scheduler.<span class="title function_">addTask</span>(<span class="number">5</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">scheduler.<span class="title function_">addTask</span>(<span class="number">3</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">scheduler.<span class="title function_">addTask</span>(<span class="number">1</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">scheduler.<span class="title function_">addTask</span>(<span class="number">2</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">scheduler.<span class="title function_">start</span>();</span><br><span class="line"><span class="comment">//输出:2314</span></span><br></pre></td></tr></table></figure><p>思路：</p><ol><li>用一个 <code>count</code> 记录并发的数量，用一个 <code>taskList</code> 数组保存任务。</li><li><code>addTask</code> 如名字，将任务一一存入 <code>taskList</code> 。</li><li>递归调用 <code>start</code> ，递归结束条件没有数据了，进入条件没有超过并发数。再通过 <code>count</code> 记录并发数量，从数组取出来一个 <code>count++</code> ，执行完一个 <code>count--</code> 。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">maxNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">maxNum</span> = maxNum;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskList</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="params">time, val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskList</span>.<span class="title function_">push</span>([time, val]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">taskList</span>.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &lt; <span class="variable language_">this</span>.<span class="property">maxNum</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> [time, val] = <span class="variable language_">this</span>.<span class="property">taskList</span>.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">start</span>();</span><br><span class="line">      &#125;, time * <span class="number">1000</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise-实现-3"><a href="#promise-实现-3" class="headerlink" title="promise 实现"></a>promise 实现</h3><p>用 <code>promise</code> 写的话，实例代码就应该是下面这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">timeout</span> = (<span class="params">time</span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scheduler = <span class="keyword">new</span> <span class="title class_">Scheduler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addTask</span> = (<span class="params">time, order</span>) =&gt; &#123;</span><br><span class="line">  scheduler.<span class="title function_">add</span>(<span class="function">() =&gt;</span> <span class="title function_">timeout</span>(time).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(order)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">5000</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">3000</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">1000</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">2000</span>, <span class="string">&quot;4&quot;</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是使用 <code>promise</code> 实现的话也是离不开循环 <code>.then</code> 的，所以我们抽出一个函数来实现 <code>then</code> 的链式调用。</p><ol><li>需要一个函数来实现 <code>add</code> 记录要执行的 <code>promiseCreator</code> ，还需要一个函数在执行的时候就去第一个就可以了。</li><li>要求只有一个 <code>add</code> 函数，所以我们需要在 <code>add</code> 里记录 <code>promiseCreator</code> 以及执行 <code>run</code> 。</li><li><code>run</code> 来触发异步函数的执行，这里的触发有两处，一处为 <code>add</code> 一个 <code>promise</code> 就 <code>run</code> ，另一个是自己执行完一个再 <code>then</code> 里执行 <code>run</code> ，当大于 <code>max</code> 时阻止继续 <code>run</code> 。<blockquote><p>这里如果想不明白的话，可以换一个生活里的场景。比如吃火锅，我喜欢吃虾滑，虾滑一个个下锅，煮熟就把它放到碗里，可碗就那么大只能放两个虾滑，吃一个才能从锅里取一个，直到锅里没有虾滑了。相信有了上述的这个场景，你能写出不一样的题解，这是我实现的既符合题意又相对简洁的 promise 实现：</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskList</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">maxNum</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">promiseCreator</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskList</span>.<span class="title function_">push</span>(promiseCreator);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &gt;= <span class="variable language_">this</span>.<span class="property">maxNum</span> || <span class="variable language_">this</span>.<span class="property">taskList</span>.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskList</span></span><br><span class="line">      .<span class="title function_">shift</span>()()</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async-实现-3"><a href="#async-实现-3" class="headerlink" title="async 实现"></a>async 实现</h3><p>最简单地写法还得是 <code>async</code> （这里换了一种写法，你也可以用类实现），然后帮助理解如果没有 <code>start</code> 函数，怎么直接在 <code>add</code> 函数中实现逻辑：</p><ol><li>用一个 <code>count</code> 记录并发的数量，用一个 <code>taskList</code> 数组保存任务。</li><li>异步函数 <code>add</code> 接受异步任务返回 <code>promise</code> 。</li><li>这里没有递归调用， <code>add</code> 一个异步任务，就执行，并用 <code>count</code> 记录并发数量。</li><li>关键思想：当并发数超过限制，我们 <code>await</code> 一个不被 <code>resolve</code> 的 <code>promise</code> ，当完成了一个请求有位置了，才 <code>resolve</code>。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scheduler</span>(<span class="params">maxNum</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> taskList = [];</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">promiseCreator</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= maxNum) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        taskList.<span class="title function_">push</span>(resolve);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">promiseCreator</span>();</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (taskList.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      taskList.<span class="title function_">shift</span>()();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="待优化"><a href="#待优化" class="headerlink" title="待优化"></a>待优化</h2><p>依旧是根据场景来的，如果并发的两个任务，一直没被处理，那么会一直等待导致后面的请求也发不了。为了防止这种阻塞，可以怎样优化呢？如果你有好的想法，非常欢迎在评论区留言，❤ღ( ´･ᴗ･` )。</p><h2 id="promise-手写"><a href="#promise-手写" class="headerlink" title="promise 手写"></a>promise 手写</h2><p>这一部分建议看 <code>PromiseA+</code> 实现，掘金有相关文章，我自己也看过也实践过完整一遍的 <code>promise</code> 手写，这里建议自己手写一遍，如果想了解的更细节循序渐进的写的话，可以搜 B 站的高赞 <code>Promise</code> 实现视频（防止有打广告嫌疑就不放链接了）跟着写。</p><p>这里我写一个最基础的 <code>Promise</code> 实现手写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span>(<span class="params"></span>) &#123;</span><br><span class="line">  self.<span class="property">status</span> = <span class="string">&quot;pending&quot;</span>; <span class="comment">// 默认的状态,只能改变一次</span></span><br><span class="line">  self.<span class="property">value</span> = <span class="literal">null</span>; <span class="comment">// 成功的值</span></span><br><span class="line">  self.<span class="property">reason</span> = <span class="literal">null</span>; <span class="comment">// 失败的原因</span></span><br><span class="line">  self.<span class="property">onFulfilledCb</span> = []; <span class="comment">// 存放then成功的回调</span></span><br><span class="line">  self.<span class="property">onRejectedCb</span> = []; <span class="comment">// 存放then失败的回调</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.<span class="property">status</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">      self.<span class="property">value</span> = value;</span><br><span class="line">      self.<span class="property">onFulfilledCb</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.<span class="property">status</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      self.<span class="property">reason</span> = reason;</span><br><span class="line">      self.<span class="property">onRejectedCb</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 抛出错误，走失败的方法</span></span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">onFulfilled</span>(self.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO 这里需要注意只能实现Promise实例可以多次.then没有实现then的链式调用（需要返回一个新的Promise）</span></span><br><span class="line">    <span class="comment">// 将成功的回调添加到数组中</span></span><br><span class="line">    self.<span class="property">onFulfilledCb</span>.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">onFulfilled</span>(self.<span class="property">value</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    self.<span class="property">onRejectedCb</span>.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p><code>Promise.all</code> 实现思路：</p><ul><li>批量执行 <code>Promise</code>，返回一个 <code>promise</code> 实例；</li><li>全部成功才算成功，返回全部执行结果；</li><li>有一个失败就算失败，返回第一个失败结果；</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> all = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将成功结果放入数组中对应的位置</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">processSuccess</span> = (<span class="params">index, val</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// result.push(val); //使用push异步会出现混乱的情况</span></span><br><span class="line">      result[index] = val;</span><br><span class="line">      <span class="keyword">if</span> (++times === promises.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(result); <span class="comment">// 全部执行成功，返回 result</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历处理集合中的每一个 promise</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (p &amp;&amp; <span class="keyword">typeof</span> p.<span class="property">then</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用这个p的 then 方法</span></span><br><span class="line">        p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 按照执行顺序存放执行结果</span></span><br><span class="line">          <span class="title function_">processSuccess</span>(i, data);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 普通值，直接按照执行顺序放入数组对应位置</span></span><br><span class="line">        <span class="title function_">processSuccess</span>(i, p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以简化这个代码，但是注意测试不要写错了：测试代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;val = 1; timeout = 1000&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(&quot;reason = 2; timeout = 3000&quot;)</span></span><br><span class="line">      <span class="comment">// reject()</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;val = 2; timeout = 3000&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;val = 3; timeout = 2000&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="number">4</span>,</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then&quot;</span>, data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch&quot;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p><code>Promise.race</code> 实现思路：谁快就返回谁</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> race = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (p &amp;&amp; <span class="keyword">typeof</span> p.<span class="property">then</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        p.<span class="title function_">then</span>(resolve, reject); <span class="comment">// 使用第一个执行成功的结果</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面这两个虽然我没有看到过在那个面试出现过，但是还是还是列出来，你可以看成前面知识都理解后的加餐，不难的。</p><h3 id="Promise-allsettled"><a href="#Promise-allsettled" class="headerlink" title="Promise.allsettled"></a>Promise.allsettled</h3><ul><li>存在失败结果也会拿到全部执行结果，不会走 <code>catch</code>；</li><li>解决了 <code>Promise.all</code> 不能拿到失败执行结果的问题； <code>Promise.allsettled</code> 以及 <code>Promise.any</code> 测试代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="title function_">resolve</span>(<span class="number">2</span>), <span class="number">2000</span>));</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="title function_">reject</span>(<span class="number">3</span>), <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1, p2, p3, <span class="number">4</span>]).<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res&quot;</span>, results)</span><br><span class="line">  <span class="comment">/**输出:</span></span><br><span class="line"><span class="comment">   *  res [&#123; status: &#x27;fulfilled&#x27;, value: 1 &#125;,</span></span><br><span class="line"><span class="comment">   * &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,</span></span><br><span class="line"><span class="comment">   * &#123; status: &#x27;rejected&#x27;, reason: 3 &#125;,</span></span><br><span class="line"><span class="comment">   * &#123; status: &#x27;fulfilled&#x27;, value: 4 &#125;]</span></span><br><span class="line"><span class="comment">   * */</span></span><br></pre></td></tr></table></figure><p>自实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">allSettled</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(promises.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (p &amp;&amp; <span class="keyword">typeof</span> p.<span class="property">then</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          result[i] = &#123; <span class="attr">status</span>: <span class="string">&quot;fulfilled&quot;</span>, <span class="attr">value</span>: data &#125;;</span><br><span class="line">          times++;</span><br><span class="line">          <span class="keyword">if</span> (times === promises.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          result[i] = &#123; <span class="attr">status</span>: <span class="string">&quot;rejected&quot;</span>, <span class="attr">reason</span>: err &#125;;</span><br><span class="line">          times++;</span><br><span class="line">          <span class="keyword">if</span> (times === promises.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[i] = &#123; <span class="attr">status</span>: <span class="string">&quot;fulfilled&quot;</span>, <span class="attr">value</span>: p &#125;;</span><br><span class="line">        times++;</span><br><span class="line">        <span class="keyword">if</span> (times === promises.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><ul><li>返回第一个成功结果，全部失败才返回失败；</li><li>解决了 <code>Promise.race</code> 只能拿到第一个执行完成（不管成功/失败）的结果；</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">any</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rejectedArr = [];</span><br><span class="line">  <span class="keyword">let</span> rejectedTimes = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises == <span class="literal">null</span> || promises.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;无效的 any&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (p &amp;&amp; <span class="keyword">typeof</span> p.<span class="property">then</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        p.<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(data); <span class="comment">// 使用最先成功的结果</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果失败了，保存错误信息；全失败，any 才失败</span></span><br><span class="line">            rejectedArr[i] = err;</span><br><span class="line">            rejectedTimes++;</span><br><span class="line">            <span class="keyword">if</span> (rejectedTimes === promises.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(rejectedArr);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上个测试用例：</span></span><br><span class="line"><span class="comment">/**输出:</span></span><br><span class="line"><span class="comment"> * res 4</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过这几个面试题的 <code>promise</code> 和 <code>async</code> 的分别实现，会发现使用 <code>promise</code> 虽然整个流程线性化，单还是会包含大量的 <code>then</code>。ES7 引入的<code>async/await</code>，可以说是 “回调地狱” 的终极解决方案，代码逻辑也更加清晰。</p><p>这篇文章总结了很久，也搜集了很多资料，真的希望你能一次学懂，而不是像我之前一样一知半解。</p><p>最后因为篇幅有限，这里只是针对面试题给出了我的解题思路和方案。而如果你还有其他的异步场景的面试题而我没有给出的，可以评论出来我们一起解决。或者有其他的建议或问题也可以评论出来，友好交流。</p><p>🌸 非常感谢你看到这，如果觉得不错的话点个赞 👍 或收藏 ⭐ 吧 ~~</p><p>今天也是在努力变强不变秃的  HearLing  呀 💪 🌸</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「前端设计模式」- 发布订阅/观察者模式深入理解</title>
      <link href="/posts/20402/"/>
      <url>/posts/20402/</url>
      
        <content type="html"><![CDATA[<h1 id="发布订阅-观察者模式"><a href="#发布订阅-观察者模式" class="headerlink" title="发布订阅/观察者模式"></a>发布订阅/观察者模式</h1><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p><h2 id="通俗的例子"><a href="#通俗的例子" class="headerlink" title="通俗的例子"></a>通俗的例子</h2><p>小玲最近迷上了看连载书，每天都在等更新，，，什么时候有书除了书店没有人能够知道。于是小玲隔三差五都会来书店看看出没出新版。除了小玲，还有张三、李四、王五也会来看更新了没。小玲不高兴，每天要跑来看有没有更新。书店不高兴，每天都有人问一样的问题。</p><p>当然现实中不会这么笨的处理：小玲离开之前，把电话号码留在了书店。书店答应他，新书一出就马上发信息通知，他们的电话号码都被记在花名册上，新书出的时候，书店会翻开花名册，依次发送一条短信来通知他们。</p><p><strong>优点：</strong></p><p>在这个例子中使用发布—订阅模式有着显而易见的优点：</p><ul><li>读者不用再天天向书店咨询，在合适的时间点，书店作为发布者会通知这些消息订阅者。</li><li>读者和书店之间不再强耦合在一起，当有新的读者出现时，他只需把手机号码留在书店，书店不关心读者的任何情况，不管读者是男是女。而书店的任何变动也不会影响读者，只要书店记得发布新书了给他们发短信这件事情。</li></ul><p>由优点可以见得：</p><ul><li><p>第一优点</p><ul><li>发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。</li><li>在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。</li></ul></li><li><p>第二个优点</p><ul><li>发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。</li><li>发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。</li><li>当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</li></ul></li></ul><h2 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h2><p>实际上，只要我们曾经在 <code>DOM</code> 节点上面绑定过事件函数，那我们就曾经使用过发布—订阅模式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">click</span>(); <span class="comment">//模拟用户点击</span></span><br></pre></td></tr></table></figure><p>在这里需要监控用户点击 <code>document.body</code> 的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅 <code>document.body</code> 上的 <code>click</code> 事件，当 <code>body</code> 节点被点击时， <code>body</code> 节点便会向订阅者发布这个消息。</p><p>当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">4</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">click</span>(); <span class="comment">//模拟用户点击</span></span><br></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>如何实现：</p><ul><li>首先要指定好谁充当发布者（比如书店）；</li><li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（书店的花名册）；</li><li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）。</li></ul><p>另外，我们还可以往回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如书店可以在发给订阅者的短信里加上书的单价、页数、章节等信息，订阅者接收到这些信息之后可以进行各自的处理：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffice = &#123;&#125;; <span class="comment">//书店</span></span><br><span class="line">salesOffice.<span class="property">clientList</span> = []; <span class="comment">//缓存列表，存放订阅者的调用函数</span></span><br><span class="line"></span><br><span class="line">salesOffice.<span class="property">listen</span> = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">//增加订阅者</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">clientList</span>.<span class="title function_">push</span>(fn); <span class="comment">//添加进缓存列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffice.<span class="property">trigger</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//发布消息</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn; (fn = <span class="variable language_">this</span>.<span class="property">clientList</span>[i++]); ) &#123;</span><br><span class="line">    fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">//arguments 是发布消息时带上的参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现了一个最简单的发布—订阅模式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HearLing订阅消息</span></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="keyword">function</span> (<span class="params">book, price</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HearLing&quot;</span>, book, price);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 小玲订阅消息</span></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="keyword">function</span> (<span class="params">book, price</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小玲&quot;</span>, book, price);</span><br><span class="line">&#125;);</span><br><span class="line">salesOffice.<span class="title function_">trigger</span>(<span class="string">&quot;深入浅出设计模式&quot;</span>, <span class="number">88</span>); <span class="comment">// 输出：HearLing 深入浅出设计模式 88  小玲 深入浅出设计模式 88</span></span><br><span class="line">salesOffice.<span class="title function_">trigger</span>(<span class="string">&quot;你不知道JavaScript&quot;</span>, <span class="number">98</span>); <span class="comment">// 输出：HearLing 你不知道JavaScript 98  小玲 你不知道JavaScript 99</span></span><br></pre></td></tr></table></figure><p>还存在一些问题。我们看到订阅者接收到了发布者发布的每个消息， <code>HearLing</code> 只想买 “深入浅出设计模式” ，但是推给他不关心的 “你不知道 JavaScript” ，这对 <code>HearLing</code> 来说是不必要的困扰。</p><p>所以我们有必要增加一个标示 <code>key</code> ，让订阅者只订阅自己感兴趣的消息。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffice = &#123;&#125;; <span class="comment">//书店</span></span><br><span class="line">salesOffice.<span class="property">clientList</span> = &#123;&#125;; <span class="comment">//缓存列表，存放订阅者的调用函数</span></span><br><span class="line"></span><br><span class="line">salesOffice.<span class="property">listen</span> = <span class="keyword">function</span> (<span class="params">key, fn</span>) &#123;</span><br><span class="line">  <span class="comment">//增加订阅者</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">clientList</span>[key]) &#123;</span><br><span class="line">    <span class="comment">// 如果还没有订阅过此类消息，给改类消息创建一个缓存列表</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clientList</span>[key] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">clientList</span>[key].<span class="title function_">push</span>(fn); <span class="comment">//订阅的消息添加进缓存列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffice.<span class="property">trigger</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//发布消息</span></span><br><span class="line">  <span class="keyword">var</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>), <span class="comment">// 取出消息类型</span></span><br><span class="line">    fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key]; <span class="comment">// 取出该消息对应的回调函数集合</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fns || fns.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有订阅该消息，则返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn; (fn = fns[i++]); ) &#123;</span><br><span class="line">    fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">//arguments 是发布消息时带上的参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HearLing订阅消息</span></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="string">&quot;深入浅出设计模式&quot;</span>, <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HearLing&quot;</span>, price);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 小玲订阅消息</span></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="string">&quot;你不知道JavaScript&quot;</span>, <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小玲&quot;</span>, price);</span><br><span class="line">&#125;);</span><br><span class="line">salesOffice.<span class="title function_">trigger</span>(<span class="string">&quot;深入浅出设计模式&quot;</span>, <span class="number">88</span>); <span class="comment">// 输出：HearLing 88</span></span><br><span class="line">salesOffice.<span class="title function_">trigger</span>(<span class="string">&quot;你不知道JavaScript&quot;</span>, <span class="number">98</span>); <span class="comment">// 输出：小玲 98</span></span><br></pre></td></tr></table></figure><p>很明显，现在订阅者可以只订阅自己感兴趣的事件了。</p><h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h2><p>假设现在 <code>HearLing</code> 又去另一个书店买书，那么这段代码是否必须在另一个书店重写一次呢，有没有办法可以让所有书店都拥有一套发布—订阅功能呢？</p><p>答案显然是有的，<code>JavaScript</code> 作为一门解释执行的语言，给对象动态添加职责是理所当然的事情。</p><p>把发布—订阅的功能提取出来，放在一个单独的对象内：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = &#123;</span><br><span class="line">  <span class="attr">clientList</span>: [],</span><br><span class="line">  <span class="attr">listen</span>: <span class="keyword">function</span> (<span class="params">key, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">clientList</span>[key]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">clientList</span>[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clientList</span>[key].<span class="title function_">push</span>(fn); <span class="comment">// 订阅的消息添加缓存列表</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">trigger</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">      fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key]; <span class="comment">// 取出该消息对应的回调函数集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fns || fns.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有订阅该消息，则返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn; (fn = fns[i++]); ) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">//arguments 是发布消息时带上的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再定义一个 <code>installEvent</code> 函数，这个函数可以给所有对象都动态安装发布-订阅功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> installEvent = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> event) &#123;</span><br><span class="line">    obj[i] = event[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>书店对象 <code>salesOffices</code> 动态增加发布—订阅功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffice = &#123;&#125;; <span class="comment">//书店</span></span><br><span class="line"><span class="title function_">installEvent</span>(salesOffice);</span><br><span class="line"></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="string">&quot;深入浅出设计模式&quot;</span>, <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HearLing订阅深入浅出设计模式价格:&quot;</span>, price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="string">&quot;你不知道JavaScript&quot;</span>, <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小玲订阅你不知道JavaScript价格:&quot;</span>, price);</span><br><span class="line">&#125;);</span><br><span class="line">salesOffice.<span class="title function_">trigger</span>(<span class="string">&quot;深入浅出设计模式&quot;</span>, <span class="number">88</span>); <span class="comment">// HearLing订阅深入浅出设计模式价格: 88</span></span><br><span class="line">salesOffice.<span class="title function_">trigger</span>(<span class="string">&quot;你不知道JavaScript&quot;</span>, <span class="number">98</span>); <span class="comment">// 小玲订阅你不知道JavaScript价格: 98</span></span><br></pre></td></tr></table></figure><h2 id="取消订阅事件"><a href="#取消订阅事件" class="headerlink" title="取消订阅事件"></a>取消订阅事件</h2><p>有时候，我们也许需要取消订阅事件的功能。比如 <code>HearLing</code> 不想买书了，为了避免继续接收到书店推送过来的短信， <code>HearLing</code> 需要取消之前订阅的事件。现在我们给 <code>event</code> 对象增加 <code>remove</code> 方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.<span class="property">remove</span> = <span class="keyword">function</span> (<span class="params">key, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key];</span><br><span class="line">  <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">    <span class="comment">// 如果key 对应的消息没有被人订阅，则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入具体的回调函数，表示需要取消可以对应消息的所有订阅</span></span><br><span class="line">    fns &amp;&amp; (fns.<span class="property">length</span> = <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = fns.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">var</span> _fn = fns[i];</span><br><span class="line">      <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">        fns.<span class="title function_">splice</span>(i, <span class="number">1</span>); <span class="comment">// 删除订阅者的回调函数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并在订阅之后取消订阅：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">salesOffice.<span class="title function_">listen</span>(</span><br><span class="line">  <span class="string">&quot;深入浅出设计模式&quot;</span>,</span><br><span class="line">  (fn1 = <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HearLing订阅深入浅出设计模式价格:&quot;</span>, price);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="string">&quot;你不知道JavaScript&quot;</span>, <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小玲订阅你不知道JavaScript价格:&quot;</span>, price);</span><br><span class="line">&#125;);</span><br><span class="line">salesOffice.<span class="title function_">remove</span>(<span class="string">&quot;深入浅出设计模式&quot;</span>, fn1);</span><br><span class="line">salesOffice.<span class="title function_">trigger</span>(<span class="string">&quot;深入浅出设计模式&quot;</span>, <span class="number">88</span>); <span class="comment">//</span></span><br><span class="line">salesOffice.<span class="title function_">trigger</span>(<span class="string">&quot;你不知道JavaScript&quot;</span>, <span class="number">98</span>); <span class="comment">// 小玲订阅你不知道JavaScript价格: 98</span></span><br></pre></td></tr></table></figure><h2 id="实现-EventEmitter"><a href="#实现-EventEmitter" class="headerlink" title="实现 EventEmitter"></a>实现 EventEmitter</h2><p>面试是具有更官方的写法的，相信你看了以上的内容已经可以将它写成一个类实现了。在这个类里我们要明确，需要具备的变量和函数：</p><ol><li>需要一个维护事件和监听者的对象</li><li>使用 <code>on</code> 函数注册事件监听者</li><li>使用 <code>emit</code> 函数发布事件</li><li>使用 <code>off</code> 函数移除某个事件的一个监听者</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 维护事件及监听者</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册事件监听者</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; type 事件类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; cb 回调函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">type, cb</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">listeners</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">listeners</span>[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span>[type].<span class="title function_">push</span>(cb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发布事件</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; type 事件类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  &#123;<span class="type">...any</span>&#125; args 参数列表，把emit传递的参数赋给回调函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">listeners</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">listeners</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">cb</span>(...args);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除某个事件的一个监听者</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; type 事件类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; cb 回调函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">type, cb</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">listeners</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">const</span> targetIndex = <span class="variable language_">this</span>.<span class="property">listeners</span>[type].<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item === cb);</span><br><span class="line">      <span class="keyword">if</span> (targetIndex !== -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">listeners</span>[type].<span class="title function_">splice</span>(targetIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">listeners</span>[type].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">listeners</span>[type];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建事件管理器实例</span></span><br><span class="line"><span class="keyword">const</span> ee = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"><span class="comment">// 注册事件监听者</span></span><br><span class="line">ee.<span class="title function_">on</span>(</span><br><span class="line">  <span class="string">&quot;设计模式&quot;</span>,</span><br><span class="line">  (fn1 = <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`HearLing订阅设计模式这本书的价格是:<span class="subst">$&#123;price&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">ee.<span class="title function_">on</span>(<span class="string">&quot;你不知道JavaScript&quot;</span>, <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`HearLing订阅你不知道JavaScript这本书的价格是:<span class="subst">$&#123;price&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ee.<span class="title function_">emit</span>(<span class="string">&quot;设计模式&quot;</span>, <span class="number">100</span>); <span class="comment">// 输出HearLing订阅设计模式这本书的价格是:100</span></span><br><span class="line"></span><br><span class="line">ee.<span class="title function_">off</span>(<span class="string">&quot;设计模式&quot;</span>, fn1);</span><br><span class="line">ee.<span class="title function_">emit</span>(<span class="string">&quot;设计模式&quot;</span>); <span class="comment">// 此时事件监听已经被移除，没有console.log</span></span><br></pre></td></tr></table></figure><h3 id="增强版"><a href="#增强版" class="headerlink" title="增强版"></a>增强版</h3><p>另增加函数，完善功能：</p><ol><li>使用 <code>once</code> 函数只执行一次</li><li>使用 <code>offAll</code> 函数移除某个事件的所有监听者</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在上节代码新增</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 某个事件只监听一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; type 事件类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; cb 回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">once</span>(<span class="params">type, cb</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">execFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">     cb.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">off</span>(type, execFn);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">on</span>(type, execFn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除某个事件的所有监听者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; type 事件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">offAll</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">listeners</span>[type]) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">listeners</span>[type]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>网上很多都喜欢将发布订阅模式、观察者模式还有 <code>EventMitter</code> 进行区分，我个人觉得没有什么必要，内核都是一样的，更多只是命名上的不同。</p><h2 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h2><p>使用观察者模式，我们可以将某些对象（观察者）订阅到另一个对象，称为 <code>observable</code>。每当一个事件发生时， <code>observable</code> 就会通知它的所有观察者。</p><p>一个可观察对象通常包含 3 个重要部分：</p><ul><li><code>observers</code> 观察者：当特定事件发生时将收到通知的观察者数组</li><li><code>subscribe()</code> : 一种将观察者添加到观察者列表的方法</li><li><code>unsubscribe()</code> ：从观察者列表中删除观察者的方法</li><li><code>notify()</code> ：当特定事件发生时通知所有观察者的方法</li></ul><h2 id="简易版实现"><a href="#简易版实现" class="headerlink" title="简易版实现"></a>简易版实现</h2><p>让我们创建一个最简易的 <code>observable</code>。我们需要实现最核心的部分：</p><ul><li>1、使用 <code>subscribe</code> 方法将观察者添加到观察者列表中</li><li>2、使用 <code>unsubscribe</code> 方法删除观察者</li><li>3、使用 <code>notify</code> 方法通知所有订阅者。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(func);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> observer !== func);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> <span class="title function_">observer</span>(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显的是上述只能完成，一有书到就发布消息，而没有分类型，而导致订阅者收到不是需要的消息，所以我们需要增加 <code>key</code> 来区分，思想可见自定义模式的增强版。</p><p>这样一个观察者模式其实就能解决很多问题了，比如我们希望观测到事件触发就通知所有的订阅者，而不关心细节。当然我们也可以去增加 <code>key</code> ，来实现不同的通知，但是一般情况我们把这种写法看成观察者模式。</p><p><strong>优点</strong></p><ol><li>分离关注点</li><li>单一责任原则观察者对象与可观察对象没有紧密耦合，并且可以随时（解）耦合。可观察对象负责监控事件，而观察者只是处理接收到的数据。</li></ol><p><strong>缺点</strong></p><p>如果观察者变得过于复杂，则在通知所有订阅者时可能会导致性能问题。</p><h3 id="增强版-1"><a href="#增强版-1" class="headerlink" title="增强版"></a>增强版</h3><p>那如果我们实现，在这个电话簿上记下订阅的类型再分发消息，那么其实就是实现了我们在发布订阅模式的类实现版。</p><p>为了实现增强，需做以下改造：</p><ol><li>需要增加 <code>key</code> 做区分，所以将 <code>observers</code> 改为对象</li><li><code>subscribe</code> 函数不再是简单地 <code>push</code>，需要不同 <code>type</code> 数组放入回调</li><li><code>unsubscribe</code> 和 <code>notify</code> 则都需要增加一层 <code>type</code> 判断</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">type, func</span>) &#123;</span><br><span class="line">    <span class="comment">//增加type和判断</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">observers</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observers</span>[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>[type].<span class="title function_">push</span>(func);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params">type, func</span>) &#123;</span><br><span class="line">    <span class="comment">//不是直接filter函数，而是根据类型删</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">observers</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observers</span>[type] = <span class="variable language_">this</span>.<span class="property">observers</span>[type].<span class="title function_">filter</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> observer !== func);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params">type, data</span>) &#123;</span><br><span class="line">    <span class="comment">//增加type判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">observers</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observers</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="title function_">fn</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和用发布订阅写的是一样的结果</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">Observable</span>();</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">subscribe</span>(</span><br><span class="line">  <span class="string">&quot;设计模式&quot;</span>,</span><br><span class="line">  (fn1 = <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`HearLing订阅设计模式这本书的价格是:<span class="subst">$&#123;price&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">observer.<span class="title function_">subscribe</span>(<span class="string">&quot;你不知道JavaScript&quot;</span>, <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`HearLing订阅你不知道JavaScript这本书的价格是:<span class="subst">$&#123;price&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">notify</span>(<span class="string">&quot;设计模式&quot;</span>, <span class="number">100</span>); <span class="comment">// 输出HearLing订阅设计模式这本书的价格是:100</span></span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">unsubscribe</span>(<span class="string">&quot;设计模式&quot;</span>, fn1);</span><br><span class="line">observer.<span class="title function_">notify</span>(<span class="string">&quot;设计模式&quot;</span>); <span class="comment">// 此时事件监听已经被移除，没有console.log</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一句话总结发布订阅/观察者模式：当事件发生时，使用该模式通知订阅者。</p><p>发布订阅模式和观察者模式其实没有区别，只是我们大多情况理解的观察者模式是一个数组而不是对象，也不区分类别，所以导致产生发布订阅模式和观察者模式不一样的想法。</p><p>那我们可以简单地区分，一种是有类型判断而一种是没有类型判断的：</p><ul><li>有类型判断<ul><li>优点：根据类型不同通知不同的订阅者，更加灵活准确</li><li>缺点：当事件类型越来越多，会难以维护，需要考虑事件命名的规范，也要防范数据流混乱。</li></ul></li><li>无类型判断<ul><li>优点：适用于不做细分类型的场景，观测的事件触发就通知所有观察者，实现简单。</li><li>缺点：无法做到精细化通知，不易拓展。</li></ul></li></ul><p>OK 那么关于发布订阅/观察者模式总结完毕，如果还有疑问，可以查阅 <code>《JavaScript设计模式与开发实践》</code> 这本书，也可以在评论留下见解。</p><p>🌸 非常感谢你看到这，如果觉得不错的话点个赞 👍 或者 ⭐ 吧~~ 我们下期见 🌸</p><p>今天也是在努力变强不变秃的  <code>HearLing</code>  呀 💪</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「前端设计模式」- 单例模式深入理解</title>
      <link href="/posts/20327/"/>
      <url>/posts/20327/</url>
      
        <content type="html"><![CDATA[<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。也可以理解成在我们的应用程序中共享一个全局实例。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>单击按钮的时候，页面中会出现一个浮窗，而这个浮窗是唯一的，无论单击多少次按钮，这个浮窗都只会被创建一次，那么这个浮窗就适合用单例模式来创建。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。</p><h2 id="传统面向对象语言实现"><a href="#传统面向对象语言实现" class="headerlink" title="传统面向对象语言实现"></a>传统面向对象语言实现</h2><p>传统的面向对象语言，单例对象是从“<strong>类</strong>”中创建而来。（现在可以告知的是，在<code>JavaScript</code> 中这种并不完全适用，但还是需要了解）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Singleton = function(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.instance = null;// 变量标记</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.prototype.getName = function()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = function(name)&#123;</span><br><span class="line">  if(!this.instance)&#123;</span><br><span class="line">  this.instance = new Singleton(name);</span><br><span class="line">  &#125;</span><br><span class="line">  return this.instance// 返回之前创建的对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a = Singleton.getInstance(&#x27;hearling1&#x27;);</span><br><span class="line">const b = Singleton.getInstance(&#x27;hearling2&#x27;);</span><br><span class="line"></span><br><span class="line">alert(a === b);// true</span><br></pre></td></tr></table></figure><h3 id="透明单例模式"><a href="#透明单例模式" class="headerlink" title="透明单例模式"></a>透明单例模式</h3><p>用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var CreateDiv = (function () &#123;</span><br><span class="line">  var instance;</span><br><span class="line">  var CreateDiv = function (html) &#123;</span><br><span class="line">    // Singleton函数</span><br><span class="line">    if (instance) &#123;</span><br><span class="line">      return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    this.html = html; // 1、创建对象</span><br><span class="line">    this.init(); //2、执行初始化init方法</span><br><span class="line">    return (instance = this); // 保证只有一个对象</span><br><span class="line">  &#125;;</span><br><span class="line">  CreateDiv.prototype.init = function () &#123;</span><br><span class="line">    var div = document.createElement(&quot;div&quot;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">  &#125;;</span><br><span class="line">  return CreateDiv;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a = new CreateDiv(&quot;Healing1&quot;);</span><br><span class="line">var b = new CreateDiv(&quot;Healing2&quot;);</span><br><span class="line"></span><br><span class="line">alert(a === b); // ture</span><br></pre></td></tr></table></figure><p>为了把<code>instance</code> 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的<code>Singleton</code> 构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。</p><p>稍微了解规范的话，会知道违反了“<strong>单一职责原则</strong>”，这是一种不好的做法，需要改进。</p><h3 id="代理实现单例模式"><a href="#代理实现单例模式" class="headerlink" title="代理实现单例模式"></a>代理实现单例模式</h3><p>将上述的代码进行指责拆分，可以使用代理实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var CreateDiv = function (html) &#123;</span><br><span class="line">  this.html = html;</span><br><span class="line">  this.init();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CreateDiv.prototype.init = function () &#123;</span><br><span class="line">  var div = document.createElement(&quot;div&quot;);</span><br><span class="line">  div.innerHTML = this.html;</span><br><span class="line">  document.body.appendChild(div);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 引入代理类proxySingletonCreateDiv</span><br><span class="line">var ProxySingletonCreateDiv = (function () &#123;</span><br><span class="line">  var instance;</span><br><span class="line">  return function (html) &#123;</span><br><span class="line">    if (!instance) &#123;</span><br><span class="line">      instance = new CreateDiv(html);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a = new ProxySingletonCreateDiv(&quot;Healing1&quot;);</span><br><span class="line">var b = new ProxySingletonCreateDiv(&quot;Healing2&quot;);</span><br><span class="line"></span><br><span class="line">alert(a === b); // ture</span><br></pre></td></tr></table></figure><p>通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类<code>proxySingletonCreateDiv</code>中。这样一来，<code>CreateDiv</code>就变成了一个普通的类，它跟<code>proxySingletonCreateDiv</code>组合起来可以达到单例模式的效果。</p><h2 id="JavaScript-中的单例模式"><a href="#JavaScript-中的单例模式" class="headerlink" title="JavaScript 中的单例模式"></a>JavaScript 中的单例模式</h2><p>前面提到的<strong>传统面向对象</strong>语言中的实现，单例对象从“<strong>类</strong>”中创建而来。但<code>JavaScript</code>其实是一门无类（<strong>class-free</strong>）语言，也正因为如此，生搬单例模式的概念并无意义。在<code>JavaScript</code>中创建对象的方法非常简单，既然我们只需要一个<strong>唯一的对象</strong>，为什么要为它先创建一个“类”呢?</p><h3 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h3><p>在 JavaScript 中，我们可以这样实现单例模式，而不需要为它创建一个类：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var createLoginLayer = (function () &#123;</span><br><span class="line">  var div;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (!div) &#123;</span><br><span class="line">      div = document.createElement(&quot;div&quot;);</span><br><span class="line">      div.innerHTML = &quot;这是一个窗口&quot;;</span><br><span class="line">      div.style.display = &quot;none&quot;;</span><br><span class="line">      document.body.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">    return div;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">document.getElementById(&quot;loginBtn&quot;).onclick = function () &#123;</span><br><span class="line">  var loginLayer = createLoginLayer();</span><br><span class="line">  loginLayer.style.display = &quot;block&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="通用的惰性单例"><a href="#通用的惰性单例" class="headerlink" title="通用的惰性单例"></a>通用的惰性单例</h3><p>上一段代码存在的问题：</p><ul><li>这段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在<code>createLoginLayer</code>对象内部</li><li>如果我们下次需要创建页面中唯一的<code>iframe</code>，或者<code>script</code>标签，用来跨域请求数据，就必须得如法炮制，把<code>createLoginLayer</code>函数几乎照抄一遍，类似这样：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var createIframe = (function () &#123;</span><br><span class="line">  var iframe;// 照抄上代码，改div为iframe</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (!iframe) &#123;</span><br><span class="line">      div = document.createElement(&quot;div&quot;);</span><br><span class="line">      div.innerHTML = &quot;这是一个窗口&quot;;</span><br><span class="line">      div.style.display = &quot;none&quot;;</span><br><span class="line">      document.body.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">    return iframe;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>将不变的部分隔离出来，用一个变量标志是否创建过对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj;</span><br><span class="line">if(!obj)&#123;</span><br><span class="line">  obj = xxx;//如果是则下次之间返回已经创建好的对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装，将逻辑封装到<code>getSingle</code>函数内部，创建对象的方法，当作<code>props</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var getSingle = function(fn)&#123;</span><br><span class="line">  var result;</span><br><span class="line">  return function()&#123;</span><br><span class="line">  return result || (result = fn.apply(this,arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写的好处，及代码：</p><ul><li>可以传各样的创建对象函数</li><li><code>getSingle</code>返回新函数，并用<code>result</code>来保存 fn 的计算结果，且不会被销毁（闭包）</li><li>在将来的请求中，如果<code>result</code>已经被赋值，那么它将返回这个值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var createLoginLayer = function()&#123;</span><br><span class="line">  var div = document.createElement(&#x27;div&#x27;);</span><br><span class="line">  div.innerHTML = &#x27;这是一个窗口&#x27;;</span><br><span class="line">  div.style.display = &#x27;none&#x27;;</span><br><span class="line">  document.body.appendChild(div);</span><br><span class="line">  return div;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var createSingelLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"></span><br><span class="line">document.getElementById(&#x27;loginBtn&#x27;).onclick = function()&#123;</span><br><span class="line">var loginLayer = createSingelLoginLayer();</span><br><span class="line">  loginLayer.style.display = &#x27;block&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定<code>click</code>事件，如果是通过<code>ajax</code>动态往列表里追加数据，在使用事件代理的前提下，<code>click</code>事件实际上只需要在第一次渲染列表的时候被绑定一次，但是我们不想去判断当前是否是第一次渲染列表，可以利用<code>getSingle</code>函数，也能达到效果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var bindEvent = getSingle(function () &#123;</span><br><span class="line">  document.getElementById(&quot;div1&quot;).onclick = function () &#123;</span><br><span class="line">    alert(&quot;click&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  return true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建且只创建唯一对象。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。</p><h2 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h2><p>单例模式通常被用于在我们的应用程序中共享一个全局实例。</p><p>单例是可以实例化一次的类，并且可以全局访问。这个单一实例可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。</p><h3 id="类实现"><a href="#类实现" class="headerlink" title="类实现"></a>类实现</h3><p>首先，让我们看看使用 <code>ES5</code> 类的单例会是什么样子。对于这个例子，我们将构建一个 <code>Counter</code> 类：</p><ul><li>创建一个名为 <code>instance</code> 的变量。</li><li>在 <code>Counter</code> 的构造函数中，我们可以在创建新实例时将<code>instance</code>设置为对实例的引用。</li><li>我们可以通过检查实例变量是否已经有值来防止新的实例化。</li><li>如果是这种情况，则实例已经存在。这不应该发生：这里抛出一个错误让用户知道</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let instance;</span><br><span class="line">let counter = 0;</span><br><span class="line"></span><br><span class="line">class Counter&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">  if(instance)&#123;</span><br><span class="line">    throw new Error(&#x27;You can only create one instance&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    instance = this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getInstance()&#123;</span><br><span class="line">  return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getCount()&#123;</span><br><span class="line">  return counter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment()&#123;</span><br><span class="line">  return ++counter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  decrement()&#123;</span><br><span class="line">  return --counter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const counter1 = new Counter();</span><br><span class="line">const counter2 = new Counter();</span><br><span class="line">console.log(counter1.getInstance() === counter2.getInstance());</span><br><span class="line">//Error: You can only create one instance</span><br></pre></td></tr></table></figure><p>很好，我们不能创建多个实例了。</p><p>需要注意的是，当我们要导出这个<code>Counter</code>实例时，我们应该<code>freeze</code>。 <code>Object.freeze</code> 方法确保消费代码不能修改 <code>Singleton</code>。无法添加或修改冻结实例上的属性，这降低了意外覆盖 <code>Singleton</code> 上的值的风险。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const singletonCounter = Object.freeze(new Counter());</span><br><span class="line">export default singletonCounter;</span><br></pre></td></tr></table></figure><h3 id="常规对象实现"><a href="#常规对象实现" class="headerlink" title="常规对象实现"></a>常规对象实现</h3><p>将上述的类实现改为使用常规对象，让我们使用与之前看到的相同的示例。然而这一次，计数器只是一个包含以下内容的对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let count = 0;</span><br><span class="line"></span><br><span class="line">const counter&#123;</span><br><span class="line">  increment()&#123;</span><br><span class="line">  return ++counter;</span><br><span class="line">  &#125;,</span><br><span class="line">  decrement()&#123;</span><br><span class="line">  return --counter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.freeze(counter);</span><br><span class="line">export &#123;counter&#125;;</span><br></pre></td></tr></table></figure><p>计数器详细代码：<a href="https://codesandbox.io/embed/competent-moon-rvzrr">https://codesandbox.io/embed/competent-moon-rvzrr</a></p><p>由于对象是通过引用传递的，<code>redButton.js</code> 和 <code>blueButton.js</code> 都在导入对同一个 <code>singletonCounter</code> 对象的引用。在这两个文件中修改 <code>count</code> 的值将修改 <code>singletonCounter</code> 上的值，这在两个文件中都是可见的。</p><p>OK 上述为一个简单的理解的例子，在实际运用中 <code>Counter</code> 示例的应用程序类似于这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aef6116bb43b4825870809fb98c34bc0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>会发现，当我们在 <code>redButton.js</code> 或 <code>blueButton.js</code> 中调用 <code>increment</code> 方法时，<code>Counter</code> 实例上的 <code>counter</code> 属性值会在两个文件中更新。我们点击红色或蓝色按钮都没有关系：<strong>所有实例共享相同的值</strong>。这就是为什么计数器一直递增一的原因，即使我们在不同的文件中调用该方法。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>将实例化限制为仅一个实例可能会节省大量内存空间。我们不必每次都为新实例设置内存，而只需为该实例设置内存，该实例在整个应用程序中都会被引用。但是，Singleton（单例模式） 实际上被认为是一种反模式（anti-pattern），并且可以（或..应该）在 JavaScript 中避免使用。</li><li>在许多编程语言中，例如 Java 或 C++，不可能像在 JavaScript 中那样直接创建对象。在那些面向对象的编程语言中，我们需要创建一个类，它会创建一个对象。该创建的对象具有类实例的值，就像 JavaScript 示例中的实例值一样。</li><li>但是，上面示例中显示的类实现实际上是矫枉过正。由于我们可以直接在 JavaScript 中创建对象，因此我们可以简单地使用常规对象来实现完全相同的结果。让我们来介绍一下使用单例的一些缺点！</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>错误的使用单例模式，很可能带来一些问题，就比如我写的这个例子，其实存在一下问题：</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试依赖于 <code>Singleton</code> 的代码可能会变得很棘手。由于我们不能每次都创建新实例，因此所有测试都依赖于对上一次测试的<strong>全局实例</strong>的修改。在这种情况下，测试的<strong>顺序</strong>很重要，一个小的修改可能会导致整个测试套件失败。测试后，我们需要重置整个实例以重置测试所做的修改。</p><h3 id="依赖隐藏"><a href="#依赖隐藏" class="headerlink" title="依赖隐藏"></a>依赖隐藏</h3><p>当导入另一个模块时，在这种情况下为 <code>superCounter.js</code>，该模块导入 <code>Singleton</code> 可能并不明显。在其他文件中，例如本例中的 <code>index.js</code>，我们可能正在导入该模块并调用其方法。这样，我们不小心修改了 <code>Singleton</code> 中的值。这可能会导致意外行为，因为可以在整个应用程序中共享 <code>Singleton</code> 的多个实例，这些实例也会被修改。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Counter from &quot;./counter&quot;;</span><br><span class="line"></span><br><span class="line">export default class SuperCounter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.count = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment() &#123;</span><br><span class="line">    Counter.increment();</span><br><span class="line">    return (this.count += 100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  decrement() &#123;</span><br><span class="line">    Counter.decrement();</span><br><span class="line">    return (this.count -= 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//index.js</span><br><span class="line">const counter = new SuperCounter();</span><br><span class="line">counter.increment();</span><br><span class="line">console.log(&quot;Counter in counter.js: &quot;, Counter.getCount());//Counter in counter.js:  1</span><br></pre></td></tr></table></figure><h3 id="全局行为"><a href="#全局行为" class="headerlink" title="全局行为"></a>全局行为</h3><p>一个单例实例应该能够在整个应用程序中被引用。全局变量本质上表现出相同的行为：由于全局变量在全局范围内可用，我们可以在整个应用程序中访问这些变量。</p><p><strong>拥有全局变量通常被认为是一个糟糕的设计决策</strong>。全局范围污染最终可能导致意外覆盖全局变量的值，从而导致许多意外行为。</p><p>在 <code>ES2015</code> 中，创建全局变量相当少见。新的 <code>let</code> 和 <code>const</code> 关键字通过将使用这两个关键字声明的变量保持在块范围内来防止开发人员意外污染全局范围。 <code>JavaScript</code> 中的新模块系统通过能够从模块中导出值并将这些值导入其他文件中，使得创建全局可访问的值更容易而不会污染全局范围。</p><p>但是，单例的常见用例是在整个应用程序中拥有某种全局状态。让你的代码库的多个部分依赖于同一个可变对象（<strong>mutable object</strong>）可能导致意外行为。</p><p>通常，代码库的某些部分会修改全局状态中的值，而其他部分会使用该数据。这里的执行顺序很重要： 我们不想在没有数据要消费的时候（还）不小心先消费数据。 随着应用程序的增长以及数十个组件相互依赖，使用全局状态时理解数据流可能会变得非常棘手。</p><p>在 <code>React</code> 中，我们经常通过 <code>Redux</code> 或 <code>React Context</code> 等状态管理工具来依赖全局状态，而不是使用 <code>Singletons</code>。尽管它们的全局状态行为可能看起来类似于单例，但这些工具提供了只读状态而不是单例的可变状态。使用 <code>Redux</code> 时，只有纯函数 <code>reducer</code> 可以在组件通过调度程序发送操作后更新状态。</p><p>尽管使用这些工具不会神奇地消除全局状态的缺点，但我们至少可以确保全局状态按照我们想要的方式发生变化，因为组件不能直接更新状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式（Singleton Pattern）是属于创建型模式，它提供了一种创建对象的最佳方式。保证仅有一个实例，并提供一个访问它的全局访问点。当您想控制实例数目，节省内存的时候使用。</p><p><strong>优点</strong> ： 内存里只有一个实例，减少频繁的创建和销毁实例提高性能。</p><p><strong>缺点</strong>： 不适用于变化频繁的对象（如上述的 count），可能存在测试问题和数据流等问题（上节所述缺点）。创建之后长时间不被利用会被垃圾回收。</p><p>🌸 非常感谢你看到这，如果觉得不错的话点个赞 ⭐ 吧~~ 今天也是在努力变强不变秃的  HearLing  呀 💪 🌸</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「辩论」应不应该多使用 useCallback 和 useMemo</title>
      <link href="/posts/20127/"/>
      <url>/posts/20127/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于不同团队而言，使不使用 useCallback和 useMemo 都有着不同的见解，看过很多文章都说不要用，作为深度使用 useCallback和 useMemo 这两个钩子的我来说，我完全能理解为什么很多人都说不要用。而这篇文章是帮助你理解 useCallback 和 useMemo，以便于结合实际来考量。</p><p>本篇文章基本概括了很多人对 useCallback 和 useMemo 的疑问，至于是要多用还是少用，相信看完你会有自己的思考。</p><p>如果你不太好考量，请看最后我结合我的开发习惯和公司情况的总结：<strong>尽量使用 useCallback 和 useMemo</strong> </p><p><strong>注意</strong>：由于 <code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code> 。以及大部分人只争议 useCallback 要不要用，所以会着重针对 useCallback。</p><h2 id="官方＆源码"><a href="#官方＆源码" class="headerlink" title="官方＆源码"></a>官方＆源码</h2><p>React官网对useCallback的介绍是比较简短的，我们一起来解析一下吧：</p><p>开篇第一句话：</p><blockquote><p>返回一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 回调函数</p></blockquote><p>意思很显而易见就是会返回被记忆的函数，具体如何实现，看看源码：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装载阶段</span></span><br><span class="line"><span class="keyword">function</span> mountCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="built_in">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="comment">// 获取对应的 hook 节点</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="comment">// 依赖为 undefiend，则设置为 null</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 将当前的函数和依赖暂存</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新阶段</span></span><br><span class="line"><span class="keyword">function</span> updateCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="built_in">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 获取上次暂存的 callback 和依赖</span></span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 将上次依赖和当前依赖进行浅层比较，相同的话则返回上次暂存的函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则则返回最新的函数</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然看上去复杂，但简单的理解的话，其实就是运用了闭包，在内部维护了依赖和函数，通过判断前后依赖是否改变，再更新这个函数并返回；</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果有兴趣可以也按这个思路分析 <code>useMemo</code> 的源码，这里节省内容就不分析 <code>useMemo</code>了。</p><h4 id="初始化阶段："><a href="#初始化阶段：" class="headerlink" title="初始化阶段："></a>初始化阶段：</h4><ul><li>❌ 函数 使用 <code>useCallback</code> 创建，内部产生闭包，缓存当前 <code>deps</code>的引用。</li></ul><h4 id="依赖不变的更新阶段"><a href="#依赖不变的更新阶段" class="headerlink" title="依赖不变的更新阶段:"></a>依赖不变的更新阶段:</h4><ul><li>❌ <code>useCallback</code> diff <code>deps</code></li><li>✅ 判断 <code>deps</code> 无变化，直接取缓存的函数</li></ul><h4 id="依赖变化的更新阶段"><a href="#依赖变化的更新阶段" class="headerlink" title="依赖变化的更新阶段:"></a>依赖变化的更新阶段:</h4><ul><li>❌ <code>useCallback</code> diff <code>deps</code></li><li>❌ 判断 <code>deps</code> 改变，重新生成方法给 函数 引用<br>其实可以发现，useCallback 会给我们做很多操作，大部分可能是无谓的操作，是浪费开销的。</li></ul><p>为了更详细的理解，你可以看下面的思考：</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>举个实际的例子，以便思考：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick1</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> handleClick2 = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="comment">// 和handleClick1 一样</span></span><br><span class="line">&#125;,[ deps ])</span><br></pre></td></tr></table></figure><p>执行 handleClick2 需要经历哪些步骤：</p><p>1、初始化，使用 <code>useCallback</code> 创建函数</p><p>2、申请 <code>useCallbck</code> 第一个参数对应的函数所需要的内存，这一点的花费基本和 <code>handleClick1</code> 的开销一样。</p><p>3、在内存中保存上一次的依赖，和最新的依赖浅比较。</p><p>这样看来，他并没有节省开销嘛，那又怎么谈得上优化呢？有了这样的疑问我们再看使用场景。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>官网的第二段，第一句告诉怎么用返回什么，第二句告诉在什么情况下用。第一句话已经分析过了，我们注意第二句话。</p><p>传递给 <code>经过优化</code> 并使用 <code>引用相等性</code> 去避免非必要渲染的<code>子组件</code>时,它将非常有用。</p><blockquote><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p></blockquote><p>这里我们就可以知道一点官网的态度了，它告诉我们在使用 <code>shouldComponentUpdate</code> （<code>React.memo</code>）的子组件，这种情况下非常有用。</p><p>先说这种非常有用的情况：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>) =&gt; &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Parent-render&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [age, setAge] = <span class="title function_">useState</span>(<span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">addCount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">addAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setAge</span>(age + <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onChange = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//...doSomthing</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;value&quot;</span>, value);</span><br><span class="line">    &#125;, []);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;addCount&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            add account</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;addAge&#125;</span> <span class="attr">className</span>=<span class="string">&quot;ml10&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            add age</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Child</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="keyword">function</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子组件函数Child...&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; onChange &#125; = props;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> onCheckChange = <span class="title function_">useCallback</span>(</span><br><span class="line">        <span class="function">(<span class="params">checkedValues</span>) =&gt;</span> &#123;</span><br><span class="line">        onChange &amp;&amp; <span class="title function_">onChange</span>(checkedValues);</span><br><span class="line">        &#125;,</span><br><span class="line">        [onChange]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Checkbox.Group</span> <span class="attr">onChange</span>=<span class="string">&#123;onCheckChange&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">value</span>=<span class="string">&quot;A&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">Checkbox</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">value</span>=<span class="string">&quot;B&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">Checkbox</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">value</span>=<span class="string">&quot;C&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">Checkbox</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Checkbox.Group</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述是没有加useCallback的示例，当<code>Parent</code> 组件render时，<code>onChange</code> 函数会被<strong>重新创建</strong>。每次 render 时 <code>Child</code> 参数中会接受一个新的 <code>onChange</code> 参数，这会直接击穿 <code>React.memo</code>，导致性能优化失效，并联动一起 render。<a href="https://codesandbox.io/s/reactmemo-rmt1e?file=/src/index.js:0-740">这里看效果</a></p><p>单从这个例子来看我们可以发现</p><p>1、不用<code>useCallback</code>, 父组件的每次<code>render</code>，都会导致子组件重新渲染。</p><p>2、不用<code>React.memo</code>, 也会造成同样问题。（所以说要搭配使用）</p><p>由此我们对 <code>useCallback</code> 已经非常清楚了，但是基于以上的认知，产生了两种截然不同的声音：尽量使用和尽量不使用。</p><h2 id="尽量不要使用-useCallback"><a href="#尽量不要使用-useCallback" class="headerlink" title="尽量不要使用 useCallback"></a>尽量不要使用 useCallback</h2><p>大部分场景不仅没有提升性能，反而让代码可读性变得很差。</p><p>以下为我调研总结不支持使用 <code>useCallback</code> 同学辩论得出的观点：</p><p>1、<strong>创建函数的性能消耗就不在优化范围内</strong>。<code>useCallback</code>是防止函数重新创建，然而重新创建函数是一个非常轻的根本不需要优化的动作。</p><p>2、<strong>useCallback其实是防止子函数的rerender</strong>，但必须配合 <code>react.memo</code>，不然没有意义。</p><p>3、<strong>既浪费缓存又浪费时间</strong>。浪费缓存这个是已知的了，时间这个差距不是很大，简单的测下来发现不用的时间还短一些（后续会解释为什么会慢）。</p><blockquote><p>而 useCallBack 节省的那点创建函数的时间根本不算优化，函数里该执行多少时间还是会执行多少时间。至于为什么甚至会多时间，因为其实每次组件重新渲染时，都可避免重新创建内部函数，因为即使useCallback的deps没有变，它也会重新创建内部函数作为useCallback的实参</p></blockquote><p>4、<strong>useCallBack 和 useMemo 不一样，useMemo 应该大量使用</strong>。<code>useMemo</code> 是缓存计算值，当计算值是 <code>expensive</code> 的时候，用它是非常有用的，可以大大减少计算时间。</p><h3 id="大部分场景没有性能提升"><a href="#大部分场景没有性能提升" class="headerlink" title="大部分场景没有性能提升"></a>大部分场景没有性能提升</h3><p>为什么我们会觉得有性能提升呢？</p><p>1、<code>useCallback</code>可以避免重复生成函数</p><p>重新生成函数代价十分低,并且使用 <code>useCallback</code> 也不能减少必要的创建，可见此实例：<a href="https://codesandbox.io/s/test-usecallback-forked-rfhl5">链接</a></p><ul><li>使用<code>useCallback</code>会产成额外的性能：对<code>deps</code>的判断。</li><li>其实每次组件重新渲染时，都可避免重新创建内部函数，因为即使<code>useCallback</code>的<code>deps</code>没有变，它也会重新创建内部函数作为<code>useCallback</code>的实参</li></ul><p>2、作为<code>props</code>传给子组件时候，也可以避免子组件重复渲染。真正有用的是能为使用 memo 的组件减少 render。</p><h3 id="代码可读性变差"><a href="#代码可读性变差" class="headerlink" title="代码可读性变差"></a>代码可读性变差</h3><p>综上useCallback 可能并不会给我们带来想要的性能提升，可能还会让代码的可读性变差，我们再来看代码：</p><p>1.让人费解的嵌套依赖</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someFuncA = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">d, g, x, y</span>)=&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">doSomething</span>(a, b, c, d, g, x, y);</span><br><span class="line">&#125;, [a, b, c]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someFuncB = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">someFuncA</span>(d, g, x, y);</span><br><span class="line">&#125;, [someFuncA, d, g, x, y]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">someFuncB</span>();</span><br><span class="line">&#125;, [someFuncB]);</span><br></pre></td></tr></table></figure><p>2.操作意外，闭包问题，函数拿到旧值</p><p>原理上有 <code>eslint</code> 检查报 <code>warn</code> 我们是能知道要把依赖都全部加上的。但是还是会有失误的时候。</p><p>比如在函数中：注释了一段代码，忘记把依赖删去。新增一段代码，存在新增依赖，忘记加上去。</p><p>总是需要凭借程序员的警觉，来防止犯错。</p><p>3.调用顺序问题<br>这也不算是特别大的问题，算是裸写 <code>function</code> 带来变量提升的一点好处吧。函数顺序能自己决定，在代码阅读起来其实也会更加舒畅。</p><h3 id="关于提前优化的思考"><a href="#关于提前优化的思考" class="headerlink" title="关于提前优化的思考"></a>关于提前优化的思考</h3><p>为什么会有这种思考呢？</p><p>因为总结起来很明确的是 <code>useCallback</code> 只有在搭配 <code>memo</code> 使用才有用，其他大部分情况没有优化。</p><p>然后有一个观点纠结我很久，父组件不知道子组件用了 <code>memo</code> 而他没使用 <code>useCallback</code> 从而导致优化失效。=&gt;所以为了避免这种情况我们应该要多使用 <code>useCallback</code> 避免这种情况发生。</p><p>我找寻了很多文章，都没有人说这个问题，他们都局限于 useCallback 没有优化不要用，而没想过这种情况。对于这种想法我也只在<a href="https://zhuanlan.zhihu.com/p/88593858">https://zhuanlan.zhihu.com/p/88593858</a> 这篇文章能看到解决方案。</p><ul><li>自封装<code>useCallback</code> 函数，添加<code>__useCallback__</code>属性，并在<code>run-time</code>检查是否存在这个属性。</li><li>用<code>eslint</code>插件去检查。但实际我并没有找到这样的。</li><li>团队约束：新人进来就要求全部加上 <code>useCallback</code> 或者 <code>review</code>检查。</li></ul><h2 id="思想的碰撞💥"><a href="#思想的碰撞💥" class="headerlink" title="思想的碰撞💥"></a>思想的碰撞💥</h2><p>三个观点：</p><ol><li>尽量使用</li></ol><ul><li><p><code>useCallback</code>会造成每次渲染时函数的重建。</p><ul><li>1.重建时间短，多创建一两次甚至更多次，不会造成什么影响</li><li>2.和 useMemo 不一样，useMemo能切实的减少重复计算（尤其 expensive 的计算）</li><li>3.使用 useCallback 花费时间其实反而会更长（真），用缓存也没换时间</li></ul></li><li><p>不使用<code>useMemo</code>和<code>useCallback</code>会造成<code>React.memo</code>失效</p><ul><li>情况很少，因为真的没有那么多使用了React.memo的非必要不渲染的子组件呀。</li></ul></li><li><p>不使用<code>useCallback</code> 则 <code>useEffect</code>无法依赖 回调函数</p><ul><li>尽量不要把函数作为 useEffect 的依赖</li></ul></li></ul><ol start="2"><li>尽量不使用<ul><li>1.不使用，你真正遇到问题，能解决问题吗？ <ul><li>能呀，并且有比 useCallback 更好用的方法解决</li></ul></li><li>2.你不知道你的子组件是否用了React.memo，然后你没加 useCallback 不就有问题了？<ul><li>在这种情况下确实有优处呀，它就是为了解决这个的。但为了优化这一点，而选取让其他组件都反优化是否有点不太值当？</li><li>我能通过一些方法（如上述例子），在runtime报错，强制让父组件包裹 useCallback</li></ul></li><li>3.尽量使用我觉得并不会造成你说的那么多问题<ul><li>1.关于嵌套依赖，useCallback 的依赖很好加，按照提示点一下就好了。到 useEffect 里绝大多数情况我们不会把函数作为依赖。</li><li>2.关于闭包问题，按照提示写依赖不会存在问题</li></ul></li></ul></li></ol><p>3.总是思考用不用<br>你需要总是了解组件的情况<br>不用思考呀，就总是不用，子组件用了 memo 的时候再包一下呀</p><p>强制加上useCallback和useMemo除了多写两行代码并不会影响代码的稳定，如果因为依赖少加导致取到旧的值，我觉得是开发者的问题（而且我们有编辑器帮助我们检查是否有漏掉依赖，这不应该是个问题）</p><p>那我还觉得你父组件 在子组件使用了 memo 优化的情况下函数没加 useCallback是开发者的问题呢。</p><h2 id="尽量使用"><a href="#尽量使用" class="headerlink" title="尽量使用"></a>尽量使用</h2><ul><li>不使用useCallback会造成每次渲染时函数的重建 ❌ <strong>创建函数时间非常小、内部还是会重新创建</strong></li><li>不使用useMemo和useCallback会造成React.memo失效 ✅ </li><li>不使用useCallback 则 useEffect无法依赖 回调函数 ✅  <strong>但大多数情况useEffect不应该依赖回调函数</strong></li><li>React.memo 类似 PureComponent 能用就用 ✅ <strong>优化，但不是说全部要使用</strong></li></ul><h3 id="损失小性能换大性能"><a href="#损失小性能换大性能" class="headerlink" title="损失小性能换大性能"></a>损失小性能换大性能</h3><p>首先分情况，对于简单组件，使用 <code>useCallback</code> 可能会造成一定的损耗，但是对比差别其实非常小，组件不会因为你使用了 <code>useCallback</code> 而产生性能问题。</p><p>反而对于复杂组件或者说是需要被优化的组件，有可能就会因为没有使用 <code>useCallback</code> 而造成优化失效而产生问题。</p><h3 id="产生问题是不会用-useCallback"><a href="#产生问题是不会用-useCallback" class="headerlink" title="产生问题是不会用 useCallback"></a>产生问题是不会用 useCallback</h3><p>1.依赖嵌套，useCallback和 useMemo 里的依赖都是要按提示补全的，通过依赖你也可以知道一些信息。比如你说的这个例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someFuncA = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">doSomething</span>(a, b, c);</span><br><span class="line">&#125;, [a, b, c]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someFuncB = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">someFuncA</span>(x, y);</span><br><span class="line">&#125;, [someFuncA,x, y]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">someFuncB</span>();</span><br><span class="line">&#125;, [someFuncB]);</span><br></pre></td></tr></table></figure><ul><li>首先能在 useEffect 依赖里写的函数必须要useCallback 包裹，如果你要这样写的话（的确还是有场景需要这样做的）。</li><li>其次这样改成不用 useCallback 那就更错了。你可能要去找究竟是那个依赖改变了要触发 useEffect。</li><li>更多时候都不会有问题，如果你足够了解 useEffect 的话</li></ul><p>大部分场景可能是这种</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getData = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">a</span>)=&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//doSomething...</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">getData</span>(a);</span><br><span class="line">&#125;, [a]);</span><br></pre></td></tr></table></figure><h3 id="对于新人的培养"><a href="#对于新人的培养" class="headerlink" title="对于新人的培养"></a>对于新人的培养</h3><p>这点很多文章其实没有考虑到，主观思维是这个新人一定是非常了解 <code>useCallback</code> 的，知道什么情况下用。</p><p>但其实我觉得这只对一部分人是有效的，很多情况下，如果你不要求他多写 <code>useCallback</code> ，他根本不知道原来这里要优化要用 <code>useCallback</code>。</p><p>举个简单的例子就是，你知道一个公式，但你从来不使用，你觉得碰到应该使用这个公式的题的时候，他能使用起来嘛？</p><h3 id="对于团队"><a href="#对于团队" class="headerlink" title="对于团队"></a>对于团队</h3><p>对于团队一定是要有规范的，不然很容易乱。对于用不用呢，每个团队都有自己的考量。我也完全可以理解不同团队做出的选择，emmm 可能有的团队没有想过东西，就随着不同开发者的个性写。</p><p>作为一个团队可以从这几个点出发去想：</p><ul><li>重视代码的稳定、可维护</li><li>重视团队新成员的成长</li><li>重视团队规范</li></ul><h2 id="至于争论"><a href="#至于争论" class="headerlink" title="至于争论"></a>至于争论</h2><p>导致争论的最大原因，我觉得可以归为以下几个原因：<br>1、团队差异<br>2、官方文档没有详细介绍<br>3、个人对官方文档理解差异</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://react.html.cn/docs/hooks-reference.html#usecallback">React 官网</a></li><li><a href="https://mp.weixin.qq.com/s/Yf4-5Zni3-heWjzM2KYAFQ">React Hooks 使用误区，驳官方文档</a></li><li><a href="https://mp.weixin.qq.com/s/PJVRA2ikcTNyrPrcKAWFmg">放弃使用 useCallback 吧，我们有更好的方式</a></li><li><a href="https://juejin.cn/post/6847902217261809671">useCallback/useMemo 的使用误区</a></li></ul><p>等…<br>感谢这些作者的文章，以及感谢提供观点的我的组员和不愿露面的网友。</p><p>🌸🌸🌸🌸🌸 </p><p>非常感谢你看到这，如果觉得不错的话点个赞 ⭐ 吧</p><p>今天也是在努力变强不变秃的 <code>HearLing</code> 呀 💪</p><p>🌸🌸🌸🌸🌸</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> Hook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「2021总结」前端女程序媛入职一年的年度总结</title>
      <link href="/posts/11203/"/>
      <url>/posts/11203/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文总结了我 2021 这一整年的学习、工作还有生活上的总结，可能文章会有点长，这我避免不了，但是你可以通过目录直接跳转到你想看的部分哦，我会尽量分好章节目录。</p><h2 id="简单介绍一下我自己"><a href="#简单介绍一下我自己" class="headerlink" title="简单介绍一下我自己"></a>简单介绍一下我自己</h2><p>大家好呀，这里是 HearLing，一个非常努力「 变强不变秃 」的前端程序媛，可能一些关注我的小伙伴都不知道我是女生吧哈哈。那在这里正式认识一下吧～</p><p><img src= "/img/loading.gif" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed703ce3f4b0438a9e46303b9614ccdf~tplv-k3u1fbpfcp-watermark.image?" alt="F2F3F600A2CA7E233C5A7A2C1A87E563.jpg"></p><p>非常感谢一直关注我的小伙伴对我的支持；当然也十分欢迎新的朋友来关注我，以后我们一起进步努力呀～</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>先从学习说好了。我始终认为不断的保持学习，才能一直不断的提升自我，不断进步。没有了学校教授知识，学习变成了一件需要主动进行的事情。变成了可以学想学的，有更多的学习支配时间，学习的东西也更多元了。但也可以变成啥也不学吃老本。</p><p>这一章，就列举一些这一年接触和深入学习的一些知识。</p><h2 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h2><p>首先由于我本身就是前端的嘛，相对于这方面的学习自然会多一些，这里列举一些前端技术。相对于之前，今年我觉得主要是围绕 React 进行的，更加贴近公司技术栈，相对来说其他学习的技术是占小头的。</p><h3 id="Vue-全家桶"><a href="#Vue-全家桶" class="headerlink" title="Vue 全家桶"></a>Vue 全家桶</h3><p>从 <a href="https://cn.vuejs.org/v2/guide/">Vue2</a> 到 <a href="https://v3.cn.vuejs.org/guide/introduction.html">Vue3</a> 虽然工作上还没有用到，但是说不定以后就能用到了呢？Vue3 有了 TypeScript 的支持，使用起来更加舒服（对我来说），其实也不用把 <code>Vue3</code> 的学习想得特别难，有 <code>Vue2</code> 的一些基础不可能学不会的。</p><h3 id="React-全家桶"><a href="#React-全家桶" class="headerlink" title="React 全家桶"></a>React 全家桶</h3><p><a href="https://zh-hans.reactjs.org/docs/hello-world.html">React</a> 是目前公司工作的主力，从<code>Vue</code> 转写 <code>React</code>我觉得没什么压力，写<code>React Hook</code>真的好上手且非常好用。而且如果看到公司以前写 class 组件的话，现在都能直接顺便改成 hook 了。</p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p><a href="http://cn.redux.js.org/tutorials/essentials/part-1-overview-concepts">Redux</a> 对于公司的状态管理是十分重要的，也是会相对复杂，真正理解了核心，再去看与 <code>Redux</code> 相关的库，以及相关的一些业务逻辑就会好理解很多。关于 Redux 也出过一篇文章：<a href="https://juejin.cn/post/6948776562019794974#comment">「Redux」概念理解+实战上手（内含大量实例）</a></p><p>期间也是调研也一些关于 Redux 的库，我也出了文章 <a href="https://juejin.cn/post/7021438027792646174">proxy-memoize</a>和<a href="https://juejin.cn/post/7025891039315492900">Redux Toolkit </a> 不过可能是受众面不够吧，没啥人看 😂。</p><h3 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h3><p><a href="https://www.nextjs.cn/learn/basics/create-nextjs-app?utm_source=next-site&utm_medium=nav-cta&utm_campaign=next-website"> Next.js</a> 我用了是真的好用，如果你在考虑构建一个完整的 Web 应用程序的话，真心推荐你看看 Next.js。它的一些好处你点链接去官网看，太多了就不放在这说了。</p><h3 id="Cesium"><a href="#Cesium" class="headerlink" title="Cesium"></a>Cesium</h3><p><a href="https://cesium.com/">Cesium</a>是一个三维地理空间平台，也是基于公司的业务场景，需要这块的学习投入。就不细说了，其实主要就是去构建 3d 模型的这么一个应用，这一块我还只是初步学习，还是需要多掌握一些知识（主要是一些地理知识）才能真正实践运用。</p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p><a href="http://nodejs.cn/api/">node.js</a> 对于前端的影响不用我多说了，他的东西是非常的多，直接学的话多少有点从入门到放弃了。建议买本书，或者下载电子书来看，也可以学一些底层的操作系统呀浏览器呀网络这些基础知识，会很有帮助。</p><p>以前的我，对于 node 的理解可能就只是辅助 JavaScript，npm 包管理，今年又发现了新领域，用 node 写爬虫。虽然说这只是一个巧合，本来是用 python 爬取数据的，由于学了 node 我就试着写了一下，直接就在中台写了一套 node 版的爬虫。至此我才发现 node 能做的东西还有很多，虽然 node 能做的其他语言也能做。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>感觉都只是稍微学了一下，花费的时间也不算多，也比较杂，干脆都放到这一块好了。</p><p><a href="https://hexo.io/zh-cn/">Hexo</a> 我又重新搭了一下博客，现在已经上线了，但是现在或许还有未发现的 <code>bug</code>？</p><p><a href="https://www.typescriptlang.org/">TypeScript </a> 学起来相对简单但是又也是重要的，我现在感觉写代码不写成 <code>TypeScript</code> 就有点难受的程度了。</p><p><a href="https://git-scm.com/">Git</a> 虽然说掌握了基础的几个命令基本就好了，但是工作中难免会遇到一些分支问题，这时候熟练<code>Git</code>就显得格外重要了。</p><p><a href="https://ant.design/index-cn">Ant Design</a> 及一系列组件库吧，虽然说把它摆出来有点奇怪，但是确实工作中它占的比重还挺大。这里顺便延伸出最近在学的，准备自己也搞个组件库。</p><p><a href="https://storybook.js.org/">Storybook</a> 最近在学的，虽然说还只学了开头吧，也算是这年新学的一个技术了，希望自己也能早日拥有自己就的组件库～</p><h2 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h2><p>其实工作中我们很难说去用后端技术，所以这些都是工作外积累的。在学校学的 c 和 java 这些就不说了，主要就讲今年学的后端的技术。</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p><a href="https://docs.python.org/3/tutorial/index.html">Python</a> 我们学校是不教这个的，虽然不教，但是这个也名声在外。虽然有点兴趣但是并不强烈所以一直没学，机缘巧合就是有朋友 👬 送了我一本 <code>python</code> 的书。从来都是我送书给别人，第一次白嫖到，就把书看了，啊真香。但是你说我学的多牛嘛，也没有，就是能简单爬些数据了，再复杂一点俺就要再翻翻书再琢磨了。</p><h3 id="Egg-js"><a href="#Egg-js" class="headerlink" title="Egg.js"></a>Egg.js</h3><p><a href="https://eggjs.org/zh-cn/tutorials/index.html">Egg.js</a> 你可能听过 Koa ，那其实 Egg.js 就是基于 Koa 的。</p><p>里面我使用的插件主要就是 <a href="https://github.com/eggjs/egg-mysql">egg-mysql</a>，通过配置，我们就可以编写操作访问 MySQL 数据库了，前提是你需要 mysql 的知识。可以操作数据库，也就是写了接口，比如写了操作删数据的逻辑，在前端调用这个接口，就可以直接操作数据库删除这条数据了。用这个搭个中台用来处理数据返回接口是非常不错的选择。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>主力还是 <a href="https://dev.mysql.com/doc/">Mysql</a>，虽然学校也教过，但是真正自己开发了才知道，各种表查询用了不好的方式 导致查询速度慢，数据库最开始没设计好 导致后续一系列问题等等。真的就是要记，熟能生巧，要不然每次都要去搜怎么查询数据，就很不 OK 了。</p><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><p><strong>计算机网络</strong>、<strong>浏览器</strong> 这两大类，真的不是简单学学就能完全理解的，现在我也依然需要时不时翻看来巩固知识。</p><p>其实之前并不觉得有什么，感觉就是<code>http</code>这些，后面因为知识壁垒我去看浏览器和网络相关知识，反而反过来帮助我理解了很多比如 <code>js</code> 的消息队列事件循环、<code>promise async await</code>、页面怎么渲染的、什么时候发什么请求、黑客怎么攻击网站的又怎么去防等等。</p><p>也出过一系列的文章总结：</p><ul><li><a href="https://juejin.cn/post/6900916440845516814">「浏览器安全」你可能需要的一份浏览器安全的总结（内附思维导图）</a></li><li><a href="https://juejin.cn/post/6902032954034225159">「导航渲染流程」你真的知道从输入 URL 到页面展示发生了什么吗？（内附思维导图） </a></li><li><a href="https://juejin.cn/post/6915362842212302862">「计算机网络」前端必备知识，看到就是赚到系列（上）</a></li><li><a href="https://juejin.cn/post/6916318564966203400">「计算机网络」前端必备知识，看到就是赚到系列（下） </a></li></ul><h2 id="理财知识"><a href="#理财知识" class="headerlink" title="理财知识"></a>理财知识</h2><p>虽然说我一直的愿望是：「 变强不变秃 」，但其实我还有一个愿望那就是「财富自由」。</p><p>突然的暴富，对我这个非洲人来说很难实现，而仅仅只靠工资收入，想要达到这个愿望我还需要很多年。并且在存款增加时，钱同时也在贬值，花销也可预见的会增长（结婚、怀孕、生孩子），所以按照长远的人生规划，要不被钱所控，就要学会控制钱 💰。</p><h3 id="远离消费陷阱-🪤"><a href="#远离消费陷阱-🪤" class="headerlink" title="远离消费陷阱 🪤"></a>远离消费陷阱 🪤</h3><p>其实有一阵我是非常喜欢买买买的，这本身没有什么不对，花钱买开心嘛。我要说的是那些并不会让你感到很开心，并且价值低且价格贵的东西。</p><p>第一种就是<strong>奢侈品</strong>：它本身可能并价值不高，但是由于品牌等原因，导致品牌溢价离奇高。这种我是不可能买，因为可预见的我买了，别人也不会认为我买的是真的 😂，并且我大概率不会开心。</p><p>第二种就是需要<strong>贷款</strong>买的东西：需要贷款，其实也就证明这个东西至少是你目前经济水平负担不起的，需要预支你后续的经济来源来还。如果是刚需买个房呀这种还好，确实是需要承担的经济压力。我这里只是说明明没必要，但又莫名就有的这个压力，比如自己赚一万多，买了一辆贵的车 🚗，出去每月车贷和日常开销，自己也就几百的可自由支配资金，那不是莫名给自己增加经济压力嘛，日常代步真的没必要攀比买名车呀，贷款前思考一下真的有必要买这么贵的嘛？</p><p>第三种可能还好就是看到<strong>便宜就买</strong>：前面两点对于我这种没啥钱 💰 的，基本伤不到我，这个就不一定了。看到它降价、打折、满 200 减 20 这种就想凑单。大学那会真的 蹲直播间、玩 tao🍑 拉人游戏、凑单、分好几单为了凑满减、帮忙砍一刀。那时候可能还是有点优惠的。现在买个东西感觉连 9 折都没有，并且现在我也没朋友了 😭，现在看清了陷阱 🪤，我不会非等到双十一，不会为了凑单而买一些其实没啥用的东西。</p><h3 id="看理财的书-📖"><a href="#看理财的书-📖" class="headerlink" title="看理财的书 📖"></a>看理财的书 📖</h3><p>光有思想的觉悟还不行，还要有知识的支撑，这里放基本我在看和准备看的理财的书 📖：</p><p>《不上班也有钱》</p><blockquote><p>简介：30 多岁就退休环游世界，台妹 Winnie 及美籍先生 Jeremy 原是一般科技上班族，靠着减少物欲及开支，存下 70%以上的收入，实现提早退休的梦想，看似不可能的圆梦故事，被国内外各大媒体争相报道。</p></blockquote><p>《穷爸爸富爸爸》</p><blockquote><p>简介：《富爸爸穷爸爸》清崎有两个爸爸：“穷爸爸”是他的亲生父亲，一个高学历的教育官员；“富爸爸”是他好朋友的父亲，一个高中没毕业却善于投资理财的企业家。清崎遵从“穷爸爸”为他设计的人生道路：上大学，服兵役，参加越战，走过了平凡的人生初期。直到 1977 年，清崎亲眼目睹一生辛劳的“穷爸爸”失了业，“富爸爸”则成了夏威夷最富有的人之一。清崎毅然追寻“富爸爸”的脚步，踏入商界，从此登上了致富快车。清崎以亲身经历的财富故事展示了“穷爸爸”和“富爸爸”截然不同的金钱观和财富观穷人为钱工作，富人让钱为自己工作！</p></blockquote><p>《财务自由之路》：</p><blockquote><p>简介：在本书中，欧洲第一理财教练博多•舍费尔将为你介绍梦想、目标、价值观和策略这四大致富支柱，指导你转变理财观念，运用有效的投资理财策略，在保证财务安全的前提下，实现财务自由。你将学到：怎样合理利用负债：科学储蓄并利用储蓄致富；股市投资的 10 条黄金法则；选择基金的技巧及投资基金的 10 条建议。</p></blockquote><p>我也是看推荐去看的这些书，如果你还有更好的书推荐的话，十分欢迎 👏 你写到评论区 💗</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2021 学习清单 🧾：</p><ul><li>✅ Vue 全家桶电商平台</li><li>✅ Next+Egg+React+mysql 全栈开发新闻平台</li><li>✅ 重构博客平台</li><li><ul><li><input disabled="" type="checkbox"> 组件库 编码 ing…</li></ul></li><li><ul><li><input disabled="" type="checkbox"> 理财学习 ing…</li></ul></li></ul><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>刚开始工作一年，说实话不会有太难的工作内容，也不会有很多的工作压力。但是工作非常重要，因为它占据了我绝大多数的时间 ⌚️。</p><p>这一年呢我的工作的四大状态就是：开会讨论 💺、编码 💻、摸鱼 🐟、总结 📝</p><p><strong>开会</strong>💺</p><p>总计开过可能近一百场的会议，包括需求评审会议、设计评审会议还有每周周会等会议。这些会议存在的意义，依照我的理解就在于讨论沟通再调整。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/317c934be2fc4e6fa995fa8629e75907~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ul><li>需求评审会议：理解这个需求为什么要做，能不能做</li><li>设计评审会议：前端指出不合理的地方，顺带提出可行方案</li><li>前端会议： 估时间，根据功能分工，技术点分析等</li><li>周会：总结</li></ul><p><strong>编码</strong>💻</p><p>从 Vue 转到 React，如果不是公司技术栈，我估计我可能会一直写 Vue 吧。倒是因为一直学和写 React，Vue 都要忘了 😂</p><p>这里就不说需求做了啥了，有的涉及一些业务不太好总结。</p><p><strong>摸鱼</strong>🐟</p><p>摸鱼还是要摸的，一个成熟的程序员怎么能不会摸鱼呢。这个摸鱼时间可长可短，想要摸鱼时间长那就凭本事了。</p><p>摸鱼也不总结了，俺自己知道就好了，还总结一下多不好呀。说点官话，就是希望以后高质量摸鱼哈哈哈。</p><p><strong>总结</strong>📝</p><p>总结是非常有必要的，有输入有输出有积累才会持续进步。但也不用每天都来个总结，或许也不是非得写出来，只是要知道自己在做什么，给你带来了什么，有什么价值等。</p><p>总共输出了包括技术分享、组件重构、技术调研、版本开发文档等共计约 15 篇文章。需要改进的是还有许多，比如格式规范、内容整理得更加有条理、研究的深度等。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>除了工作学习当然也要好好的生活啦。这一章可能图片会有点多，不知道怎么说，就放多了点图，就看着好玩好了 👌。</p><h2 id="吃好玩好"><a href="#吃好玩好" class="headerlink" title="吃好玩好"></a>吃好玩好</h2><p>当然生活中对我而言最重要的就是吃什么，吃好才有力气干活。玩虽然也不是必须的，但是把握度确实能让我开心。</p><h3 id="关于吃"><a href="#关于吃" class="headerlink" title="关于吃"></a>关于吃</h3><p>关于吃，分为自己做饭吃，探店吃以及和朋友聚餐（几乎不会点外卖）。</p><p>自己做饭的话，确实是花费精力和时间（可能还不好吃），但是谁生来就是大厨呢，咱们从简单的开始，煎个蛋包个饺子煮个面，再到炒青菜炒肉炒饭，再到做自己喜欢吃的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8669ee98bac438db80da040e767bf63~tplv-k3u1fbpfcp-watermark.image?" alt="D4BC06ECB3D7DABD70E82444E64EA2A5.jpg"></p><p>实在不行网上教程也很多，相关的书也很多（但其实我又知道了，我可能只是懒）</p><p>不自己做那就走出去吃呗，大街小巷总有你喜欢吃的。时常感叹周围的美食太多了，经常让我产生不做饭的想法，啊这。也放个图吧：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85a5c202317d4b748fb8c34094cb1111~tplv-k3u1fbpfcp-watermark.image?" alt="017AF446D27E1F9D1E0EBCE5FE7B5913.jpg"></p><p>再就是聚会约饭，大学同学 👨‍🎓 大概也就约了三次吧，谁要他们都是行业精英呢，太难约了真的是 😂。</p><p>这一年和高中玩得最好的闺蜜约了一次逛街，和大学在同一城市的同学约了一次大型聚餐，两次中型聚餐，还有两次家庭聚会，以及被鸽的和大学学姐的聚餐。总的来说还是很多的，对于我这种相对宅的人来说。</p><p>如果可以我还是觉得可以多聚聚。</p><h3 id="关于玩"><a href="#关于玩" class="headerlink" title="关于玩"></a>关于玩</h3><p>从玩一些打发时间的游戏 🎮 比如 2048、数独，到玩王者（现在不玩了）、玩吃鸡（现在也不玩了）再到最近在玩的金铲铲。玩游戏确实能非常快的带来开心，但其实这种开心愉悦也只是短暂的，所以说要把握一个度呀。</p><p>然后也看一些综艺和电视剧 📺，有印象觉得不错的就《你是我的荣耀》和最近看了一个电视剧《成人练习生》从第三集开始看，太甜了，但是只有三集太短了 😭。</p><h2 id="爱情-💓"><a href="#爱情-💓" class="headerlink" title="爱情 💓"></a>爱情 💓</h2><p>关于爱情的总结，我很纠结到底要不要写出来，也不是不愿意和大家分享，就是不知道怎么说。</p><p>我其实应该算那种不谈恋爱自己也能过得非常舒服，谈恋爱也不会粘人的那种类型。既不会主动去和男生聊天，单如果有人找我聊天三两句我就能聊冷场或者聊成工作等。甚至因为这个行为，让人以为我有男友了，所以和男生保持距离。你以为这就有点离谱了是吧，更离谱的是我自己还和别人开玩笑说我确实有个校外男友，长得又高又帅成绩又好巴拉巴拉的，就这样好多人都信了，我也就真没法不单身了 😂。</p><p>然后就是说，就我这样竟然在大四这一年还脱单了。也随便说一说和憨憨的故事吧，和憨憨在一起确实也就一年，前几天刚过完周年，虽然说在一起只有一年，但是其实之前已经相识三四年了，我是新班长他是旧班长这样。年初他来我家这边顺便见了我方家长，年初我们一起来这边实习，然后回学校毕设，结束后又来这边入职正式工作，开始了俺们两人的新生活。</p><p>没想到总结起来还是挺短的，写详细了估计也没人想看，就这样吧～</p><h2 id="家人"><a href="#家人" class="headerlink" title="家人"></a>家人</h2><p>深处异地，我家还只有我一个小孩，虽说我家实行的是放养制，家里人也习惯我经常不在家，但是像这种一年可能也就回一次家的情况属实有点太长了。</p><p>直到写这篇文章的时候我才意识到，原来我主动联系家里人的次数，仅仅只有大概一周一次。这一点尤其对比憨憨几乎每天一次，就显得格外的少了。</p><p>憨憨对我来说现在也是家人般的存在，生病难受的时候，如果没有他，真的会非常艰难吧，或许也不会体会到这个城市的温暖吧。</p><h2 id="猫-🐱"><a href="#猫-🐱" class="headerlink" title="猫 🐱"></a>猫 🐱</h2><p>养一只猫实在是太治愈了，其实一直都非常纠结要不要养。直到现在租了一个大的房子 🏠，有阳台，有能放它各种玩具吃的和窝的地方，有富余的钱 💰 养她等等，这个想法才最终敲定。</p><p>它实在是太可爱了，会在你办公的时候趴在键盘 ⌨️ 旁，揣着小手看着你。会在你脚边睡着。还会在早上把你叫醒。她会调皮嘛，答案是会的，她也掉毛，需要你陪她。但是小猫能有什么坏心思呢？掉毛用吸毛器洗掉不就好了？她一直陪你等你回家，你陪她玩玩怎么了？</p><p>养猫 🐱 无疑让我的生活发生了改变，一想到家里有只小家伙还在等我，心里就好开心，回到家还会蹭你，真的太治愈了，吸吸秋咪（我家 🐱 名字），一天工作的疲惫都没有了呢。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2af404df5266449ca92335fa912104aa~tplv-k3u1fbpfcp-watermark.image?" alt="BB3DBFB97E4A4C693F3A21808B5AEA10.jpg"></p><h2 id="自己"><a href="#自己" class="headerlink" title="自己"></a>自己</h2><p>相比一年前，长胖了 7 斤？简单分析一下原因呀，经常是坐着不咋活动，回家也坐着。吃的多了健身少了。。。然后就胖了。今年多多少少是没办法改变了，这也是这一年做的不是很好的地方，请来年 2022 年践行「管住嘴，迈开腿」这句话 👌。</p><p>然后是相比一年前，更注重护肤了，也是老了嘛。但是护肤的水好深，目前还没找到什么感觉特别好的护肤品。</p><p>反而相比大学，化妆减少了，化妆技术呢也没有进步，估计还退步了吧。原因呢当然是太难起床化妆了啦，基本上打个底就出门，现在冬天我更狂，直接素颜去公司上班了。能多睡一会就是一会吧，长期来看不会改变 😂，可惜了我的化妆品用不完了 😭。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>2021 生活清单 🧾：</p><ul><li><ul><li><input disabled="" type="checkbox"> 加强锻炼，减肥回到原来体重</li></ul></li><li><ul><li><input disabled="" type="checkbox"> 和家人常主动联系，更亲近</li></ul></li><li><ul><li><input disabled="" type="checkbox"> 和朋友有时间多聚</li></ul></li><li><ul><li><input disabled="" type="checkbox"> 旅游</li></ul></li><li>✅ 保持存款，投资</li><li>✅ 精简化妆品，研究护肤</li><li>✅ 保持一定时间陪猫 🐱 玩</li><li>✅ 关心憨憨</li></ul><h1 id="我与掘金"><a href="#我与掘金" class="headerlink" title="我与掘金"></a>我与掘金</h1><p>专门写一章来讲述我与掘金，@juejin 运营 够意思吧那还不给我推荐 💐 。这一小节会讲述在掘金的收获和反思</p><h2 id="相遇"><a href="#相遇" class="headerlink" title="相遇"></a>相遇</h2><p>与掘金的相遇确实主要是因为面试，相信有很多朋友也是这样的，当时我还只是一个读者，我看得多的就是面试相关的文章哈哈 😄。</p><h2 id="发布第一篇文章"><a href="#发布第一篇文章" class="headerlink" title="发布第一篇文章"></a>发布第一篇文章</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dbf2cf35a2340fb9afe3a8021f91913~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ul><li><a href="https://juejin.cn/post/6900916440845516814">「浏览器安全」你可能需要的一份浏览器安全的总结（内附思维导图）</a> 这篇文章其实是我自己总结，自己看的，因为自己当时对同源策略、跨站脚本攻击（xss）、跨域请求伪造（CSRF）这些知识相对薄弱。</li></ul><p>秉持着学习知识也输出知识的理念，我着手将这片文章优化发表。</p><p>但事实是想要发一篇不错的文章还是要花很多心思的，比如文案、首图、交互等等，我希望读者看到我的文章不会觉得我是粗制滥造，理解知识也是容易的。</p><h2 id="正向反馈"><a href="#正向反馈" class="headerlink" title="正向反馈"></a>正向反馈</h2><p>当我将我总结的知识发表出去时，我发现其实还是有很多人和我一样，对一些知识没有总结到位或者理解到位。也收获了一些志同道合的朋友。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb539b586bec4d66a0a08e86a6bcaa34~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="质疑"><a href="#质疑" class="headerlink" title="质疑"></a>质疑</h2><p>有正面的当然也有负面的啦，虽然说其实没几条，但由于我每个评论都会看，所以还是有点印象。</p><p>主要是在这篇 <a href="https://juejin.cn/post/6930897845369356295">🐮 化身面试官出 30+Vue 面试题，超级干货（附答案）｜牛气冲天新年征文</a>，其实是一个参与活动的文章，本来只是想写 vue 的面经，可是我是谁，肯定不能这么没有诚意，至少要给个参考答案吧，所以有了这篇文章。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d6f5f5c9ffc40a9bec15d5a63fe1b78~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>没想到有那么多人看，说实话我自己也慌了，因为我自己也深刻意识到我自己不是什么厉害的人物，这种面试文章的形式会不会不好？面试题有没有写全？会不会我的答案给别人造成误解？。。。</p><p>最后还是自己给自己解答，那就是对自己写出来的文章负责，努力写出好文，同时接受批评改正进步。</p><h2 id="成为鸽子-🐦"><a href="#成为鸽子-🐦" class="headerlink" title="成为鸽子 🐦"></a>成为鸽子 🐦</h2><p>写一篇文章，说实话没有什么收益，且需要投入大量时间成本，而你的时间又十分有限。虽然说掘金还是有很多鼓励政策，我也白嫖到了掘金的好多周边，但是权衡下来，我(没错）逐渐成为了鸽子。</p><p>容我狡辩一下：好的内容一定是经过沉淀的，学习也不是一件短暂的事情，所以保持非常勤的更新并不是件好事。</p><p>但是我还是会保持一定的输出的，写博客、有知识的理解输出，我始终认为是一个好习惯，这个是肯定的，只不过不会更新很快就是了。</p><p>顺便一提，我最近想跟进一下面试系列，准备写一篇《🐯 化身面试官出 30+React 面试题，超级干货（附答案）》的文章，想看的小伙伴可以点个赞或者评论让我知道，我再决定要不要写吧。</p><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><p>这一年，从大学迈入社会，从学生变成职场人，我也在慢慢适应逐渐成为一个成熟的人。虽然说还没有到自己特别满意，但人生不就是这样嘛。</p><p>这一年发生了很多变化，从管家里要钱到现在往家里给钱，从一堆人到一个人再到两个人，从读者到作者，同事、城市、工作从陌生到熟悉。。。</p><p>这一年也学到了很多东西。对于一个职场新人，第一年无疑是会学到很多东西的，但是我还是希望后续也能保持着这种状态，不畏惧学习新知识，对于旧知识也加强巩固，共勉。</p><p>2022 年 待总结…</p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
          <category> 关于我 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
            <tag> 关于我 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Redux写一个todoList</title>
      <link href="/posts/11112/"/>
      <url>/posts/11112/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写了 <code>Redux</code> 相关的实战，很多人说：啊！Up主这个你涉及的知识点太多了呀，我学不会呀，有没有简单一点的呀？</p><p>我想了想，确实一个知识点就不要穿插其他难懂的知识点了，这样对小白不友好，那我就给大伙写用最原始的 <code>html、css、js</code> 和 <code>redux</code> 的来写一个简易版的todolist吧，保证你立马上手redux</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f49a44e032fe4854b0eec27cfaa9b4ac~tplv-k3u1fbpfcp-watermark.image?" alt="TodoList"><br>这个效果的功能点有：</p><ol><li><code>input</code> 框输入点击<code>+</code>将添加到下方</li><li>点击下方某 <code>item</code> 可以将其删除<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2></li><li>在你的开发环境添加 <code>react</code> 、 <code>redux</code> <ul><li>这个你不会的话就去安装一个npm或者yarn，用npm或yarn命令来安装。</li></ul></li><li><code>index.js</code>  主文件，入口</li><li><code>TodoList.js</code>  `  组件文件，实现</li><li><code>store/index.js</code>  返回 <code>store</code> ，你可以把它想象为银行存款会影响视图更新（我也忘记从哪里看的这个比喻的，我觉得还挺好理解的）</li><li><code>store/reducer.js</code>  银行的计算器，处理数据。根据 <code>action.type</code> 你要做啥操作，()=&gt; newState计算出的钱💰 会改变原来的存款 💰</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p>通过 <code>Provider</code> 将 <code>store</code> 注射进 <code>TodoList</code> 组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TodoList</span> <span class="keyword">from</span> <span class="string">&#x27;./TodoList&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Provider</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;<span class="comment">//提供器</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>=(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">TodoList</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="title class_">App</span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="TodoList-js"><a href="#TodoList-js" class="headerlink" title="TodoList.js"></a>TodoList.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>; <span class="comment">//链接器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TodoList</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; inputValue,list,inputChange,clickBtn,deletItem&#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;content&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;todoListDiv&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;inputDiv&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;inputChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;clickBtn&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;listDiv&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;list.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">              return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;deletItem&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;item&#125;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">            &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">stateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">inputValue</span>: state.<span class="property">inputValue</span>,</span><br><span class="line">    <span class="attr">list</span>: state.<span class="property">list</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dispatchToProps</span> = (<span class="params">dispatch</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">inputChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;change_input&quot;</span>,</span><br><span class="line">        <span class="attr">value</span>: e.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="title function_">dispatch</span>(action);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">clickBtn</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;add_item&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="title function_">dispatch</span>(action);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">deletItem</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;delete_item&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="title function_">dispatch</span>(action);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(stateToProps, dispatchToProps)(<span class="title class_">TodoList</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code>connect</code> 可以在 <code>stateToProps</code> 获得 <code>state</code> 的值并把它注射到 <code>props</code> 里，可以看到在 <code>props</code> 可以获得  <code>inputValue</code>  和 <code>list</code>  这两个值。</p><p>同理  <code>dispatchToProps</code>  ，这些方法  <code>inputChange,clickBtn,deletItem</code>  也可以在  <code>props</code>  获取，里面写的  <code>dispatch(action)</code>  对应  <code>reducer.js</code>  文件：</p><h3 id="reducer-js"><a href="#reducer-js" class="headerlink" title="reducer.js"></a>reducer.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState =&#123;</span><br><span class="line">    <span class="attr">inputValue</span>:<span class="string">&#x27;Hearling&#x27;</span>,</span><br><span class="line">    <span class="attr">list</span>:[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState,action)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&#x27;change_input&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> newState = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state))</span><br><span class="line">        newState.<span class="property">inputValue</span> = action.<span class="property">value</span></span><br><span class="line">        <span class="keyword">return</span> newState</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&#x27;add_item&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> newState = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state))</span><br><span class="line">        newState.<span class="property">list</span>.<span class="title function_">push</span>(newState.<span class="property">inputValue</span>)</span><br><span class="line">        newState.<span class="property">inputValue</span>=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> newState</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>action.type</code>  识别要做什么操作，会更新 <code>store</code> </p><h3 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>提供 <code>store</code></p><h3 id="inex-css"><a href="#inex-css" class="headerlink" title="inex.css"></a>inex.css</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">content</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">100</span>%;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    justify-<span class="attr">content</span>: center;</span><br><span class="line">    align-<span class="attr">items</span>: center;</span><br><span class="line">    background-<span class="attr">image</span>: linear-<span class="title function_">gradient</span>( </span><br><span class="line">    62deg, <span class="title function_">rgb</span>(<span class="number">135</span> <span class="number">94</span> <span class="number">215</span> / <span class="number">48</span>%) <span class="number">13</span>%, <span class="title function_">rgb</span>(<span class="number">161</span> <span class="number">122</span> <span class="number">255</span> / <span class="number">29</span>%) <span class="number">4</span>%), linear-<span class="title function_">gradient</span>( </span><br><span class="line">    44deg, <span class="title function_">rgba</span>(<span class="number">0</span>, <span class="number">43</span>, <span class="number">99</span>, <span class="number">0.0792209024</span>) <span class="number">39</span>%, <span class="title function_">rgb</span>(<span class="number">242</span> <span class="number">140</span> <span class="number">206</span> / <span class="number">29</span>%) <span class="number">18</span>%), linear-<span class="title function_">gradient</span>( </span><br><span class="line">    118deg, <span class="title function_">rgba</span>(<span class="number">84</span>, <span class="number">202</span>, <span class="number">242</span>, <span class="number">0.0315299727</span>) <span class="number">40</span>%, <span class="title function_">rgba</span>(<span class="number">215</span>, <span class="number">152</span>, <span class="number">218</span>, <span class="number">0.5</span>) <span class="number">54</span>%), linear-<span class="title function_">gradient</span>( </span><br><span class="line">    58deg, <span class="title function_">rgba</span>(<span class="number">246</span>, <span class="number">171</span>, <span class="number">236</span>, <span class="number">0.161</span>) <span class="number">83</span>%, <span class="title function_">rgba</span>(<span class="number">240</span>, <span class="number">193</span>, <span class="number">230</span>, <span class="number">0.909</span>) <span class="number">23</span>%);</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">todoListDiv</span>&#123;</span><br><span class="line">    border-<span class="attr">radius</span>: 8px;</span><br><span class="line">    <span class="attr">width</span>: 480px;</span><br><span class="line">    background-<span class="attr">color</span>: #10101d;</span><br><span class="line">    <span class="attr">padding</span>: 24px;</span><br><span class="line">&#125;</span><br><span class="line">input&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">    <span class="attr">padding</span>: <span class="number">0</span> 4px;</span><br><span class="line">    <span class="attr">border</span>: none;</span><br><span class="line">    border-<span class="attr">bottom</span>: 1px solid #fff;</span><br><span class="line">    background-<span class="attr">color</span>: transparent;</span><br><span class="line">    <span class="attr">color</span>: #fff;</span><br><span class="line">&#125;</span><br><span class="line">button&#123;</span><br><span class="line">    <span class="attr">width</span>: 44px;</span><br><span class="line">    <span class="attr">height</span>: 41px;</span><br><span class="line">    border-<span class="attr">radius</span>: <span class="number">50</span>%;</span><br><span class="line">    background-<span class="attr">size</span>: 44px;</span><br><span class="line">    background-<span class="attr">position</span>: center;</span><br><span class="line">    background-<span class="attr">repeat</span>: no-repeat;</span><br><span class="line">    background-<span class="attr">image</span>:<span class="title function_">url</span>(<span class="string">&#x27;add.svg&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">inputDiv</span>&#123;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line">ul&#123;</span><br><span class="line">    list-<span class="attr">style</span>: none;</span><br><span class="line">    <span class="attr">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">    background-<span class="attr">color</span>: <span class="title function_">rgb</span>(<span class="number">136</span> <span class="number">130</span> <span class="number">147</span> / <span class="number">48</span>%);</span><br><span class="line">    border-<span class="attr">radius</span>: 4px;</span><br><span class="line">    margin-<span class="attr">bottom</span>: 12px;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    align-<span class="attr">items</span>: center;</span><br><span class="line">    <span class="attr">padding</span>: 8px;</span><br><span class="line">    <span class="attr">color</span>: #e9e2f5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上 <code>css</code> 就是加上灵魂</p><blockquote><p>如果说上面是做的剁椒鱼头的鱼头那剁椒和调料就是这道菜的灵魂了</p></blockquote><h2 id="思考时间🤔"><a href="#思考时间🤔" class="headerlink" title="思考时间🤔"></a>思考时间🤔</h2><p>虽然是能实现功能，但是我还是希望你能知道这个小功能还是有缺陷的。这里提一下对标实际开发可能存在的问题：</p><h3 id="缺少功能"><a href="#缺少功能" class="headerlink" title="缺少功能"></a>缺少功能</h3><ol><li>首先是我故意少写了一个删除的代码逻辑，希望你能看懂自实现这个功能</li><li>可以加定时功能</li><li>可以增加分类</li><li>云存储<h3 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h3></li><li>现在的值刷新页面就会没有，需要将值存起来</li><li>和实际项目有区别，可以搞个 <code>mock</code> 接口获取数据</li><li>在 <code>React hook</code> 里是不这么写的</li><li>当数据、或者方法很多的时候，我们要怎么写才能让代码可读性更高呢？</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>非常感谢你看到这，如果觉得不错的话点个赞 ⭐ 吧</p><p>今天也是在努力「 变强不变秃 」的 <code>HearLing</code> 呀 ❤️</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Redux </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Redux Toolkit」 是个好东西 💗</title>
      <link href="/posts/11102/"/>
      <url>/posts/11102/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hello朋友们，我又来分享技术调研了，芜湖～</p><p>这次是Readux Toolkit，它配合我上次调研的 <code>proxy-memoize</code> 一起来优化一下我们项目现在的状态管理。</p><p>相信大部分小伙伴还是对 <code>redux</code> 更了解，那这个Readux Toolkit又是个啥东西的，能带来啥，怎么用。那这篇文章可能能帮你解决这几个疑问。当然如果你想更详细的了解的话肯定是要看<a href="https://redux-toolkit.js.org/tutorials/overview">官网</a>的啦。</p><p>那么话不多说，进入正题吧</p><h2 id="基于Redux优化"><a href="#基于Redux优化" class="headerlink" title="基于Redux优化"></a>基于Redux优化</h2><p>首先毫无疑问，Readux Toolkit是基于Redux的一系列优化，那优化了redux的什么呢，这里我就简要的讲一讲redux可能存在的缺点（从一些角度说它的缺点也是了优点，因场景而异啦）：</p><ol><li>我们很多状态都要抽象到 store，一个变化就要对应编写 action，reducer</li><li>需要几个软件包来使Redux与React一起工作，例如redux-thunk、reselect</li><li>Redux的一些理念导致我们需要写很多样板代码</li><li>配置 Redux store太复杂</li></ol><p>当然我们也不全是因为redux他的这些所谓的缺点，而非要卷来优化哈，其实也是因为调研Readux Toolkit我才发现这redux的缺点，虽然是上级给的任务，但是调研之后发现还是真香。</p><h2 id="需了解的知识"><a href="#需了解的知识" class="headerlink" title="需了解的知识"></a>需了解的知识</h2><p>首先当然是要了解redux知识啦，有redux知识为了方便更迅速理解Readux Toolkit的实现或者他的妙用，还需要先了解他的核心依赖：</p><ul><li>immer</li><li>redux</li><li>redux-thunk</li><li>reselect</li></ul><h3 id="immer"><a href="#immer" class="headerlink" title="immer"></a>immer</h3><p>这几个中我是不了解这个immer的，其他基本略知一二，那么就看看这个immer库是个啥吧：</p><p>这个库，它允许我们把state的 <code>不变的（immutable）</code> 特性转化为 <code>可变的（mutable）</code>；</p><p>具体上的实现它是利用了 <code>proxy</code>，当我们对 state 进行修改，proxy对象会拦截，并且按顺序替换上层对象，返回的新对象。看上去就好像自动帮你直接修改了state</p><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>首先看看整体的Api，然后再详细说说可能会常用的：</p><ul><li><code>configureStore ()</code>: 包装 <code>createStore</code> 以提供简化的配置选项和良好的默认设置。它可以自动组合你的slice reducers，添加你提供的任何 Redux 中间件，默认包括 <code>Redux-thunk</code>，并启用 Redux DevTools 扩展。</li><li><code>createReducer ()</code> : 它允许您为 case reducer 函数提供一个动作类型查找表，而不是编写 switch 语句。此外，它还自动使用 <code>immer</code> 库，让您使用普通的可变代码编写更简单的不可变更新，比如 state.todos [3].complete = true。</li><li><code>createAction ()</code> : 为给定的动作类型字符串生成动作创建器函数。函数本身定义了 <code>toString ()</code> ，因此可以使用它来代替类型常量。</li><li><code>createSlice ()</code> : 接受 reducer 函数的对象、片名和初始状态值，并自动生成带有相应动作创建器和动作类型的 slice reducer。</li><li><code>createAsyncThunk</code>: 接受一个操作类型字符串和一个返回promise函数，并生成一个 thunk，该 thunk 根据该promise dispatches <code>pending/fulfilled/rejected</code>的action types</li><li><code>createEntityAdapter</code>: 生成一组可重用的还原器和选择器来管理存储中的规范化数据</li><li>reselect库中的 <code>createSelector</code> utility，为了方便使用而re-exported。</li></ul><h3 id="configureStore"><a href="#configureStore" class="headerlink" title="configureStore"></a>configureStore</h3><p><strong>step1</strong> 是 <strong>configureStore</strong>，这个必不可少，用来创建一个空的Redux store，同时这里呢会自动配置 Redux DevTools 扩展，以便检查存储：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">    <span class="attr">reducer</span>: &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>step2</strong> 是要&lt; provider &gt; 来使 redux 对 React 组件可用，将导出的store当作prop传递给它，这一块不必多说</p><h3 id="createSlice"><a href="#createSlice" class="headerlink" title="createSlice"></a>createSlice</h3><p><strong>step3</strong> 这里会有点不一样了，我们要通过 <strong>createSlice</strong> 创建一个Redux状态切片（Redux State Slice），创建这个slice需要：</p><ol><li>一个字符串名来标识该片</li><li>一个初始状态值</li><li>一个或多个 reducer 函数来定义如何更新该状态<br>创建这个slice能干嘛？可以导出生成的 Redux 动作创建器（action creators）和整个片的 reducer 函数：</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">  initialState,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * Redux Toolkit 允许我们在还原器中编写“可变的（mutable）”逻辑。</span></span><br><span class="line"><span class="comment">       * 它实际上并没有改变状态，因为它使用 Immer 库,</span></span><br><span class="line"><span class="comment">       * 它将检测对&quot;draft state&quot; 的更改，并根据这些更改生成</span></span><br><span class="line"><span class="comment">       * 一个全新的不可变状态</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      state.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">value</span> -= <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">incrementByAmount</span>: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">value</span> += action.<span class="property">payload</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个 reducer 函数生成动作创建器（Action creators）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, incrementByAmount &#125; = counterSlice.<span class="property">actions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span></span><br></pre></td></tr></table></figure><p>结合这个例子，可以清楚的看到这个createSlice接收的：一个字符串名来标识该片也就是name，一个初始状态值initialState，以及多个reducer函数。并且为每个 reducer 函数生成动作创建器。</p><p>它有啥作用或者其他好处呢？可能一小部分人不看代码，我把注释给拿下来。</p><p>我们知道 Redux 它是要求我们通过制作数据副本和更新副本来编写所有状态更新的。然而， createSlice 和 createReducer 在内部使用 Immer 来允许我们编写“可变的（mutable）”的更新逻辑，使其成为正确的不可变更的更新。</p><blockquote><p>Redux Toolkit 允许我们在还原器中编写“mutable”逻辑。它实际上并没有改变状态，因为它使用 Immer 库,检测对“draft state”的更改，并根据这些更改生成一个全新的不可变状态</p></blockquote><p><strong>step 4</strong>  我们需要从上面的创建的空的 store 导入 reducer 函数并将其添加到我们的存储中，通过在 reducer 参数中定义一个字段，告诉 store 使用这个 slice reducer 函数来处理该状态的所有更新。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;../features/counter/counterSlice&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">counter</span>: counterReducer,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>step 5</strong> 现在我们可以使用 React-Redux hook 让 React 组件与 Redux 存储交互。我们可以使用 useSelector 从存储中读取数据，并使用 useDispatch 分派操作。</p><p>理解的话我们看这个 counter 组件的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; decrement, increment &#125; <span class="keyword">from</span> <span class="string">&#x27;./counterSlice&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">counter</span>.<span class="property">value</span>)</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125; &gt;</span></span><br><span class="line"><span class="language-xml">          增加+</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125; &gt;</span></span><br><span class="line"><span class="language-xml">          减少-</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当点击+、-按钮时的动作，分析：</p><ul><li>相应的 Redux action 将被派发（dispatched）到存储区（store）</li><li>这个 counter slice reducer将观测actions并更新其状态</li><li>&lt; Counter &gt; 组件将观测到存储（store）中新的状态值，并使用新数据re-render自己</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里也放一个简单的例子，可以访问codesandbox的可以<a href="https://codesandbox.io/s/github/reduxjs/redux-essentials-counter-example/tree/master/?from-embed">戳这里</a>，也可以去官网找这个例子。</p><p>store.js 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@reduxjs/toolkit&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;../features/counter/counterSlice&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">    <span class="attr">reducer</span>: &#123;</span><br><span class="line">        <span class="attr">counter</span>: counterReducer,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>counterSlice.js 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&#x27;@reduxjs/toolkit&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> slice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">    <span class="attr">initialState</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">reducers</span>: &#123;</span><br><span class="line">        <span class="attr">increment</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">value</span> += <span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">decrement</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">value</span> -= <span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">incrementByAmount</span>: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">value</span> += action.<span class="property">payload</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, incrementByAmount &#125; = slice.<span class="property">actions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">incrementAsync</span> = amount =&gt; <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">dispatch</span>(<span class="title function_">incrementByAmount</span>(amount));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">selectCount</span> = state =&gt; state.<span class="property">counter</span>.<span class="property">value</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> slice.<span class="property">reducer</span>;</span><br></pre></td></tr></table></figure><p>Counter.js 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    decrement,</span><br><span class="line">    increment,</span><br><span class="line">    incrementByAmount,</span><br><span class="line">    incrementAsync,</span><br><span class="line">    selectCount,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./counterSlice&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./Counter.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">useSelector</span>(selectCount);</span><br><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"><span class="keyword">const</span> [incrementAmount, setIncrementAmount] = <span class="title function_">useState</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125; &gt;</span></span><br><span class="line"><span class="language-xml">        +</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125; &gt;</span></span><br><span class="line"><span class="language-xml">        -</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;incrementAmount&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setIncrementAmount(e.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span></span></span><br><span class="line"><span class="language-xml">        dispatch(incrementByAmount(Number(incrementAmount) || 0))</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">        Add Amount</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(incrementAsync(Number(incrementAmount) || 0))&#125; &gt;</span></span><br><span class="line"><span class="language-xml">        Add Async</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./app/store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里简要的讲一下这个简单例子的整体的步骤：</p><ol><li><strong>使用 configureStore 创建 Redux 存储</strong><ul><li>configureStore 接受作为命名参数的 reducer 函数</li><li>configureStore 自动设置好了默认设置</li></ul></li><li><strong>向 React 应用程序组件提供 Redux 存储</strong><ul><li>在 组件外包裹 React-Redux &lt; Provider &gt; 组件</li><li>&lt; Provider store = { store } &gt; </li></ul></li><li><strong>使用 createSlice 创建一个 Redux“ slice”reducer</strong><ul><li>使用字符串名称、初始 state 和 reducer 函数调用 createSlice</li><li>Reducer 函数可能使用 Immer“mutate”状态</li><li>导出生成的slice reducer 和 action creators</li></ul></li><li><strong>在 React 组件中使用 redux useSelector/useDispatch 挂钩</strong><ul><li>使用 useSelector 钩子从 store 中读取数据</li><li>使用 useDispatch 钩子获取 dispatch 函数，并根据需要进行 dispatch actions 操作</li></ul></li></ol><p>OK，大概就总结道这里了，你会发现还有一些主要的api没有讲到，比如很重要的createReducer 和 createAction这些还没讲，但是这个小应用也能实现了（这个例子的场景限制发挥了呀）。</p><p>那其实你知道这些基本就能使用了，还有就是这篇也没讲到 use Redux Toolkit and React-Redux with TypeScript，下篇我们详细讲一下搭配 TypeScript 如何使用以及他的好处吧。</p><p>🌸🌸🌸🌸🌸 </p><p>非常感谢你看到这，如果觉得不错的话点个赞 ⭐ 吧</p><p>今天也是在努力变强不变秃的 <code>HearLing</code> 呀 💪</p><p>🌸🌸🌸🌸🌸</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 技术调研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 技术调研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proxy-memoize代替reselect</title>
      <link href="/posts/11021/"/>
      <url>/posts/11021/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在像 React 这样的前端框架中，对象不变性非常重要。但其实它本身并不支持强制不变性。那这个库利用了 <code>Proxy</code> 和 <code>WeakMap</code>，并提供了记忆功能。<strong>仅当参数(对象)的使用部分发生变化时，记忆函数才会重新计算原始函数。</strong></p><p>通过引言我们已经知道了它的<strong>优点</strong>，那么你可能会好奇他是如何实现的，那么你可以看看下面这个介绍，如果你只关心它是如何使用你也可以跳过这一小节：</p><h2 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h2><p>当它(重新)计算一个函数时，它将用<strong>代理</strong>(递归地，根据需要)<strong>包装一个输入对象</strong>并调用该函数。当它完成时，它将检查什么是<strong>受影响的</strong>。这个受影响其实是在函数调用期间访问的<strong>输入对象的路径列表</strong>。</p><p>当它下一次接收到一个新的输入对象时，它将检查<strong>受影响路径中的值</strong>是否被更改。如果是被更改，那么它将重新计算函数。否则，它将返回一个缓存结果。默认缓存大小为1，可配置。</p><p>一个个说吧，首先要包装成对象：显然这里需要注意：一个要被记忆的函数必须是一个只<strong>接受一个对象</strong>作为参数的函数。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要为对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x</span>) =&gt; (&#123; <span class="attr">foo</span>: x.<span class="property">foo</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> memoizedFn = <span class="title function_">memoize</span>(fn);</span><br><span class="line"><span class="comment">//不支持</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unsupportedFn1</span> = (<span class="params"><span class="built_in">number</span></span>) =&gt; <span class="built_in">number</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unsupportedFn2</span> = (<span class="params">obj1, obj2</span>) =&gt; [obj1.<span class="property">foo</span>, obj2.<span class="property">foo</span>];</span><br></pre></td></tr></table></figure><p>再来说它是如何检查<strong>受影响</strong>的。<br>下面这个例子是一个实例不是解释哈，我们先理解表层，再来更深一层的理解如何实现：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">obj</span>) =&gt; obj.<span class="property">arr</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">num</span>);</span><br><span class="line"><span class="keyword">const</span> memoizedFn = <span class="title function_">memoize</span>(fn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = <span class="title function_">memoizedFn</span>(&#123;</span><br><span class="line">  <span class="attr">arr</span>: [</span><br><span class="line">    &#123; <span class="attr">num</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;hello&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">num</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;world&#x27;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 受影响的是 &quot;arr[0].num&quot;, &quot;arr[1].num&quot; and &quot;arr.length&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title function_">memoizedFn</span>(&#123;</span><br><span class="line">  <span class="attr">arr</span>: [</span><br><span class="line">    &#123; <span class="attr">num</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;hello&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">num</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;proxy&#x27;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">extraProp</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 受影响的对象num的值并没有改变，于是:</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result1 === result2 =&gt;&#x27;</span>,result1 === result2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>这个神奇的效果是如何实现的呢？</p><p>你可以通过<a href="https://github.com/dai-shi/proxy-memoize">proxy-memoize</a>了解到其中使用跟踪和影响的比较是通过内部库<a href="https://github.com/dai-shi/proxy-compare">proxy-compare</a>完成的。</p><p>简单介绍一下 <code>proxy-compare</code> ：<br>这是一个从 react-tracked 中提取的库，只提供与代理的比较特性。(实际上，react-tracked v2将使用这个库作为依赖项。)</p><p>该库导出了两个主要功能: createDeepProxy 和 isDeepChanged</p><p>工作原理：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> affected = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">createDeepProxy</span>(state, affected);</span><br><span class="line">proxy.<span class="property">a</span> <span class="comment">// touch a property</span></span><br><span class="line"><span class="title function_">isDeepChanged</span>(state, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">22</span> &#125;, affected) <span class="comment">// is false</span></span><br><span class="line"><span class="title function_">isDeepChanged</span>(state, &#123; <span class="attr">a</span>: <span class="number">11</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;, affected) <span class="comment">// is true</span></span><br></pre></td></tr></table></figure><p>状态可以是嵌套对象，只有当触及某个属性时，才会创建新的代理。当然如果你想深究createDeepProxy和isDeepChanged是如何实现的，你可以去看proxy-compare源码，我这里就不过多介绍了。</p><p>接下来介绍它配合React Context和React Redux这两个主要场景的使用，我这里放的是自己写的例子，当然你也可以看官网给出的例子都行。</p><h2 id="Usage-with-React-Context"><a href="#Usage-with-React-Context" class="headerlink" title="Usage with React Context"></a>Usage with React Context</h2><p>如果将<code>proxy-memoize</code> 与 <strong>useMemo</strong> 一起使用，我们将能够获得类似 <code>react-tracked</code> 的好处。</p><p>官方实例Sandbox：<a href="https://codesandbox.io/s/proxy-memoize-demo-vrnze"></a><a href="https://codesandbox.io/s/proxy-memoize-demo-vrnze">https://codesandbox.io/s/proxy-memoize-demo-vrnze</a></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">&#x27;proxy-memoize&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br><span class="line">  <span class="keyword">const</span> render = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">memoize</span>(<span class="function">(<span class="params">&#123; firstName, lastName &#125;</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      First Name: &#123;firstName&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;firstName&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(event)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          dispatch(&#123; type: &#x27;setFirstName&#x27;, firstName: event.target.value &#125;);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      (Last Name: &#123;lastName&#125;)</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )), [dispatch]);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">render</span>(state);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params">&#123; children &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;useReducer(reducer,</span> <span class="attr">initialState</span>)&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当上下文发生变化时，组件将<code>re-render</code>。怎样才不会每次re-render呢，在这个例子中我们可以发现除非 <code>firstName</code> 没有改变，否则它返回<code>memoized</code>的react 元素树，re-render 将不会发生。这种行为不同于react-tracked，但还是有优化的。</p><p>Usage with React Context 实际上使用可能没有那么广泛，但是如果你们项目中有使用了许多 ReactContext 确实是可以用这个来优化。</p><p>接下来要说的我觉得是最广泛的应用场景（当然我是说的大部分项目）</p><h2 id="Usage-with-React-Redux"><a href="#Usage-with-React-Redux" class="headerlink" title="Usage with React Redux"></a>Usage with React Redux</h2><p>Instead of <a href="https://github.com/reduxjs/reselect">reselect</a>.</p><p>他两都是解决这个问题的：可以创建可记忆的(Memoized)、可组合的 selector 函数、可以用来高效地计算 Redux store 里的衍生数据。</p><p>如果你没用过<code>proxy-memoize</code>，你大概率是使用的<code>reselect</code>来编写选择器 <code>selector</code> 函数 ，这里我们来对比两个库，我这里举一个简单的例子，但是往往state结构是没有这么简单的，这里只是个演示。</p><p>其实在对比中你就可以知道memoize如何使用以及他的优化好处了。</p><h2 id="为啥说代替reselect"><a href="#为啥说代替reselect" class="headerlink" title="为啥说代替reselect"></a>为啥说代替reselect</h2><p>相信看了下面的例子你能明白：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="title function_">memoize</span>(<span class="function">(<span class="params">x:State</span>) =&gt;</span> (&#123; <span class="attr">sum</span>: x.<span class="property">a</span> + x.<span class="property">b</span>, <span class="attr">diff</span>: x.<span class="property">a</span> - x.<span class="property">b</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="title function_">createSelector</span>(</span><br><span class="line">    [<span class="function">(<span class="params">state:State</span>)=&gt;</span>state],</span><br><span class="line">    <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            sum :state.<span class="property">a</span>+state.<span class="property">b</span>,</span><br><span class="line">            <span class="attr">diff</span>:state.<span class="property">a</span>-state.<span class="property">b</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn=&gt;&quot;</span>,(<span class="title function_">fn</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)))<span class="comment">//&#123;sum: 3, diff: -1&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn =&gt;&quot;</span>,(<span class="title function_">fn</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> ,<span class="attr">c</span>:<span class="number">3</span>&#125;) === <span class="title function_">fn</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> ,<span class="attr">c</span>:<span class="number">1</span>&#125;)))<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn1=&gt;&quot;</span>,(<span class="title function_">fn1</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) === <span class="title function_">fn1</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;)))<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>当然我发现如果扩展成这样也是可以的（偶然的发现，可能确实是因为这个<code>state</code>太简单了吧），但是写起来就更复杂(尤其是层级深需要的值多的时候，并且当需要的是数组中属性值时，这就实现不了)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">selectA</span> = (<span class="params">state:State</span>)=&gt;state.<span class="property">a</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">selectB</span> = (<span class="params">state:State</span>)=&gt;state.<span class="property">b</span></span><br><span class="line"><span class="keyword">const</span> selectSub = <span class="title function_">createSelector</span>(</span><br><span class="line">    selectA,</span><br><span class="line">    selectB,</span><br><span class="line">    <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            sum :a+b,</span><br><span class="line">            <span class="attr">diff</span>:a-b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn1=&gt;&quot;</span>,(<span class="title function_">fn1</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) === <span class="title function_">fn1</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;)))<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>那么久来个稍微复杂一点的例子吧</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">&#x27;proxy-memoize&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params">&#123; id &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line">  <span class="keyword">const</span> selector = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">memoize</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">firstName</span>: state.<span class="property">users</span>[id].<span class="property">firstName</span>,</span><br><span class="line">    <span class="attr">lastName</span>: state.<span class="property">users</span>[id].<span class="property">lastName</span>,</span><br><span class="line">  &#125;)), [id]);</span><br><span class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = <span class="title function_">useSelector</span>(selector);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      First Name: &#123;firstName&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;firstName&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(event)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          dispatch(&#123; type: &#x27;setFirstName&#x27;, firstName: event.target.value &#125;);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">      (Last Name: &#123;lastName&#125;)</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理我们也来对比一下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对比</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">memoize</span>(<span class="function">(<span class="params">state:State</span>) =&gt;</span> state.<span class="property">users</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> user.<span class="property">firstName</span>))</span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="title function_">createSelector</span>(</span><br><span class="line">[<span class="function">(<span class="params">state:State</span>)=&gt;</span>state.<span class="property">users</span>],</span><br><span class="line"><span class="function">(<span class="params">users</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> users.<span class="title function_">map</span>(<span class="function">(<span class="params">user</span>)=&gt;</span>user.<span class="property">firstName</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn =&gt;&quot;</span>,<span class="title function_">fn</span>(&#123;<span class="attr">count</span>:<span class="number">1</span> ,<span class="attr">text</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">users</span>: [&#123;<span class="attr">firstName</span>:<span class="string">&quot;hh&quot;</span>,<span class="attr">lastName</span>:<span class="string">&quot;ll&quot;</span>&#125;]&#125;) === <span class="title function_">fn</span>(&#123;<span class="attr">count</span>:<span class="number">1</span> ,<span class="attr">text</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">users</span>: [&#123;<span class="attr">firstName</span>:<span class="string">&quot;hh&quot;</span>,<span class="attr">lastName</span>:<span class="string">&quot;lllll&quot;</span>&#125;]&#125;))<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn1 =&gt;&quot;</span>,<span class="title function_">fn1</span>(&#123;<span class="attr">count</span>:<span class="number">1</span> ,<span class="attr">text</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">users</span>: [&#123;<span class="attr">firstName</span>:<span class="string">&quot;hh&quot;</span>,<span class="attr">lastName</span>:<span class="string">&quot;ll&quot;</span>&#125;]&#125;) === <span class="title function_">fn</span>(&#123;<span class="attr">count</span>:<span class="number">1</span> ,<span class="attr">text</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">users</span>: [&#123;<span class="attr">firstName</span>:<span class="string">&quot;hh&quot;</span>,<span class="attr">lastName</span>:<span class="string">&quot;ll&quot;</span>&#125;]&#125;))<span class="comment">//false</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>可以发现，我们要取的值是在一个数组里，并且我们只要数组里的firstName这个属性，按reselect来的话我们要先拿到数组再去遍历拿到里面的值，所以检测变化就是检测这个数组变化咯。这时你就能发现memoize的简洁和优化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">memoize</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">users</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> user.<span class="property">firstName</span>))</span><br></pre></td></tr></table></figure><p>它不会每次都创建，只有在用户长度更改或 firstName 中的一个更改时，才会重新计算这个值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个其实是我工作中调研的一个库，这个知识无偿分享给大家，也不知道大家喜不喜欢这种硬核一点的知识分享哈，那如果你觉得写的还不错的话，点个赞再走吧💖</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 技术调研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 技术调研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「项目 📝 」React实现导入导出Excel文件</title>
      <link href="/posts/10710/"/>
      <url>/posts/10710/</url>
      
        <content type="html"><![CDATA[<h1 id="🌼-表示层"><a href="#🌼-表示层" class="headerlink" title="🌼 表示层"></a>🌼 表示层</h1><p>这里我是使用的是antd的Upload上传组件</p><p>引用antd部分代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>,<span class="title class_">Table</span>,<span class="title class_">Upload</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Upload</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">fileList</span>=<span class="string">&#123;state.fileList&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> &gt;</span>Excel导入<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Upload</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleExport&#125;</span>&gt;</span>Excel导出<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="🌴-业务层"><a href="#🌴-业务层" class="headerlink" title="🌴  业务层"></a>🌴  业务层</h1><p>首先分析一下工作：</p><ul><li><strong>导入</strong>Excel工作：用户上传Excel表格，将表格内容转换为json对象方便后端处理，后端将数据存储数据库；</li><li><strong>导出</strong>Excel工作：获取后端json格式数据，前端将数据转换为sheet工作薄对象，生成的对象转换为Excel表格下载导出；</li></ul><p>下面就是技术层面的细节</p><h2 id="✨-核心插件xlsx"><a href="#✨-核心插件xlsx" class="headerlink" title="✨ 核心插件xlsx"></a>✨ 核心插件xlsx</h2><p>安装xlsx：<code>npm install xlsx --save-dev</code></p><p>主要介绍用到的核心api：</p><ul><li><input disabled="" type="checkbox"> <p>XLSX.read(data,type) // 解析Excel数据</p></li><li><input disabled="" type="checkbox"> <p>workbook.Sheets[workbook.SheetNames[0]] // 取到<strong>workbook</strong>对象中的第一个sheet表，<code>规定用户只有一个sheets</code>，不理解workbook的下面有解释</p></li><li><input disabled="" type="checkbox"> <p>XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], {header:1,defval:’’}）// 将工作簿对象转换为JSON对象数组，<code>注意defval不设置‘’则默认值为empty</code></p></li><li><input disabled="" type="checkbox"> <p>XLSX.utils.json_to_sheet(json) // 将json对象转换为工作簿对象</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workbook 理解：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">SheetNames</span>: [<span class="string">&#x27;sheet1&#x27;</span>, <span class="string">&#x27;sheet2&#x27;</span>],</span><br><span class="line">    <span class="title class_">Sheets</span>: &#123;</span><br><span class="line">        <span class="comment">// worksheet</span></span><br><span class="line">        <span class="string">&#x27;sheet1&#x27;</span>: &#123;</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            <span class="string">&#x27;A1&#x27;</span>: &#123; ... &#125;,</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            <span class="string">&#x27;A2&#x27;</span>: &#123; ... &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// worksheet</span></span><br><span class="line">        <span class="string">&#x27;sheet2&#x27;</span>: &#123;</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            <span class="string">&#x27;A1&#x27;</span>: &#123; ... &#125;,</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            <span class="string">&#x27;A2&#x27;</span>: &#123; ... &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍒-excel-导入"><a href="#🍒-excel-导入" class="headerlink" title="🍒 excel 导入"></a>🍒 excel 导入</h2><p>核心代码 ：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = file;</span><br><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> datas = e.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">        <span class="keyword">const</span> workbook = <span class="variable constant_">XLSX</span>.<span class="title function_">read</span>(datas, &#123;<span class="attr">type</span>: <span class="string">&quot;binary&quot;</span>,&#125;); <span class="comment">//解析datas</span></span><br><span class="line">        <span class="keyword">const</span> first_worksheet = workbook.<span class="property">Sheets</span>[workbook.<span class="property">SheetNames</span>[<span class="number">0</span>]]; <span class="comment">//是工作簿中的工作表的第一个sheet</span></span><br><span class="line">        <span class="keyword">const</span> jsonArr = <span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">sheet_to_json</span>(first_worksheet, &#123;<span class="attr">header</span>: <span class="number">1</span>,<span class="attr">defval</span>:<span class="string">&#x27;&#x27;</span>&#125;); <span class="comment">//将工作簿对象转换为JSON对象数组</span></span><br><span class="line">        <span class="title function_">handleImpotedJson</span>(jsonArr)<span class="comment">// 数组处理</span></span><br><span class="line">        message.<span class="title function_">success</span>(<span class="string">&#x27;Excel上传解析成功！&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;文件类型不正确！或文件解析错误&#x27;</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">reader.<span class="title function_">readAsBinaryString</span>(f);</span><br></pre></td></tr></table></figure><p>理解：</p><ol><li>FileReader对象实例化<code>file</code>对象在<code>onload</code>事件里进行处理</li><li>XLSX.read 解析<code>data</code></li><li>XLSX.utils.sheet_to_json(first_worksheet, {header: 1,defval:’’}) 将解析出的工作簿对象转化为<code>JSON</code>对象</li></ol><h2 id="🍇-excel-导出"><a href="#🍇-excel-导出" class="headerlink" title="🍇 excel 导出"></a>🍇 excel 导出</h2><p>核心代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">downloadExcel</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> json = <span class="title function_">handleExportedJson</span>(data)</span><br><span class="line">    <span class="keyword">const</span> sheet = <span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">json_to_sheet</span>(json);</span><br><span class="line">    <span class="title function_">openDownloadDialog</span>(<span class="title function_">sheet2blob</span>(sheet,<span class="string">&quot;Sheet1&quot;</span>), <span class="string">&quot;下载文件.xls&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleExportedJson</span> = (<span class="params">array</span>) =&gt;&#123;...&#125;  <span class="comment">// 处理Json数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">openDownloadDialog</span> = (<span class="params">url, saveName</span>) =&gt;&#123;...&#125; <span class="comment">// 打开下载</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sheet2blob</span> = (<span class="params">sheet, sheetName</span>) =&gt;&#123;...&#125; <span class="comment">// 转成blob类型</span></span><br></pre></td></tr></table></figure><p>理解：</p><ol><li>得到处理后的<code>json</code>格式数据</li><li>XLSX.utils.json_to_sheet(json) 转换成<code>sheet</code>工作簿对象</li><li>sheet2blob(sheet,saveName) 将工作簿对象转换成 <code>blob</code></li><li>openDownloadDialog 创建blob地址通过<code>&lt;a&gt;</code>标签实现下载动作</li></ol><h2 id="🍑-excel-导出插件（js-export-excel）"><a href="#🍑-excel-导出插件（js-export-excel）" class="headerlink" title="🍑 excel 导出插件（js-export-excel）"></a>🍑 excel 导出插件（js-export-excel）</h2><p>之前为啥没放自实现的代码，那不是因为发现有好用的插件嘛，代码很简单。</p><p>核心代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接导出文件</span></span><br><span class="line"><span class="keyword">let</span> dataTable = [];  <span class="comment">//excel文件中的数据内容</span></span><br><span class="line"><span class="keyword">let</span> option = &#123;&#125;;  <span class="comment">//option代表的就是excel文件</span></span><br><span class="line">dataTable  = data;  <span class="comment">//数据源</span></span><br><span class="line">option.<span class="property">fileName</span> = <span class="string">&quot;下载文件&quot;</span>;  <span class="comment">//excel文件名称</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data===&quot;</span>,dataTable)</span><br><span class="line">option.<span class="property">datas</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">sheetData</span>: dataTable,  <span class="comment">//excel文件中的数据源</span></span><br><span class="line">        <span class="attr">sheetName</span>: <span class="string">&#x27;Sheet1&#x27;</span>,  <span class="comment">//excel文件中sheet页名称</span></span><br><span class="line">        <span class="attr">sheetFilter</span>: [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;belong&#x27;</span>, <span class="string">&#x27;step&#x27;</span>,<span class="string">&#x27;tag&#x27;</span>],  <span class="comment">//excel文件中需显示的列数据</span></span><br><span class="line">        <span class="attr">sheetHeader</span>: [<span class="string">&#x27;项目id&#x27;</span>, <span class="string">&#x27;项目名称&#x27;</span>, <span class="string">&#x27;所属公司&#x27;</span>, <span class="string">&#x27;项目阶段&#x27;</span>,<span class="string">&#x27;项目标签&#x27;</span>],  <span class="comment">//excel文件中每列的表头名称</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> toExcel = <span class="keyword">new</span> <span class="title class_">ExportJsonExcel</span>(option);  <span class="comment">//生成excel文件</span></span><br><span class="line">toExcel.<span class="title function_">saveExcel</span>();  <span class="comment">//下载excel文件</span></span><br></pre></td></tr></table></figure><p>上为这个插件的基本用法，还支持导出Blob，支持压缩等，详细见<a href="https://www.npmjs.com/package/js-export-excel">官网</a></p><p>解释核心 <strong>option</strong>:</p><ul><li><p>fileName 下载文件名(默认：<code>download</code>)</p></li><li><p>datas 数据:</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*多个sheet*/</span></span><br><span class="line"><span class="comment">/*每个sheet为一个object */</span></span><br><span class="line">[&#123;</span><br><span class="line">    <span class="attr">sheetData</span>:[], <span class="comment">// 数据</span></span><br><span class="line">    <span class="attr">sheetName</span>:<span class="string">&#x27;&#x27;</span>, <span class="comment">// （非必需）sheet名字，默认为sheet1</span></span><br><span class="line">    <span class="attr">sheetFilter</span>:[], <span class="comment">//（非必需）列过滤(只有在 data 为 object 下起作用)</span></span><br><span class="line">    <span class="attr">sheetHeader</span>:[] <span class="comment">// 第一行，标题</span></span><br><span class="line">    <span class="attr">columnWidths</span>: [] <span class="comment">//（非必需）列宽，需与列顺序对应</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>浏览器支持：ie 10+ 我测试下来demo在chrom、Safari、IE下都是能用的。</p><h1 id="🌸-实现效果"><a href="#🌸-实现效果" class="headerlink" title="🌸  实现效果"></a>🌸  实现效果</h1><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb0ec5dba4e4c6c8ee83e3617e83669~tplv-k3u1fbpfcp-watermark.image" alt="2021-07-09 12.23.55 1 1.gif"></p><p>还有不懂得可以看 <a href="https://github.com/HearLing/react-excel-demo/tree/master/demo">GitHub demo源码</a> </p><h1 id="🍀-结语"><a href="#🍀-结语" class="headerlink" title="🍀 结语"></a>🍀 结语</h1><p>这是一个简单的业务实现，仔细的总结了一下。💗 感谢你看到这～💗 ，如果觉得不错麻烦点个赞 👍 </p><p>刚忙完毕业的事儿，事情没有那么多了，又可以慢慢发文了，预告下一篇吧，关于我的「毕业设计」，给大家看个效果图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01bf489d1bfa4efe8eeaea5ab9e4d33d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>我感觉这个可以到时候改成🌟博客啥的，毕竟开发了挺久的，想着有点用嘛 😂</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Redux」概念理解+实战上手（内含大量实例）</title>
      <link href="/posts/10408/"/>
      <url>/posts/10408/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章零基础也可以看，我尽量写得简单易懂了，如果觉得理解起来有点费力，也可以先去官网入门。</p><p>这篇文章也附上了许多实战代码，但是由于篇幅原因，一些实战例子我没有直接摆出来，而是放在了sandBox链接里，除了慢优点还是很多的。</p><h1 id="一、Redux因何产生？"><a href="#一、Redux因何产生？" class="headerlink" title="一、Redux因何产生？"></a>一、Redux因何产生？</h1><p>首先说它为什么出现</p><p>1.趋势所致： JavaScript 单页应用开发日趋复杂，<strong>JavaScript 需要管理比任何时候都要多的 state （状态）。</strong></p><p>2.管理不断变化的 state 非常困难：如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。<strong>state 在什么时候，由于什么原因，如何变化已然不受控制。</strong></p><h1 id="二、Redux是干什么的？"><a href="#二、Redux是干什么的？" class="headerlink" title="二、Redux是干什么的？"></a>二、Redux是干什么的？</h1><p>说到底它也只是个工具，了解一个工具最开始当然是要了解它是做啥的咯。</p><p>官网对它的定义：Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 </p><p>详细一些：</p><ul><li>Redux会将整个应用状态(其实也就是数据)存储到<code>Store</code></li><li>Store里面保存一棵状态树(<code>state tree</code>)</li><li>组件改变state的唯一方法是通过调用store的<code>dispatch</code>方法，触发一个<code>action</code>，这个action被对应的<code>reducer</code>处理，于是state完成更新</li><li>组件可以派发(dispatch)行为(action)给store,而不是直接通知其它组件</li><li>其它组件可以通过订阅store中的状态(state)来刷新自己的视图</li></ul><p>可以结合这张图看：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8a60bf1474147c6be57ef4f8f47992d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h1 id="三、Redux怎么用？"><a href="#三、Redux怎么用？" class="headerlink" title="三、Redux怎么用？"></a>三、Redux怎么用？</h1><h2 id="官网实例（todo）"><a href="#官网实例（todo）" class="headerlink" title="官网实例（todo）"></a>官网实例（todo）</h2><p><strong>State:</strong> 用了一个普通对象描述应用中的State，没有setter（修改器方法）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">todos</span>: [&#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;Eat food&#x27;</span>,</span><br><span class="line">    <span class="attr">completed</span>: <span class="literal">true</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;Exercise&#x27;</span>,</span><br><span class="line">    <span class="attr">completed</span>: <span class="literal">false</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">visibilityFilter</span>: <span class="string">&#x27;SHOW_COMPLETED&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Action：</strong> 想更新state中的数据，例如增加todo，需要发起一个action。Action就是一个普通的JavaScript对象,描述发生了什么的指示器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;Go to swimming pool&#x27;</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;TOGGLE_TODO&#x27;</span>, <span class="attr">index</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>, <span class="attr">filter</span>: <span class="string">&#x27;SHOW_ALL&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>强制使用 action 来描述所有变化带来的好处是可以清晰地知道应用中到底发生了什么。如果一些东西改变了，就可以知道为什么变。</p></blockquote><p><strong>Reducer:</strong> 把 action 和 state 串起来，reducer 只是一个接收 state 和 action，并返回新的 state 的函数。 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写很多小函数来分别管理 state 的一部分</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">visibilityFilter</span>(<span class="params">state = <span class="string">&#x27;SHOW_ALL&#x27;</span>, action</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.<span class="property">filter</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todos</span>(<span class="params">state = [], action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> state.<span class="title function_">concat</span>([&#123; <span class="attr">text</span>: action.<span class="property">text</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;]);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;TOGGLE_TODO&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> state.<span class="title function_">map</span>(<span class="function">(<span class="params">todo, index</span>) =&gt;</span></span><br><span class="line">      action.<span class="property">index</span> === index ?</span><br><span class="line">        &#123; <span class="attr">text</span>: todo.<span class="property">text</span>, <span class="attr">completed</span>: !todo.<span class="property">completed</span> &#125; :</span><br><span class="line">        todo</span><br><span class="line">   )</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reducer 调用上两个 reducer，进而管理整个应用的 state</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">todos</span>: <span class="title function_">todos</span>(state.<span class="property">todos</span>, action),</span><br><span class="line">    <span class="attr">visibilityFilter</span>: <span class="title function_">visibilityFilter</span>(state.<span class="property">visibilityFilter</span>, action)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写实战（TodoList）"><a href="#手写实战（TodoList）" class="headerlink" title="手写实战（TodoList）"></a>手写实战（TodoList）</h2><p>感兴趣的可以看一下<a href="https://codesandbox.io/s/wonderful-williams-8mir6?fontsize=14&hidenavigation=1&theme=dark">codesandbox-TodoList例子</a>可能会比较慢。</p><p>没有用过sandbox的，我展示一下大概长这样：<br><img src= "/img/loading.gif" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b679c4c3198420cb3951d1294d20976~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>个人觉得这样比较直观一些，所以后面有的还是贴的链接～<br>todo这种例子还是比较简单的，相当于入门，理解Redux工作。</p><h1 id="四、react-redux"><a href="#四、react-redux" class="headerlink" title="四、react-redux"></a>四、react-redux</h1><p>可以看到上面我们并没有使用到react-redux，虽然能实现功能，但细心会发现我是直接拿的store，组件多的话个个拿store，这样不好。我来总结一下不用react-redux可能会遇到头痛的问题比如：</p><p>1.store并不是那么显而易见，一旦组件层级变得更复杂，这个store就会变得很难控制。</p><p>2.逻辑组件看上去很乱，不清晰的原因state和dispatch没有各自写在一起，重复代码有点多，不直观。</p><p>3.React 组件从 Redux store 中读取数据，向 store 中分发 actions 更新数据还不够方便。</p><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>这个还是很好理解的，<del>就是把store直接集成到React应用的顶层props里面</del><code>Provider是把store注入到context，connect才是吧context转换成props</code>，好处是，所有组件都可以在react-redux的控制之下，所有组件都能访问到Redux中的数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> store=&#123;store&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"> &lt;/<span class="title class_">Provider</span>&gt;,</span><br></pre></td></tr></table></figure><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><ul><li>技术上讲，容器组件就是使用store.subscribe()  从 Redux state 树中读取部分数据，并通过 props 来把这些数据提供给要渲染的组件。</li><li>为啥要用它，简单来说节省工作，没有他得手工开发容器组件，并为了性能而手动实现 React 性能优化建议中的 shouldComponentUpdate 方法。</li><li>使用 React Redux 库的 connect() 方法来生成，这个方法做了性能优化来避免很多不必要的重复渲染。</li></ul><h3 id="connect的使用"><a href="#connect的使用" class="headerlink" title="connect的使用"></a>connect的使用</h3><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">Counter</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h3><p>理解这个单词mapStateToProps：把state映射到props中去，state就是redux的state啦，props就是react的props咯。</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map Redux state to component props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapStateToProps</span>(<span class="params">state</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">value</span>: state.<span class="property">count</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在组件中使用this.props.value就能完成渲染</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onIncreaseClick &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onIncreaseClick&#125;</span>&gt;</span>Increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h3><p>理解这个单词mapDispatchToProps：map 各种dispatch 变成props。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map Redux actions to component props</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">mapDispatchToProps</span>(<span class="params">dispatch</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="attr">onIncreaseClick</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(increaseAction)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onIncreaseClick &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onIncreaseClick&#125;</span>&gt;</span>Increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>同理也是可以通过this.props.onIncreaseClick调用dispatch，这样就不需要在代码中运行dispatch了。</p><h2 id="connect、provider应用实例"><a href="#connect、provider应用实例" class="headerlink" title="connect、provider应用实例"></a>connect、provider应用实例</h2><p>看了上面的介绍，应该能比较清楚的了解connect是干什么的了，然后也基本能明白怎么做了，但还是没有写哥实例更清楚直白的了：</p><p><a href="https://codesandbox.io/s/increase-count-33fjs">简单的点击增加count的实例</a>，应该还有许多需要优化的地方，这里就学明白connect和provider就好了。</p><p><a href="https://codesandbox.io/s/magical-chatelet-p26wj?file=/src/TodoList.js">复杂一点的todolist的实例</a>这里用了hooks、connect、provider没有用react-redux里的hooks钩子（如果有看不懂的话可以学学hooks或者等我有时间再出一个class改写成hooks的文章，还是很简单的，只要你专心学）</p><h1 id="五、Hooks下的redux"><a href="#五、Hooks下的redux" class="headerlink" title="五、Hooks下的redux"></a>五、Hooks下的redux</h1><p>如果项目开发是用的hooks，那很好，你又省了许多力气，比如计数器这个这种<strong>简单</strong>的状态管理例子，几行代码解决。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们能完全不用redux状态管理了嘛？哈哈哈怎么可能呢</p><ul><li>对于已经使用redux的：首先在redux没有给出对hooks较好支持之前，大多不会为了hooks来完全重构项目吧，顺便一讲重构可能造成的问题：<ul><li>失去很多connect()提供的自动引用缓存，可能导致性能问题，除非用大量的useCallback()来包裹</li><li>如果代码依赖于mapStateToProps中的ownProps，那么你可能会使用redux hooks编写更多代码，而不能直接拿到这个属性。</li><li>不能像以前那样在mapDispatchToProps中，为action creator提供依赖注入</li></ul></li><li>对于有可能是复杂应用的：许多公司的项目大部分都是用的redux管理状态，他的许多优点比如单一数据源、数据共享、事务状态、数据状态I/O和副作用隔离、状态回溯以及一系列辅助工具带来的强大调试能力等等，使得用redux来管理数据流成为更好的选择。</li><li>react-redux发布了新的版本，与之前的contextAPI分离，提供对hooks的支持，那这不就更香了</li></ul><h2 id="新的redux带来的改变"><a href="#新的redux带来的改变" class="headerlink" title="新的redux带来的改变"></a>新的redux带来的改变</h2><ol><li><strong>不再需要使用</strong>  <code>mapStateToProps</code>，<code>mapDispatchToProps</code>和<code>connect</code>来维护单独的container组件和UI组件，而是在组件中直接使用redux提供的hooks,读取redux中的state。</li><li>可以将任何现有的自定义<strong>hooks与redux集成</strong>，而不是将通过hooks创建的state，作为参数传递给其他hooks。</li></ol><h2 id="redux对hooks的支持"><a href="#redux对hooks的支持" class="headerlink" title="redux对hooks的支持"></a>redux对hooks的支持</h2><p>首先介绍几个核心：</p><ul><li><strong>useSelector：</strong> 用于从Redux存储的state中提取值并订阅该state。</li><li><strong>useDispatch：</strong> 除了读取store中的state，还能dispatch actions更新store中的state。</li><li><strong>useStore：</strong> 用于获取创建的store实例。</li></ul><p>光看简介还不是很清楚，一个个来说：</p><h3 id="useSelector"><a href="#useSelector" class="headerlink" title="useSelector"></a>useSelector</h3><p>看它的介绍，就很像mapStateToProps，但是</p><ul><li>不提供ownProps API，最好用useCallback或useMemo来获取</li><li>和useEffect一样，如果不提供第二个参数，每次组件更新就会重新计算</li></ul><p>那可能会存在一些担忧，会不会新的没有之前用的mapStateToProps好用呢？那来看看他的一些好处吧：</p><ul><li>当然是配合hooks写代码更<strong>简洁</strong></li><li>性能上延续redux以前的性能优化逻辑，<strong>比较props</strong>，如果当前的props跟老的props相同，则组件将不会重新渲染。</li><li>批处理更新，使得多个useSelector()重新计算出state，组件只会重新渲染一次，<strong>不用担心useSelector重复渲染问题</strong>。</li></ul><p>首先看看以前是怎么写的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// React component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onIncreaseClick &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onIncreaseClick&#125;</span>&gt;</span>Increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connected Component</span></span><br><span class="line"><span class="comment">// Map Redux state to component props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapStateToProps</span>(<span class="params">state</span>) &#123;<span class="keyword">return</span> &#123;<span class="attr">value</span>: state.<span class="property">count</span>&#125;&#125;</span><br><span class="line"><span class="comment">// Map Redux actions to component props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapDispatchToProps</span>(<span class="params">dispatch</span>) &#123;<span class="keyword">return</span> &#123;<span class="attr">onIncreaseClick</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(increaseAction)&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connected Component</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="title function_">connect</span>(mapStateToProps,mapDispatchToProps)(<span class="title class_">Counter</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure><p>然后让我们用新的useSelect改写之前写得计数器：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//after</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = props=&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count &#125; = <span class="title function_">useSelector</span>(</span><br><span class="line">    <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">count</span>: state.<span class="property">count</span></span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><h3 id="useDispatch"><a href="#useDispatch" class="headerlink" title="useDispatch"></a>useDispatch</h3><p>之前是使用mapDispatchToProps：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="comment">// Map Redux actions to component props</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mapDispatchToProps</span>(<span class="params">dispatch</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">onIncreaseClick</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(increaseAction)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>现在使用useDispatch，可以直接在组件中使用，以匿名函数形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//after</span></span><br><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>dispatch(increaseAction)&#125;&gt;Increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>由于匿名函数的性质，每次重新渲染获得新的引用，如果作为props传递给子组件，那么子组件每次都要重新渲染。</p><p>优化的意见是在useCallback中创建这个匿名函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//after</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useCallback &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> increaseAction <span class="keyword">from</span> <span class="string">&quot;./store/action&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = props=&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count &#125; = <span class="title function_">useSelector</span>(</span><br><span class="line">    <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">count</span>: state.<span class="property">count</span></span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line">  <span class="keyword">const</span> onIncreaseClick = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(increaseAction),[dispatch]</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onIncreaseClick&#125;</span>&gt;</span>Increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><h3 id="useStore"><a href="#useStore" class="headerlink" title="useStore"></a>useStore</h3><p>在任何需要访问store的应用中，都可以通过usestore来获取。如果出于某种原因，比如说单元测试时，想要获取不同的store，我们可以将store通过新的contextAPI传递进组件树中，就像下面这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">OtherProvider</span> <span class="keyword">from</span> <span class="string">&#x27;./OtherProvider&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="title function_">useStore</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">OtherProvider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">OtherProvider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>接着上面已经改成hooks的todolist但是还是用的connect的实例，来重新用react-redux的useSelector和useDispatch实现。</p><p>基本思想前面介绍的差不多来，这里我就不败代码，为了更直观还是用sandbox虽然不是很快：</p><p><a href="https://codesandbox.io/s/todolistredux-for-hook-671ex?file=/src/store/reducer.js">SandBox —— useSelector、useDispatch实战TodoList</a></p><h2 id="Hooks下的redux总结"><a href="#Hooks下的redux总结" class="headerlink" title="Hooks下的redux总结"></a>Hooks下的redux总结</h2><p>为什么还是要用redux？<br>简单来说：Redux 提供了应对大型应用的代码组织和调试能力，在程序出错时， 能帮你快速定位问题。</p><p>对于一些场景的需求hooks没法解决：</p><ul><li>需要保存或者加载状态</li><li>跨组件共享状态</li><li>需要与其他组件共享业务逻辑或数据处理过程</li></ul><p>配合hooks新的redux带来的不一样的改变：通过使用useSelector、useDispatch和useStore搭配这hooks写确实也是个不错的尝试。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>作为一个之前vue技术栈转react技术栈的菜鸟来说，还是踩了一些的坑的：<br>比如在有了vuex的基础之后，然后有没有理解清楚理解redux，很容易觉得他两差不多，但实际还是有挺多区别的，也是我深入学习redux的一个导火索。</p><p>简单的说一下：<br>在 Vuex 中，$store 被直接注入到了组件实例中，因此可以比较灵活的使用：</p><ul><li><p>使用 dispatch 和 commit 提交更新</p></li><li><p>通过 mapState 或者直接通过 this.$store 来读取数据</p></li><li><p>组件中既可以 dispatch action 也可以 commit updates</p></li></ul><p>在 Redux 中：</p><ul><li>我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。</li><li>Redux 中只能进行 dispatch，并不能直接调用 reducer 进行修改。<br>从实现原理上来说，最大的区别是两点：</li></ul><p>Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改。</p><p>Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的。</p><h1 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h1><p>🚀🚀 后续可能大概率还会更新这篇文章，还有些没写到，希望这篇文章对于你学习redux有所帮助哦～</p><p>⭐️⭐️ 如果觉得不错的话，点个赞再走吧 ❤️ ❤️ ～～</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Redux </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐮化身面试官出30+Vue面试题，超级干货（附答案）</title>
      <link href="/posts/31403/"/>
      <url>/posts/31403/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前一直没有总结Vue相关的知识，看了挺多别人总结的，其实也能快速知道一些，但是遇到真正的面试，发现自己的知识都还只是碎片化的，觉得不行，得总结一下了。</p></blockquote><p>不知道大伙是不是已经在准备春招面试了呢，准备得咋样了呢，面试的Vue复习得怎么样了呢？</p><p>如果你感觉在vue这方面还比较薄弱的话，不如来做一做这套模拟面试吧，看看大伙能不能打个满分，祝你顺利，🌸答案仅供参考🌸</p><p>欢迎访问<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes/issues">GitHub仓库</a>，目前已经有<code>552</code> 道大厂真题了，涵盖各类前端的真题</p><p>—— 进入正题化身为面试官 ——</p><p>📞📞电话拨通中，咳咳喂，听得到吗，听得到是吧😊，那面试开始了，你先做个自我介绍吧<br>。。。<br>在你自我介绍的时候呢，我就看看你做过的项目，技术栈什么的。</p><p>第一个问题，先摸个底：</p><h2 id="了解过（用过）react或者angular吗，他们有什么区别？"><a href="#了解过（用过）react或者angular吗，他们有什么区别？" class="headerlink" title="了解过（用过）react或者angular吗，他们有什么区别？"></a>了解过（用过）react或者angular吗，他们有什么区别？</h2><details><summary><b>答案</b></summary><p><code>Vue</code> 借鉴了<code>angular</code>  的模板和数据绑定技术，又借鉴了<code>react</code> 的组件化和虚拟<code>DOM</code> 技术。</p></details><p>😶对<code>Vue</code> 比较熟一些是吧~（这里只说<code>Vue</code> 假设你就只熟练<code>Vue</code> ）</p><h2 id="那首先谈谈你对Vue的理解吧？"><a href="#那首先谈谈你对Vue的理解吧？" class="headerlink" title="那首先谈谈你对Vue的理解吧？"></a>那首先谈谈你对Vue的理解吧？</h2><details><summary><b>答案</b></summary><p><p><strong>官网介绍：</strong>  <a href="https://cn.vuejs.org/index.html">https://cn.vuejs.org/index.html</a></p><p><strong>关键点：</strong> 渐进式<code>JavaScript</code> 框架、核心库加插件、动态创建用户界面（异步获取后台数据，数据展示在界面）</p><p><strong>特点：</strong>  <code>MVVM</code> 模式；代码简洁体积小，运行效率高，适合移动PC端开发；本身只关注<code>UI</code> （和<code>react</code> 相似），可以轻松引入 <code>Vue</code> 插件或其他的第三方库进行开发。</p></p></details><p>🌸思考一下自己所说的那些点，自己都非常清楚明白吗？</p><p>下面呢我就根据你对<code>vue</code> 的理解，接着谈谈：</p><h2 id="你刚刚说到了MVVM，能详细说说吗？"><a href="#你刚刚说到了MVVM，能详细说说吗？" class="headerlink" title="你刚刚说到了MVVM，能详细说说吗？"></a>你刚刚说到了MVVM，能详细说说吗？</h2><details><summary><b>答案</b></summary><p><p>全称：<code>Model-View-ViewModel</code> ，<code>Model</code> 表示数据模型层。<code>view</code> 表示视图层，<code>ViewModel</code> 是<code>View</code> 和<code>Model</code> 层的桥梁，数据绑定到<code>viewModel</code> 层并自动渲染到页面中，视图变化通知<code>viewModel</code> 层更新数据。</p></p></details><p>😶摸底差不多，问基础了，响应式数据得知道吧，问一问</p><h2 id="vue是如何实现响应式数据的呢？（响应式数据原理）❗"><a href="#vue是如何实现响应式数据的呢？（响应式数据原理）❗" class="headerlink" title="vue是如何实现响应式数据的呢？（响应式数据原理）❗"></a>vue是如何实现响应式数据的呢？（响应式数据原理）❗</h2><details><summary><b>答案</b></summary><p><p>Vue2：<code>Object.defineProperty</code> 重新定义<code>data</code> 中所有的属性，<code>Object.defineProperty</code> 可以使数据的获取与设置增加一个拦截的功能，拦截属性的获取，进行依赖收集。拦截属性的更新操作，进行通知。</p><p>具体的过程：首先Vue使用 <code>initData</code> 初始化用户传入的参数，然后使用 <code>new Observer</code> 对数据进行观测，如果数据是一个对象类型就会调用<code>this.walk（value）</code> 对对象进行处理，内部使用 <code>defineeReactive</code>  循环对象属性定义响应式变化，核心就是使用<code>Object.defineProperty</code> 重新定义数据。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a5a919f243644a3a0fbeaa884d2f9cd~tplv-k3u1fbpfcp-watermark.image" alt=""></p></details><p>🌸刚刚如果你说了对象的检测，然后又没说清楚数组的处理的话，我就会问下面这个问题</p><h2 id="那vue中是如何检测数组变化的呢？"><a href="#那vue中是如何检测数组变化的呢？" class="headerlink" title="那vue中是如何检测数组变化的呢？"></a>那vue中是如何检测数组变化的呢？</h2><details><summary><b>答案</b></summary><p><p>数组就是使用<code>object.defineProperty</code> 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的，<code>pop</code> 、<code>push</code> 、<code>shift</code> 、<code>unshift</code> 、<code>splice</code> 、<code>sort</code> 、<code>reverse</code> 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解。</p><ol><li><p>是用来函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新。</p></li><li><p>数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测）</p></li></ol><p>vue3：改用<code>proxy</code> ，可直接监听对象数组的变化。</p></p></details><h2 id="那你说说Vue的事件绑定原理吧"><a href="#那你说说Vue的事件绑定原理吧" class="headerlink" title="那你说说Vue的事件绑定原理吧"></a>那你说说Vue的事件绑定原理吧</h2><details><summary><b>答案</b></summary><p><ul><li><p>原生<code>DOM</code> 的绑定：Vue在创建真实DOM时会调用<code>createElm</code> ，默认会调用<code>invokeCreateHooks</code> 。会遍历当前平台下相对的属性处理代码，其中就有<code>updateDOMListeners</code> 方法，内部会传入<code>add（）</code> 方法</p></li><li><p>组件绑定事件，原生事件，自定义事件；组件绑定之间是通过Vue中自定义的<code>$on</code> 方法实现的。<br>（可以理解为：组件的<code>nativeOnOn</code>  等价于 普通元素on 组件的on会单独处理）</p></p></details></li></ul><h2 id="v-model中的实现原理及如何自定义v-model-❗"><a href="#v-model中的实现原理及如何自定义v-model-❗" class="headerlink" title="v-model中的实现原理及如何自定义v-model ❗"></a>v-model中的实现原理及如何自定义v-model ❗</h2><details><summary><b>答案</b></summary><p><p><code>v-model</code> 可以看成是<code>value+input</code> 方法的语法糖（组件）。原生的<code>v-model</code> ，会根据标签的不同生成不同的事件与属性。解析一个指令来。</p><p>自定义：自己写<code>model</code> 属性，里面放上<code>prop</code> 和<code>event</code> </p></p></details><p>👍还行哟~知道响应式数据和数据绑定问完了，接着问问渲染呗：</p><h2 id="为什么Vue采用异步渲染呢？"><a href="#为什么Vue采用异步渲染呢？" class="headerlink" title="为什么Vue采用异步渲染呢？"></a>为什么Vue采用异步渲染呢？</h2><details><summary><b>答案</b></summary><p><p><code>Vue</code> 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能，<code>Vue</code> 会在本轮数据更新后，在异步更新视图。核心思想<code>nextTick</code> 。</p><p><code>dep.notify（）</code> 通知 watcher进行更新，<code>subs[i].update</code> 依次调用 watcher 的<code>update</code> ，<code>queueWatcher</code> 将watcher 去重放入队列， nextTick（<code>flushSchedulerQueue</code> ）在下一tick中刷新watcher队列（异步）。</p></p></details><p>🌸接着追问，要是你nextTick都能讲得很清楚的话那基本你是明白了。</p><h2 id="了解nextTick吗？"><a href="#了解nextTick吗？" class="headerlink" title="了解nextTick吗？"></a>了解nextTick吗？</h2><details><summary><b>答案</b></summary><p><p>异步方法，异步渲染最后一步，与JS事件循环联系紧密。主要使用了宏任务微任务（<code>setTimeout</code>、<code>promise</code>那些），定义了一个异步方法，多次调用<code>nextTick</code>会将方法存入队列，通过异步方法清空当前队列。</p></p></details><p>可以的可以的，先问你个生命周期，我再想想怎么难住你😄</p><h2 id="说说Vue的生命周期吧-❗"><a href="#说说Vue的生命周期吧-❗" class="headerlink" title="说说Vue的生命周期吧 ❗"></a>说说Vue的生命周期吧 ❗</h2><details><summary><b>答案</b></summary><p><p><strong>什么时候被调用？</strong></p><ul><li>beforeCreate ：实例初始化之后，数据观测之前调用</li><li>created：实例创建万之后调用。实例完成：数据观测、属性和方法的运算、<code>watch/event</code> 事件回调。无<code>$el</code> .</li><li>beforeMount：在挂载之前调用，相关<code>render</code> 函数首次被调用</li><li>mounted：了被新创建的<code>vm.$el</code>替换，并挂载到实例上去之后调用改钩子。</li><li>beforeUpdate：数据更新前调用，发生在虚拟DOM重新渲染和打补丁，在这之后会调用改钩子。</li><li>updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用改钩子。</li><li>beforeDestroy：实例销毁前调用，实例仍然可用。</li><li>destroyed：实例销毁之后调用，调用后，Vue实例指示的所有东西都会解绑，所有事件监听器和所有子实例都会被移除</li></ul><p><strong>每个生命周期内部可以做什么？</strong></p><ul><li>created：实例已经创建完成，因为他是最早触发的，所以可以进行一些数据、资源的请求。</li><li>mounted：实例已经挂载完成，可以进行一些DOM操作。</li><li>beforeUpdate：可以在这个钩子中进一步的更改状态，不会触发重渲染。</li><li>updated：可以执行依赖于DOM的操作，但是要避免更改状态，可能会导致更新无线循环。</li><li>destroyed：可以执行一些优化操作，清空计时器，解除绑定事件。</li></ul><p><strong>ajax放在哪个生命周期？</strong>：一般放在<code>mounted</code> 中，保证逻辑统一性，因为生命周期是同步执行的，<code>ajax</code> 是异步执行的。单数服务端渲染<code>ssr</code> 同一放在<code>created</code> 中，因为服务端渲染不支持<code>mounted</code> 方法。<br><strong>什么时候使用beforeDestroy？</strong>：当前页面使用<code>$on</code> ，需要解绑事件。清楚定时器。解除事件绑定，<code>scroll mousemove</code> 。</p></p></details><h2 id="父子组件生命周期调用顺序（简单）"><a href="#父子组件生命周期调用顺序（简单）" class="headerlink" title="父子组件生命周期调用顺序（简单）"></a>父子组件生命周期调用顺序（简单）</h2><details><summary><b>答案</b></summary><p><p>渲染顺序：先父后子，完成顺序：先子后父</p><p>更新顺序：父更新导致子更新，子更新完成后父</p><p>销毁顺序：先父后子，完成顺序：先子后父</p></p></details><h2 id="Vue组件通信-❗"><a href="#Vue组件通信-❗" class="headerlink" title="Vue组件通信 ❗"></a>Vue组件通信 ❗</h2><details><summary><b>答案</b></summary><p><ul><li><p>父子间通信:父亲提供数据通过属性<code>props</code>传给儿子；儿子通过<code>$on</code> 绑父亲的事件，再通过<code>$emit</code> 触发自己的事件（发布订阅）</p></li><li><p>利用父子关系<code>$parent</code> 、<code>$children</code> ，<br>获取父子组件实例的方法。</p></li><li><p>父组件提供数据，子组件注入。<code>provide</code> 、<code>inject</code> ，插件用得多。</p></li><li><p><code>ref</code> 获取组件实例，调用组件的属性、方法</p></li><li><p>跨组件通信<code>Event Bus</code>  （Vue.prototype.$bus = new Vue）其实基于$on与$emit</p></li><li><p><code>vuex</code>  状态管理实现通信</p></p></details></li></ul><h2 id="Vuex-工作原理"><a href="#Vuex-工作原理" class="headerlink" title="Vuex 工作原理"></a>Vuex 工作原理</h2><details><summary><b>答案</b></summary><p><p>官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></p><ul><li><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</p></li><li><p>状态自管理应用包含以下几个部分：</p><ul><li><p>state，驱动应用的数据源；</p></li><li><p>view，以声明方式将 state 映射到视图；</p></li><li><p>actions，响应在 view 上的用户输入导致的状态变化。下图单向数据流示意图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aecf55d9a396473c95dff6eca9ecfb7b~tplv-k3u1fbpfcp-watermark.image" alt=""></p></li></ul></li><li><p>vuex，多组件共享状态，因-单向数据流简洁性很容易被破坏：</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。<br><img src= "/img/loading.gif" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17eb2230b3f46729cbfbe7144873065~tplv-k3u1fbpfcp-watermark.image" alt=""></p></details></li></ul></li></ul><p>问虚拟<code>DOM</code> 吧，看你能不能讲清楚从真实<code>DOM</code> 到虚拟<code>DOM</code> ，再和我说说<code>diff</code> </p><h2 id="如何从真实DOM到虚拟DOM"><a href="#如何从真实DOM到虚拟DOM" class="headerlink" title="如何从真实DOM到虚拟DOM"></a>如何从真实DOM到虚拟DOM</h2><details><summary><b>答案</b></summary><p><p>涉及到Vue中的模板编译原理，主要过程：</p><ol><li><p>将模板转换成<code>ast</code> 树，<code>ast</code> 用对象来描述真实的JS语法（将真实DOM转换成虚拟DOM）</p></li><li><p>优化树</p></li><li><p>将<code>ast</code> 树生成代码</p></p></details></li></ol><h2 id="用VNode来描述一个DOM结构"><a href="#用VNode来描述一个DOM结构" class="headerlink" title="用VNode来描述一个DOM结构"></a>用VNode来描述一个DOM结构</h2><details><summary><b>答案</b></summary><p><p>虚拟节点就是用一个对象来描述一个真实的DOM元素。首先将<code>template</code> （真实DOM）先转成<code>ast</code> ，<code>ast</code> 树通过<code>codegen</code> 生成<code>render</code> 函数，<code>render</code> 函数里的<code>_c</code> 方法将它转为虚拟dom</p></p></details><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><details><summary><b>答案</b></summary><p><p><strong>时间复杂度：</strong> 个树的完全<code>diff</code> 算法是一个时间复杂度为<code>O(n*3）</code> ，vue进行优化转化成<code>O(n)</code> 。</p><p><strong>理解：</strong></p><ul><li><p>最小量更新，<code>key</code> 很重要。这个可以是这个节点的唯一标识，告诉<code>diff</code> 算法，在更改前后它们是同一个DOM节点</p><ul><li>扩展<code>v-for</code> 为什么要有<code>key</code> ，没有<code>key</code> 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改DOM），加<code>key</code> 只会移动减少操作DOM。</li></ul></li><li><p>只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。</p></li><li><p>只进行同层比较，不会进行跨层比较。</p></li></ul><p><strong>diff算法的优化策略</strong>：四种命中查找，四个指针</p><ol><li><p>旧前与新前（先比开头，后插入和删除节点的这种情况）</p></li><li><p>旧后与新后（比结尾，前插入或删除的情况）</p></li><li><p>旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）</p></li><li><p>旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）</p></p></details></li></ol><p>— 问完上面这些如果都能很清楚的话，基本O了 —</p><p>以下的这些简单的概念，你肯定也是没有问题的啦😉</p><h2 id="Computed-watch-和-method"><a href="#Computed-watch-和-method" class="headerlink" title="Computed watch 和 method"></a>Computed watch 和 method</h2><details><summary><b>答案</b></summary><p><p><strong>computed</strong>：默认<code>computed</code>也是一个<code>watcher</code>具备缓存，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。如果一个数据依赖于其他数据，使用<code>computed</code> </p><p><strong>watch</strong>：每次都需要执行函数。 <code>watch</code> 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。</p><p><strong>method</strong>：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大</p></p></details><h2 id="v-if-和-v-show-区别"><a href="#v-if-和-v-show-区别" class="headerlink" title="v-if 和 v-show 区别"></a>v-if 和 v-show 区别</h2><details><summary><b>答案</b></summary><p><ul><li><p><code>v-if</code>  如果条件不成立不会渲染当前指令所在节点的DOM元素</p></li><li><p><code>v-show</code> 只是切换当前DOM的显示与隐藏</p></p></details></li></ul><h2 id="v-for和v-if为什么不能连用"><a href="#v-for和v-if为什么不能连用" class="headerlink" title="v-for和v-if为什么不能连用"></a>v-for和v-if为什么不能连用</h2><details><summary><b>答案</b></summary><p><p><code>v-for</code>  会比 <code>v-if</code>  的优先级更高，连用的话会把<code>v-if</code> 的每个元素都添加一下，造成性能问题。</p></p></details><h2 id="v-html-会导致哪些问题（简单）"><a href="#v-html-会导致哪些问题（简单）" class="headerlink" title="v-html 会导致哪些问题（简单）"></a>v-html 会导致哪些问题（简单）</h2><details><summary><b>答案</b></summary><p><ul><li><p><code>XSS</code> 攻击</p></li><li><p><code>v-html</code>  会替换标签内部的元素</p></p></details></li></ul><h2 id="描述组件渲染和更新过程"><a href="#描述组件渲染和更新过程" class="headerlink" title="描述组件渲染和更新过程"></a>描述组件渲染和更新过程</h2><details><summary><b>答案</b></summary><p><p>渲染组件时，会通过<code>vue.extend()</code> 方法构建子组件的构造函数，并进行实例化。最终手动调用<code>$mount()</code> 进行挂载。更新组件时会进行<code>patchVnode</code> 流程，核心就是<code>diff</code> 算法。</p></p></details><h2 id="组件中的data为什么是函数"><a href="#组件中的data为什么是函数" class="headerlink" title="组件中的data为什么是函数"></a>组件中的data为什么是函数</h2><details><summary><b>答案</b></summary><p><p>避免组件中的数据互相影响。同一个组件被复用多次会创建多个实例，如果<code>data</code> 是一个对象的话，这些实例用的是同一个构造函数。为了保证组件的数据独立，要求每个组件都必须通过<code>data</code> 函数返回一个对象作为组件的状态。</p></p></details><h2 id="为什么要使用异步组件？"><a href="#为什么要使用异步组件？" class="headerlink" title="为什么要使用异步组件？"></a>为什么要使用异步组件？</h2><details><summary><b>答案</b></summary><p><ol><li>节省打包出的结果，异步组件分开打包，采用jsonp的方式进行加载，有效解决文件过大的问题。</li><li>核心就是包组件定义变成一个函数，依赖<code>import（）</code> 语法，可以实现文件的分割加载。<br>详细的看官方文档：<a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6</a></p></details></li></ol><h2 id="action-与-mutation-的区别"><a href="#action-与-mutation-的区别" class="headerlink" title="action 与 mutation 的区别"></a>action 与 mutation 的区别</h2><details><summary><b>答案</b></summary><p><ul><li><code>mutation</code>  是同步更新，<code>$watch</code> 严格模式下会报错</li><li><code>action</code>  是异步操作，可以获取数据后调用<code>mutation</code> 提交最终数据</p></details></li></ul><h2 id="插槽与作用域插槽的区别"><a href="#插槽与作用域插槽的区别" class="headerlink" title="插槽与作用域插槽的区别"></a>插槽与作用域插槽的区别</h2><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><details><summary><b>答案</b></summary><p><ul><li><p>创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类<code>&#123;a:[vnode],b[vnode]&#125;</code> </p></li><li><p>渲染组件时会拿对应的<code>slot</code> 属性的节点进行替换操作。（插槽的作用域为父组件）</p></p></details></li></ul><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><details><summary><b>答案</b></summary><p><ul><li><p>作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。</p></li><li><p>普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。</p></p></details></li></ul><h2 id="vue中相同逻辑如何抽离"><a href="#vue中相同逻辑如何抽离" class="headerlink" title="vue中相同逻辑如何抽离"></a>vue中相同逻辑如何抽离</h2><details><summary><b>答案</b></summary><p><p>其实就是考察<code>vue.mixin</code> 用法，给组件每个生命周期，函数都混入一些公共逻辑。</p></p></details><h2 id="谈谈对keep-alive的了解"><a href="#谈谈对keep-alive的了解" class="headerlink" title="谈谈对keep-alive的了解"></a>谈谈对keep-alive的了解</h2><details><summary><b>答案</b></summary><p><p><code>keep-alive</code> 可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。常用的2个属性<code>include/exclude</code> ，2个生命周期<code>activated</code> ，<code>deactivated</code> </p></p></details><h2 id="Vue性能优化"><a href="#Vue性能优化" class="headerlink" title="Vue性能优化"></a>Vue性能优化</h2><details><summary><b>答案</b></summary><p><p><strong>编码优化</strong>：</p><ul><li>事件代理</li><li><code>keep-alive</code> </li><li>拆分组件</li><li><code>key</code> 保证唯一性</li><li>路由懒加载、异步组件</li><li>防抖节流</li></ul><p><strong>Vue加载性能优化</strong></p><ul><li>第三方模块按需导入（<code>babel-plugin-component</code> ）</li><li>图片懒加载</li></ul><p><strong>用户体验</strong></p><ul><li><code>app-skeleton</code>  骨架屏</li><li><code>shellap</code> p壳</li><li><code>pwa</code> </li></ul><p><strong>SEO优化</strong></p><ul><li>预渲染</p></details></li></ul><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>🚀🚀 觉得不错的朋友可以⭐️关注我，后续会持续更新~</p><p>⭐️⭐️ 最后祝各位正在准备秋招补招和春招的小伙伴面试顺利~，收割offer，我们一起加油吧🤝！还有就是<br>新年快乐❤️ ❤️ ~</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS手撕，经典面试题</title>
      <link href="/posts/10205/"/>
      <url>/posts/10205/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>首先出这篇文章，一方面是为了记录巩固我所学的知识，明白面试的高频考点。不鼓励大家背题的，初衷是希望总结的一些面试题能帮助你查漏补缺，温故知新。这些题并不是全部，如果你还想看得更多，可以访问<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes/issues">GitHub仓库</a>，目前已经有552道大厂真题了，涵盖各类前端的真题，欢迎加入我们一起来讨论~</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ul><li>语法：fn.call(obj,…args)</li><li>功能：执行fn，使this为obj，并将后面的n个参数传给fn</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">obj, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">undefined</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    obj = globalThis</span><br><span class="line">  &#125;</span><br><span class="line">  obj.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">let</span> res = obj.<span class="title function_">fn</span>(...args)</span><br><span class="line">  <span class="keyword">delete</span> obj.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span> (<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, <span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.<span class="title function_">myCall</span>(foo, <span class="string">&#x27;HearLing&#x27;</span>, <span class="number">18</span>) <span class="comment">//HearLing 18 1</span></span><br><span class="line">bar.<span class="title function_">myCall</span>(<span class="literal">null</span>, <span class="string">&#x27;HearLing&#x27;</span>, <span class="number">18</span>) <span class="comment">//HearLing 18 2</span></span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><ul><li>语法：fn.apply(obj,arr)</li><li>功能：执行fn，使this为obj，并arr数组中元素传给fn</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myAplly</span> = <span class="keyword">function</span> (<span class="params">obj, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">undefined</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    obj = globalThis</span><br><span class="line">  &#125;</span><br><span class="line">  obj.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">let</span> res = obj.<span class="title function_">fn</span>(...arr)</span><br><span class="line">  <span class="keyword">delete</span> obj.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span> (<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, <span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.<span class="title function_">myAplly</span>(foo, [<span class="string">&#x27;HearLing&#x27;</span>, <span class="number">18</span>]) <span class="comment">//HearLing 18 1</span></span><br><span class="line">bar.<span class="title function_">myAplly</span>(<span class="literal">null</span>, [<span class="string">&#x27;HearLing&#x27;</span>, <span class="number">18</span>]) <span class="comment">//HearLing 18 2</span></span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul><li>语法：fn.bind(obj,…args)</li><li>功能：返回一个新函数，给fn绑定this为obj，并制定参数为后面的n个参数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">obj, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> fn) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">that</span>(...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> that.<span class="title function_">call</span>(obj, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">value = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span> (<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, <span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = bar.<span class="title function_">myBind</span>(foo, <span class="string">&#x27;HearLing&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">//fn() //HearLing 18 1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">fn</span>() <span class="comment">//HearLing 18 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>)<span class="comment">//bar &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="区别call-apply-bind"><a href="#区别call-apply-bind" class="headerlink" title="区别call()/apply()/bind()"></a>区别call()/apply()/bind()</h3><p><strong>call(obj)/apply(obj)：</strong>:调用函数, 指定函数中的this为第一个参数的值<br><strong>bind(obj):</strong> 返回一个新的函数, 新函数内部会调用原来的函数, 且this为bind()指定的第一参数的值</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul><li>理解：在函数多次频繁触发时，函数执行一次后，只有大于设定的执行周期后才会执行第二次</li><li>场景：页面滚动（scroll）、DOM 元素的拖拽（mousemove）、抢购点击（click）、播放事件算进度信息</li><li>功能：节流函数在设置的delay毫秒内最多执行一次（简单点说就是，我上个锁，不管你点了多少下，时间到了我才解锁）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span></span><br><span class="line">    flag = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">      flag = <span class="literal">true</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><ul><li>理解：在函数频繁触发是，在规定之间以内，只让最后一次生效</li><li>场景：搜索框实时联想（keyup/input）、按钮点击太快，多次请求（登录、发短信）、窗口调整（resize）</li><li>功能：防抖函数在被调用后，延迟delay毫秒后调用，没到delay时间，你又点了，清空计时器重新计时，直到真的等了delay这么多秒。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流与防抖的区别"><a href="#节流与防抖的区别" class="headerlink" title="节流与防抖的区别"></a>节流与防抖的区别</h3>首先概念上的不同，解释一下什么是防抖节流；然后就是使用场景的不同；<br>经典区分图：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df0bec093f754804b46a86704096215b~tplv-k3u1fbpfcp-zoom-1.image" alt=""><h3 id="curry"><a href="#curry" class="headerlink" title="curry"></a>curry</h3></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mycurry</span>(<span class="params">fn, beforeRoundArg = []</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...beforeRoundArg, ...<span class="variable language_">arguments</span>]</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &lt; fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> mycurry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sumFn = <span class="title function_">mycurry</span>(sum)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sumFn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))<span class="comment">//6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  arr.<span class="title function_">foreach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[item] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      obj[item] = <span class="literal">true</span></span><br><span class="line">      res.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他方法</span></span><br><span class="line"><span class="comment">//Array.from(new Set(array))</span></span><br><span class="line"><span class="comment">//[...new Set(array)]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归展开</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flattern1</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  arr.<span class="title function_">foreach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(...<span class="title function_">flattern1</span>(item))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newInstance</span> (<span class="title class_">Fn</span>, ...args) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Fn</span>.<span class="title function_">call</span>(obj, ...args)</span><br><span class="line">  <span class="comment">// 如果Fn返回的是一个对象类型, 那返回的就不再是obj, 而是Fn返回的对象否则返回obj</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instance_of</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.<span class="property">__proto__</span> === prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    left = left.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">instance_of</span>(a, <span class="title class_">Object</span>))<span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="对象数组拷贝"><a href="#对象数组拷贝" class="headerlink" title="对象数组拷贝"></a>对象数组拷贝</h2><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的方法</span></span><br><span class="line"><span class="comment">//Object.assign(target,...arr)</span></span><br><span class="line"><span class="comment">// [...arr]</span></span><br><span class="line"><span class="comment">// Array.prototype.slice()</span></span><br><span class="line"><span class="comment">// Array.prototype.concate()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cloneShallow</span>(<span class="params">origin</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> origin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      target[key] = origin[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lala&#x27;</span>,</span><br><span class="line">  <span class="attr">skill</span>: &#123;</span><br><span class="line">    <span class="attr">js</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">css</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newobj = <span class="title function_">cloneShallow</span>(obj)</span><br><span class="line">newobj.<span class="property">name</span> = <span class="string">&#x27;zhl&#x27;</span></span><br><span class="line">newobj.<span class="property">skill</span>.<span class="property">js</span> = <span class="number">99</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)<span class="comment">//&#123; name: &#x27;lala&#x27;, skill: &#123; js: 99, css: 2 &#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newobj)<span class="comment">//&#123; name: &#x27;zhl&#x27;, skill: &#123; js: 99, css: 2 &#125; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的方法</span></span><br><span class="line"><span class="comment">//JSON.parse(JSON.stringify(obj))</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">source, hashMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> target = <span class="keyword">new</span> source.<span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line">  <span class="keyword">if</span> (source == <span class="literal">undefined</span> || <span class="keyword">typeof</span> source !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> source</span><br><span class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="title function_">source</span>(<span class="title class_">Date</span>)</span><br><span class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="title function_">source</span>(<span class="title class_">RegExp</span>)</span><br><span class="line">  hashMap.<span class="title function_">set</span>(target, source)<span class="comment">//解决循环引用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      target[key] = <span class="title function_">deepClone</span>(source[key], hashMap)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="comment">//应该考虑更复杂的数据</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lala&#x27;</span>,</span><br><span class="line">  <span class="attr">skill</span>: &#123;</span><br><span class="line">    <span class="attr">js</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">css</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newobj = <span class="title function_">deepClone</span>(obj)</span><br><span class="line">newobj.<span class="property">skill</span>.<span class="property">js</span> = <span class="number">100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)<span class="comment">//&#123; name: &#x27;lala&#x27;, skill: &#123; js: 1, css: 2 &#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newobj)<span class="comment">//&#123; name: &#x27;lala&#x27;, skill: &#123; js: 99, css: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>🚀🚀 更多基础知识总结可以⭐️关注我，后续会持续更新面试题总结~</p><p>⭐️⭐️ 最后祝各位正在准备秋招补招和春招的小伙伴面试顺利<del>，收割offer，我们一起加油吧🤝！还有就是快春节了，提前祝你新年快乐</del>❤ ❤ </p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从大一到大三，我与服务外包大赛🏆</title>
      <link href="/posts/10203/"/>
      <url>/posts/10203/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我与服务外包，真的是一场缘分，大一的时候因为在部门学会了做视频，在班级群看到辅导员问有没有人会做视频，我回复了，没想到我与服务外包的缘分就此展开了。。。</p><p>总结我与服务外包：大一帮忙做视频接触服务外包这个比赛，大二正式参加的服务外包拿到<code>一等奖</code>，大三又参加拿到<code>二等奖</code>。</p><p>我写这篇文章已经过了记录心路历程的最佳时间，所以这篇文章更多的是建议和打气，因为我觉得你们肯定比当时的我要厉害，我行你也行的，要相信自己！</p><p>—— 正文开始——</p><p>若果你是要听故事，那么你可以从头到尾看这篇文章，若果只是想听我分享经验，可以直接跳到最后。</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>一切得从一个群消息开始，是辅导员金杰学长在群里问我们有没有会做视频的，大一的我很菜，自己也就是会一些皮毛，我一时间看到了也没有回复。学长又说了是一位学姐请人帮忙，十分急迫。我想着等等我们班那些做视频做得好的回复，然而过了一会都没有人，我看着总不能没人帮这个忙吧，又不是什么坏事，于是我回了：<code>我会做视频吖~</code></p><p>很快学姐就加到我了，确实十分迫切，交给我的任务就是做一个他们课程系统的介绍视频，也就是从这个时候开始，我了解到了很多技术，记得当时很多名词都还不会读呢。。。</p><p>当时改视频改到崩溃：（这个文件一直留着得有三年了吧）</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c0f2d19ce884368a3fed46113b57943~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>做的视频截取了部分：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b4da4f55d414adb8c1facf9e29f3a18~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>其实真的很坎坷，时间也很紧迫，也因我当时做视频的能力确实不行，达不到她们的期望，最后还是拉上老韩（韩梓健），熬了一个通宵，才做完整个四分多钟视频。</p><p>最后学长学姐拿到了三等奖，这个证书上虽然没有我的名字，但是也觉得自己收获满满，也为我之后想这个奖上有我的名字埋下了种子。。。</p><h2 id="从未想过的道路"><a href="#从未想过的道路" class="headerlink" title="从未想过的道路"></a>从未想过的道路</h2><p>第一个没想过：我当组长，第二个没想过：选一个没人选的题，第三个没想到：大二就拿国一 🏆</p><p>真的是从未想过的道路，其实中途一阵很慌，做为组长也压力山大。但是努力总是有回报的吧，我也一直对我们的项目很有信心，虽然我可能并不是技术的核心人物，但是大家各司其职，完成一个远大目标的这种感觉实在太妙了~</p><h3 id="预备阶段"><a href="#预备阶段" class="headerlink" title="预备阶段"></a>预备阶段</h3><p>伟帅（刘伟老师）把我们所有组拉一起讲了一下选题之后(人是真的多，整个三机房全满了)，当天晚上我们就把企业命题的 PDF 打印出五份，去小吃街的螺蛳粉店里头讨论命题。</p><p>第一次选题讨论：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b799b8e16b94a3db28917542f8c2196~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>赛题匹配</strong>：我们拿着册子一页一页，拿着笔一遍遍的筛筛着命题，划掉不可能选的题包括且不限于大数据量化的，硬件设计的，需要自己写人工智能内核逻辑的，需要大量资金的等等，真有点职场讨论的意思。最后选题落在四个上面，两个微信小程序(其中一个就是 A11)，一个传统的跨境电商，一个 A15 景点识别。</p><p><strong>经典二选一</strong>：队里讨论到后面有两种声音：<br>赵振睿和吴若峰（上图离我远一些的两位）主张选微信小程序的，理由：</p><ol><li>本生微信是国内平台。</li><li>文档多，学习成本低。</li><li>命题的功能点虽多但都很明确。</li></ol><p>韩梓健和缪传鹏主张选 A15，理由：</p><ol><li>写这个代码必须要用到 Xcode,那玩意儿只存在于白苹果和黑苹果，白苹果不是家家都有这就刷掉一批人了，黑苹果也不是家家都会又刷掉一批人了，而韩梓健恰好又能装黑苹果，这是先天优势。</li><li>选 Swift 语言的好处是能把大家都拉回同一起跑线，一起从零开始学习，毕竟移动端 IOS 开发大学生肯定没有专门去学。</li><li>参加这个比赛主要是为了学习，就算没拿奖也没关系，以后职场能用。</li></ol><p>好家伙二比二平了呗，换你来你会怎么选呢？</p><p><strong>选题 ending</strong>：当时的我们才刚进大二，总结来说光脚的不怕穿鞋的，什么都要新学，为什么不选一个感兴趣的呢？经过我们三（我、缪、韩）的说服，我们五个都统一了观点。话说那个时候我们都挺自信的，可能是不知道未来要面对什么吧 😅</p><p><strong>选题挑战</strong>：1、谷歌的 API 是什么，返回来的结果是什么都不知道。2、当时队里五台电脑只有两台黑苹果。3、如何实现景点识别的逻辑毫无头绪。😂 真的是非常的莽，但是对于当时的我们啥都是挑战，可能这个挑战更大，但是如果我们实现了感觉能吹一辈子。</p><p>当时的赛题：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4d44e14e55d44fe9fa51ff0af41032d~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="赛题启动"><a href="#赛题启动" class="headerlink" title="赛题启动"></a>赛题启动</h3><p><strong>启动及危机</strong>：选完题没多久，期末了。。。大家都忙着复习。。。期末弄完就又实训了。。。实训完放寒假了。。。 哪怕时间再紧凑也还是要挤出时间来的，现阶段还写不了代码，那就想功能，想创新，聊分工，总有能做的事 💗。</p><p>当时的需求分析：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b480aa1c586c496db25b85df7a5d83d7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="十分重要的寒假"><a href="#十分重要的寒假" class="headerlink" title="十分重要的寒假"></a>十分重要的寒假</h2><p>放寒假更不好弄了，很容易就分心，虽然早就预料到了，没想到心散的这么快 💔。刚回家那一阵，都没什么人吱声，大家似乎都不知道要干些什么，没什么干劲，我想多半是我的问题，于是有了下面的张图，根据这张图明确功能点明确了分工。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed1b08efebb746b3820bf49580473c86~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p><strong>灵魂拷问</strong>：</p><ul><li>要五个人都编码嘛？要你你怎么安排？</li><li>队员找不到，或有事，项目参与度低怎么办？</li><li>项目进度缓慢怎么办？<br>我在这先不说，当时的我这方面做的不是太好，后面在大三的参加的时候吸取了教训，具体怎么做的后面再说吧。</li></ul><p><strong>积极面对</strong>：寒假整个下来并不顺利，首先在群里疯狂活跃，杜绝冷场吧，基本上除了编码，能做的事我都做了，主要还是看他们吧</p><p>墨刀做的原型（部分）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42251339df9c4795b11170035f684584~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>期间的各种文档，做的一点也不比写代码简单，如果让我选我宁愿去写代码，然而我没得选 😭，安安心心写了几千字，加上做各种图（跟写论文差不多）</p><p>当时的文档，各种改（不要学我这么弄，当时比较傻）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de29ea1e82f8426cba91b9140c445cc1~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="回学校"><a href="#回学校" class="headerlink" title="回学校"></a>回学校</h3><p><strong>寒假结束</strong>：文字、图片、语音翻译都有了，也就是说核心的翻译功能我们基本完成了，当然我也知道单靠这样是没法拿奖的。不过还是要吹一波组员，总还是会跟我报告一下进度，发个小视频演示一下效果，况且用的黑苹果很卡顿，这么极端条件下能做完这些已经很不错了。</p><p>寒假做出的功能 demo，十分简陋：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39d55ca8c872489089abf3a37163efd3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>初检查</strong>：<br>一回到学校不久伟帅就要检查项目了！咋办呐，没有界面，拿这个去不被骂死 😧？不过回学校还是有很多好处，大家集在一起，很快就开始进入正轨了，当时我们拿着韩梓健用 Flutter 撸出来的一个模板交货，并且讲了我们理解的大概的命题需求和想法。</p><p>那天伟帅在机房里提了许多想法。你们不是搞 AR 吗（可能因为我们实现了一个 AR demo）？AR 中搞一个气球，显示这个景点和你的距离，越远越小，点一下他就飞走引领你去目的地。还有啥 NLP 情感分析的，能识别出大家对于这个景点的舆论评级，进而做推荐还有很多。走出三教之后吴若峰就说”咋不上天呢”? 😂 哈哈哈哈哈哈哈</p><p><strong>启程</strong>：因为只有一个月就要交作品了，时间非常非常赶，我们回来就各种熬夜写逻辑，做界面。我和赵振睿则负责文档 PPT 的初步撰写等等。那段时间因为队里只有两台正常的黑苹果，经常是韩做完部分功能睡觉后老缪接过他的电脑继续工作。我们那几个技术 boy 那几个星期是天天熬夜，熬到三四点都是小意思了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af33663b1fd64763b3e99ca57043ce8f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>收尾</strong>：因为我们这个软件的性质，我们去拍介绍视频就免不了“游山玩水”，我们去了五一广场，橘子洲头拍素材。拍完之后老韩（韩梓健）就开工了，这里放一段 GIF，视频做的是真的好，所以说大佬就是大佬呢，很有大片的感觉，配上音乐一绝。我呢就还是“打杂”，在组员的帮助下把能写的都写出来了，PPT 也都做出来了，最后文档 PPT 视频，加上编译的 ipa，上传，over 了，结果由天。</p><p>大佬做的视频片段：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad617c135a545b6a94cd4f1d75db9ae~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>PPT</p><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06cd356c79c147f5a317c31b428fdd38~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="决赛！"><a href="#决赛！" class="headerlink" title="决赛！"></a>决赛！</h3><p>那天我们还在上课，组员突然发我消息说我们进了，一看文件确实我们进决赛了，这意味着我们可以去无锡了！当天晚上我们又去那家螺蛳粉的店里搓了一顿，看了一下名单 A15 进决赛的全国就五支队伍，之前中南，南邮选这个题目的都被刷掉了，不禁唏嘘。A11 有 11 个队伍，而且学校另外两个进决赛的也都选了 A11，反正怎么想都觉得当时没选 A11 或者另外一个微信小程序题目的决定多么正确 ✌️。再加上我们有 AR，实际上从那时候开始我们还是很有信心的，底气来自于各种核心代码逻辑，各种核心功能实现都是自己写出来的。伟帅把我们叫去开会，让我们准备答辩，做好 PPT 录好视频，准备好稿子什么的。</p><h3 id="喜讯！"><a href="#喜讯！" class="headerlink" title="喜讯！"></a>喜讯！</h3><p><strong>到了酒店</strong>：经过了一天的高铁，我们一行人都挺累的了，不过当天晚上伟帅还是拉着我们再阿里是房间又来了一场排练，当时吴若峰已经对 PPT 非常熟悉了，都可以做到不看 PPT 从头到尾娓娓道来。第二天就要比赛，我让他们早点休息，缪传鹏还在改代码，第二天早上和我说 AR 翻译做到所见即所得了，没有延迟，花了一个晚上给 AR 绘图加了多线程，大大提升速度。我已听到高兴坏了，之前还担心评委要求演示 AR 半天半天不出来呢，现在可以说是真的一点都不慌了。</p><p>一大早缪传鹏还在改代码：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed5e5bb532d94aafb3ffd6b4524b9c72~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>答辩</strong>：我们抽到的签是下午一点的，当时咱们学校的另外两个队伍都已经答完了，看着都挺轻松的，我们也不慌，进答辩室之前都是有说有笑的。进去之后正常的按流程，答辩，视频演示。回答问题也是一样，因为创新点，功能点是在你这边，你知道你为什么要做这个功能，你怎么做这个功能，所以，其实主导权在你手里，无论老师怎么问，万变不离其宗。换句话说，只要老师问到了我们设计的功能点上，我们都能回答的非常好。反而让我们担心的是他们如果问成本，问市场价值这些虚幻的东西我们可能会紧张答不好，但其实也无所谓，毕竟我们做足了百分的准备…</p><p>一出答辩门，我们都小声的说 <code>稳了，稳了</code>，伟帅看我们一脸笑意的走过来，也笑了，都不需要问我们情况，我们路上还在想该不会我们三个队伍都拿一等奖吧哈哈哈。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b88aa79c298249069ab57c8c428c032a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>一通电话</strong>：第二天早上我原本想睡个懒觉，因为昨晚大家一起庆祝玩累了，迷迷糊糊接到志愿者的电话说要去彩排，三支队伍有两只接到了电话，我们推断我们就是一等奖了，掩饰不住的喜悦，急匆匆的就去了江大。然后体育馆彩排照片传回来实锤了就是一等奖，高兴的一批 😆。</p><p><strong>完结撒花</strong>：接下来就是开心的玩耍啦，伟帅还请我们搓了一顿，然而时间还是有限，也就玩了一天，收获满满回学校了~<br>一回学校我就发了说说，当时要是我有博客就可以把这些分享给更多人了：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/728c2dfba8cd4725bf914bb550e5df73~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h2><p>没错大三我又参见了这个比赛，确实是觉得自己在之前的比赛中，技术方面没有学到很多，于是我和赵振睿两个就一起约着继续参加。大三期间我们也学了一些新的技术，其中两个组员就是课题作业的两位，还有一位则是睿哥他们组的组员。然后就是整装待发，开始了第二次的服务外包大赛之旅。</p><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>其实大体上和大二是差不多的，如果硬要说区别，可能是更沉稳了？当时也是有比较成熟的技术栈了，就想学学对以后找工作有用的新技术，于是采用了相对比较保守的选题策略。<br>然后就还是老样子啦，依然是要考试等等事情，不过倒是不是很慌问题不大，毕竟身份不同，现在可是老学姐了啦哈哈哈~</p><h3 id="疫情来袭"><a href="#疫情来袭" class="headerlink" title="疫情来袭"></a>疫情来袭</h3><p>寒假回家之前，我们已经完成了原型设计，需求分析，创新点分析，前端要用的一些框架也学得差不多了。接着回到家，我制定了一系列的计划，人员安排，保证人人都有事情做。要说我唯一没有料到的事情就是疫情，我也没法预料。说实话确实是有一阵子乱了针脚。每天都实时关注着各类信息，时不时被感动又被气炸，可能还睡不好觉，不过好在疫情慢慢转好，心情也不再那么容易波动，修整之后很快我们又步上了正轨。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab3055a0f194483c9769622604615082~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>不过仔细想想有没有疫情我们五个注定都是要宅在在家写代码的。当然依旧还是会出现问题，比如一个功能点久久实现不出来，这个赛题要求的文档太多了怎么办，真的想不出创新点又怎么办？等等。。。</p><p><strong>漫长的假期</strong>：感觉每天都在重复上演，每天都在做着差不多的事，只不过饭菜发生了一些改变，经常是写着写着一下午就过去了，又要吃晚饭了。在加上疫情的缘故改成了网上授课，原本我们计划回学校一起讨论写代码什么的都泡汤了，“假期”感觉又长了许多。。。于是只能继续沿用假期的管理方案，白天就是自由写代码还有上课，晚上咱们就开会议视频 7 点到 10，也不是说一定要讲什么事，有事就一起快速讨论解决了，没事就还是各自写代码（没有疫情，我们就会是在机房疫情写的了）</p><p>也不知道因为这个会议视频我产出了多少黑照：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e24bf86f4e834c009738a387efcee0a9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>每星期一篇的汇报情况文档：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c6c495811594cadba16dfc55cf0996f~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p><strong>独当大任</strong>：除了写代码，还有一个重大的工程，那就是做视频了，以前还有老韩在，现在我要一个人来面对了哎~。没有办法拿起鼠标就是干呗，找素材录音剪辑，全自学，直接实践，现在回头看觉得实在是挺猛的。不过确实还是不是非常完美的，毕竟当时时间还是比较紧张嘛，虽然没有老韩那个视频那么上档次，但这个扁平化小清新的风格是视频还是符合我们软件介绍的感觉的。</p><p>放个视频片段吧：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d254f88b905b4647b902470edb4381e3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="回到学校"><a href="#回到学校" class="headerlink" title="回到学校"></a>回到学校</h3><p>回到学校，完善了所有要提交的东西，最终交了上去，等待通知。不过我们基本不会熬夜了，前期该做的都做了，可能就是改改界面改改视频以及文档的一些工作。</p><p><strong>区域赛</strong>：不过和以往不同的是，今年开始（2020）开始分区域赛了，进了区域赛再比一轮才能进决赛，门槛比以往高了许多，痛苦也加倍。。。还记得当时同样的场景，还是在课间，收到伟帅在大群里发的获奖名单，怀着忐忑的心情点开了它，搜索着我们的组名，进了！一下子石头落地，甚至想哭 😭</p><p><strong>答辩</strong>：我是最了解我们这个项目的人，毫无疑问答辩主讲的任务落在了我的头上，连夜写主讲稿，每次都还是会有一些些失误，伟帅也一直说我可以更自信，稿子要记熟，不要死记。我就拿着稿子天天背，晚上睡觉脑子里还会自动想稿子里的内容。当时觉得自己哪里都有问题，自带湖南口音难纠正这是一，二呢说得太快经常性顺嘴或者卡壳，三呢用伟帅的话说就是没有激情，给我造成了挺大打击的，但是组员总是会在我垂头丧气时给我鼓励，感恩~💕</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14ed476d6e804534a453787919a47864~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="决赛"><a href="#决赛" class="headerlink" title="决赛"></a>决赛</h3><p>其实还是有遗憾的，没能再去一趟无锡，只能远程参见决赛，彩排也只能各自在家中。</p><p><strong>压力</strong>：进决赛是有想到过的，毕竟当时我们做的准备十分充足，并且答辩过程也不错。没有想到的是全校只有我们一个队进了决赛，这就意味着老师都会来盯我们了~虽然也没想过划水，但是压力确实还是会有的。加需求、改视频、加创意等等一堆事儿又来了，不想再讲了，总之就是挺枯燥的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/870e2a1b2fb44aa4a4221caa7d3d0f4b~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>经过几天的远程彩排，终于到决赛那一天了。还是像之前彩排一样我进行着我的演讲，只不过对象从我认识的老师换成了评委老师们。很快如流水般就结束了，问的问题我们也都八九不离十都答出来了。结束后倒是感觉非常不真实，就结束了嘛？我打开手机，志愿者又在报下一组准备了，关上手机，长叹一口气，都结束了~</p><p><img src= "/img/loading.gif" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16d84ca75a50475b96b40a2d9ca03f4e~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p><strong>噩耗</strong>：颁奖当然也还是远程观看的，宣布得奖就是一张名单，仔细查找发现没有我们队，甚至我们这个题都没有一等。我们只能苦笑，忙活半天还是二等奖嘛，之前还想着一等奖没跑了呢 😂</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06e65ebb287a4aef978279f1c80e8147~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>也许是线上的原因吧，也没有那么难过，也询问了伟帅，确实是存在有的赛题没有一等的情况，毕竟那么多题，有的题可能还会有两个一等。我们只能叹了口气，自认选题没选好咯。当天还想发个说说，一翻也没什么合适的照片，呜呜呜要是没有疫情，我们的比赛就是线下了，还可以“白嫖”学校的赞助，还能在无锡游玩 😭</p><p>好吧故事到这就结束了。。。没有图片。。。</p><p>💜 下面是我给参加服务外包比赛的学弟学妹们的一些建议 💜</p><h2 id="我的一些小建议"><a href="#我的一些小建议" class="headerlink" title="我的一些小建议"></a>我的一些小建议</h2><p>我给的建议完全是参考我自己的经验，其实每个组的情况都是不一样的，但是我希望我踩过的坑你们就不要再踩了，我的一些经验能给你一些参考~</p><h3 id="给大二同学的建议"><a href="#给大二同学的建议" class="headerlink" title="给大二同学的建议"></a>给大二同学的建议</h3><p>大二我们选的赛题任务是做一个基于 swift 开发的景点智能识别语言翻译 iOS 软件</p><p><strong>赛题阶段</strong></p><p>当时我们选了一个没有一个队选的赛题，不过我们很有信心，这个信心来自于对赛题的琢磨，队员的情况我们当时就是非常自信，啥也不怕，因为啥对我们都是新的，光脚不怕穿鞋的，但我们都有学新知识的干劲，并且志向高远就是要拿全国一等奖。</p><p>总结起来就是几点：</p><ol><li>要<code>有信心</code>，不仅对自己还有对你的组员</li><li>仔细<code>琢磨每个赛题</code>，了解组员们，选出你们最合适的赛题</li><li>对于<code>新知识不要怕</code>，要有学新知识的干劲</li></ol><p><strong>回家前（大三也适用）</strong></p><p>分工明确，时间规划明确（最简单的就是用笔记下来，当然可以也可以找一些高效的协同工具），最好在回家前对队员的职责非常明确，对自己的组员要有基本了解，在一起就多讨论。</p><p><strong>在家（大三也适用）</strong></p><p>项目汇报要认真督促，不要糊弄老师糊弄自己。</p><p>找不到队员的情况，确实存在，但是最后要了解清楚是什么原因，会造成什么后果，然后组内讨论调整。</p><h3 id="给大三同学的建议"><a href="#给大三同学的建议" class="headerlink" title="给大三同学的建议"></a>给大三同学的建议</h3><p>大三我们选的赛题是做一个绿色积分系统嵌入码上行 APP。</p><p>选题上还是大二差不多，只不过大三的同学们应该是已经有相对成熟的技术栈了，推荐采用了保守选题的策略，不过关键还是看你们啦。</p><p>其他的规划管理还是和大二差不多，可以试着用用除 QQ 以外的一些沟通工具，这里我们可以用一些高效的远程协同工具，比如远程视频（钉钉、腾讯会议），文档协同等等，来提高效率，减少沟通成本。</p><h3 id="一些工具的推荐"><a href="#一些工具的推荐" class="headerlink" title="一些工具的推荐"></a>一些工具的推荐</h3><p>有很多学弟学妹问我视频怎么做，怎么管理团队等等，我这里还是有些工具推荐给大家的。<br>做文档需要的：</p><ul><li><code>ProcessOn</code> 可以实现免费在线作图、实时协作</li><li><code>XMind</code>: 做思维导图的，超级好用</li><li><code>腾讯文档、金山文档、石墨文档</code> :在线协同编辑文档</li><li><code>starUML</code>画 UML 等图的</li></ul><p>做 PPT 需要的（美观）：</p><ul><li>如果只是想做简单的 PPT，就用<code>office PPT</code>就行</li><li>如果追求美观，那必须得用 PPT 模板呀：<code>52PPT</code>（可以下到免费的 PPT）、<code>包图网</code>（找网络部的借会员）、<code>千图网</code>（也是要借会员，也可以去某宝买）、<code>iconfont</code>（图标库）、<code>flaticon</code>（PPT 图标库，需要访问外网）</li></ul><p>做视频需要的</p><ul><li>有条件的可以用 <code>finalCut</code>，我是没有这个条件，没用过，但是韩梓健用的这个，说挺好用的（大二那个视频）</li><li><code>万彩动画大师</code>，我比较推荐的，很好上手，新手友好，扁平化，模板也算多的</li><li><code>pr</code>，常规吧，我用还算习惯，毕竟我只用那么几个功能，做完加个音频剪辑一下的时候用</li><li><code>ae</code>，容易卡，模板不多，难上手，我没玩会，不推荐吧，但是用它做特效应该不错，但是一般我们也没这个需求不是吗？</li></ul><p>这些都只是辅助工具，还是要看你怎么用，可能还有一些忘记写上去了，但基本就这些就足够了</p><h2 id="最后的提醒："><a href="#最后的提醒：" class="headerlink" title="最后的提醒："></a>最后的提醒：</h2><ul><li>每次老师组织的会议都要认真记录很有用，官方和学校赛题群及时关注消息，利用好官网提供的答疑系统去提交对赛题的疑问。</li><li>反复琢磨赛题，琢磨赛题不仅仅是确定需求，挖掘需求，需求排序</li><li>组长最好可视化需求，可视化进度安排，反复根据打分规则自评分析</li><li>团队很重要，不然就变成一个人在写项目了。不互相督促，跟进度，项目完成不了</li><li>最后一定要留充足的时间写文档和做视频，这个是非常重要的，大家也都是懂的，你交上去的东西就是文档和视频，打分也基本根据你提交的文档视频和 PPT 来打分，所以要提前规划好</li></ul><p>💜💜💜 就写到这了，其实应该更早一点发，一直拖到现在，不过也算是对我大学生活的一大部分的总结了 💜💜💜</p><p>写这篇文章也不知道会不会有人看 💔，如果你看到这了，觉得故事不错或者对你有一点点帮助的话，就给个三连再走吧~❤️</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52899d88b6f64c77bc42b74849476342~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
          <category> 关于我 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
            <tag> 关于我 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「面试」前端高频CSS面试题及答案</title>
      <link href="/posts/10201/"/>
      <url>/posts/10201/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>首先出这篇文章，一方面是为了记录巩固我所学的知识，明白面试的高频考点。不过我是不鼓励大家背题的，初衷是希望总结的一些面试题能帮助你查漏补缺，温故知新。这些题并不是全部，如果你还想看得更多，可以访问<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes/issues">小狮子前端</a>，目前已经有552道大厂真题了，涵盖各类前端的真题，欢迎加入我们一起来讨论~</p><p>—— 以下是正文 ——</p><h1 id="介绍一下css盒模型"><a href="#介绍一下css盒模型" class="headerlink" title="介绍一下css盒模型"></a>介绍一下css盒模型</h1><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距margin，边框border，填充padding，和实际内容content。</p><p>有两种盒模型，<strong>标准</strong> 盒模型和 <strong>怪异</strong> 盒模型，区别在于，元素的宽高大小表现为content的大小，而怪异盒模型则表现为content + padding + border的大小<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abcea89eddc847e0a35a25f141e44ac1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="样式框架的原理，布局方法有哪些，flex，grid，还有吗？"><a href="#样式框架的原理，布局方法有哪些，flex，grid，还有吗？" class="headerlink" title="样式框架的原理，布局方法有哪些，flex，grid，还有吗？"></a>样式框架的原理，布局方法有哪些，flex，grid，还有吗？</h1><p><strong>正常流布局</strong> 浏览器默认的HTML布局方式，就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行</p><p><strong>浮动布局</strong> 使用 float 属性，使元素脱离文档流，浮动起来。</p><p><strong>定位布局</strong> 通过 position 属性来进行定位。（这里常考绝对定位于相对定位基准问题，下面再讲）</p><p><strong>使用display布局</strong><br>在css中实现页面布局的主要方法是设定display属性的值。此属性允许我们更改默认的显示方式。<br>通过将一些内容从block转换为inline（反之亦然）来更改默认表示形式，更重要的是可以通过设置flex 或 grid 进行布局：</p><p><strong>flex布局</strong> 通过容器和轴进行布局设置。其中，容器分为父容器和子容器。轴分为主轴和交叉轴。</p><p><strong>grid 网格布局</strong>：可以实现二维布局方式，和 table 布局差不多，基本概念-网格线(Grid Lines) 网格的水平和垂直的分界线 、网格轨道(Grid Track) 好比表格中行或列，分为grid column和grid row 、网格单元格(Grid Cell) 好比表格中的单元格 、网格区域(Grid Area) 好比表格合并单元格后的区域（用的不是很多）</p><p><strong>多列布局</strong> :  一种把内容按列排序的方式，就像文本在报纸上排列那样。使用 column-count属性设置需要多少列，也可以使用column-width以至少某个宽度的尽可能多的列来填充容器。</p><h1 id="css绝对定位和相对定位都是以谁为基准？"><a href="#css绝对定位和相对定位都是以谁为基准？" class="headerlink" title="css绝对定位和相对定位都是以谁为基准？"></a>css绝对定位和相对定位都是以谁为基准？</h1><p>定位position的几个属性要清楚：</p><ul><li><strong>静态定位</strong>(<code>Static</code>positioning)是每个元素<strong>默认</strong>的属性——它表示“将元素放在文档布局流的默认位置。</li><li><strong>相对定位</strong>(<code>Relative</code> positioning)允许我们相对于元素在<strong>正常的文档流中的位置移动</strong>它——包括将两个元素叠放在页面上。这对于微调和精准设计(design pinpointing)非常有用。</li><li><strong>绝对定位</strong>(<code>Absolute</code> positioning)<strong>脱离文档流</strong>。我们可以将元素相对于页面的 <html> 元素边缘固定，或者相对于该元素的最近被定位祖先元素(nearest positioned ancestor element)。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。</li><li><strong>固定定位</strong>(<code>Fixed</code> positioning)与绝对定位非常类似，但是它是将一个元素<strong>相对浏览器视口固定</strong>。 这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。</li><li><strong>粘性定位</strong>(<code>Sticky</code> positioning)它会让元素<strong>先保持和position: static</strong>一样的定位，当它的相对视口位置(offset from the viewport)达到某一个预设值时，他就会<strong>再像position: fixed</strong>一样定位（某些网站头导航栏滚动到一定位置固定到屏幕）。</li></ul><p>再回答这个问题：</p><ul><li><p><strong>absolute</strong> 绝对定位 相对于最近的已定位的祖先元素, （有已定位指position不是static的元素祖先元素）如果无已定位祖先元素, 以body元素为偏移参照基准, 完全脱离了标准文档流。</p></li><li><p><strong>relative</strong>：相对定位元素的定位是相对其正常位置。设置了relative的元素仍然处在文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置。</p></li></ul><p>共同点：改变行内元素的呈现方式，都脱离了文档流；<br>不同点：absolute的”根元素“是可以设置的，fixed的“根元素”固定为浏览器窗口</p><h1 id="浮动布局和flex布局相比有什么优缺点？"><a href="#浮动布局和flex布局相比有什么优缺点？" class="headerlink" title="浮动布局和flex布局相比有什么优缺点？"></a>浮动布局和flex布局相比有什么优缺点？</h1><p><code>flex</code>：优点在于其容易上手，根据flex规则很容易达到某个布局效果。缺点是：浏览器兼容性比较差，只能兼容到ie9及以上。</p><p><code>浮动</code>：浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等。浮动布局的优点就是比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的。</p><h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p><code>clear</code> 规则用于清除元素浮动影响<br><code>::after</code> 伪类为父元素添加后标签，实现清除浮动影响<br>通过添加父元素并设置 <code>overflow</code> 属性可以清除浮动，原因：父元素产生 BFC 机制，即父元素的高度计算会包括浮动元素的高度。</p><h1 id="bfc是什么，怎么样形成bfc，bfc有哪些用？"><a href="#bfc是什么，怎么样形成bfc，bfc有哪些用？" class="headerlink" title="bfc是什么，怎么样形成bfc，bfc有哪些用？"></a>bfc是什么，怎么样形成bfc，bfc有哪些用？</h1><p>BFC Block Formatting Context（BFC | <strong>块级格式化上下文</strong>），是Web页面中盒模型布局的CSS渲染模式，是一个隔离的独立容器。 </p><p><strong>怎样形成一个BFC？</strong><br>块级格式化上下文由以下之一创建：</p><ul><li>根元素或其它包含它的元素</li><li>浮动 (元素的 float 不是 none)</li><li>绝对定位的元素 (元素具有 position 为 absolute 或 fixed)</li><li>非块级元素具有 display: inline-block，table-cell, table-caption, flex, inline-flex</li><li>块级元素具有overflow ，且值不是 visible</li></ul><p><strong>BFC用处</strong></p><ol><li>清除浮动（规则6）</li><li>布局：自适应两栏布局（规则4、5）</li><li>防止垂直margin合并（规则5）</li></ol><p>BFC规则：</p><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的左外边缘（margin-left)， 与包含块的左边（contain box left）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ol><h1 id="css选择器有哪些？"><a href="#css选择器有哪些？" class="headerlink" title="css选择器有哪些？"></a>css选择器有哪些？</h1><p>基本选择器比如 标签标签选择器、类选择器、ID选择器，机构选择器比如后代、子、紧邻兄弟、后兄弟选择器，伪类选择器</p><p><strong>基本选择器</strong>：</p><ul><li><strong>标签选择器</strong>：通配符选择器*、根据标签为元素设置样式</li><li><strong>类选择器</strong>：.class 类选择器是为一类状态声明样式规则</li><li><strong>ID选择器</strong>：#id 为有 id 属性的元素设置样式</li></ul><p><strong>结构选择器</strong>：</p><ul><li>后代选择器：div p  选择元素内部的所有元素</li><li>子元素：div&gt;p 选择子元素，不包括孙级及以下元素</li><li>紧邻兄弟元素： div+p 选择紧挨着的同级兄弟元素</li><li>后兄弟元素选择器：p~ul 选择后面的所有兄弟元素</li></ul><p><strong>属性选择器</strong>：[target] 带有 target 属性所有元素、 [target=_blank]targe 属性 等于”_blank” 的所有元素。。。根据属性来为元素设置样式。 </p><p><strong>伪类选择器</strong>：</p><ul><li>超链接伪类 :target（控制具有锚点目标元素的样式）、:root （根元素选择伪类即选择html）  、:empty （没有内容和空白的元素）</li><li>结构伪类 ：first-child  、 :last-child 、:nth-child(n) 、<br>nth-child(odd) 选择奇数 、 nth-child(even)选择偶数（表格隔行变色 table tr&gt;td:nth-child(odd)）</li><li>表单伪类：input:enabled 选择每个启用的 input 元素</li><li>字符伪类：p:first-letter  选择每个元素的首字母</li></ul><p>元素权重：（可叠加）强制优先级 !important 让某个规则强制有效</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce4cb9f4fa9f439cb1422b46d7fcb590~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="预处理器sass（less）优点"><a href="#预处理器sass（less）优点" class="headerlink" title="预处理器sass（less）优点"></a>预处理器sass（less）优点</h1><p>可以提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性，提高开发效率。</p><h1 id="实现一个垂直水平居中"><a href="#实现一个垂直水平居中" class="headerlink" title="实现一个垂直水平居中"></a>实现一个垂直水平居中</h1><p><strong>垂直水平居中</strong></p><ul><li>行内元素<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">   height: 高度; </span><br><span class="line">   text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">    line-height: 高度;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>flex布局<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line">//或者设置父flex ，子 margin: auto;</span><br></pre></td></tr></table></figure></li><li>table<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  display: table;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">  display: table-cell;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>绝对定位定宽  定高<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.son &#123;</span><br><span class="line"> position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    height: 高度;</span><br><span class="line">    margin-top: -0.5高度;</span><br><span class="line">    width: 宽度;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-left: -0.5*宽度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>transform绝对定位不定宽  不定高<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.son &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, 0);</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate( 0, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>left/right: 0  top/bottom: 0;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.son &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 宽度;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line"></span><br><span class="line">    height: 高度;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="css中隐藏元素的方法，display-none-visibility-hidden-区别？还有什么方式"><a href="#css中隐藏元素的方法，display-none-visibility-hidden-区别？还有什么方式" class="headerlink" title="css中隐藏元素的方法，display:none, visibility:hidden,区别？还有什么方式"></a>css中隐藏元素的方法，display:none, visibility:hidden,区别？还有什么方式</h1></li></ul><p>visibility:hidden、display:none、z-index=-1、opacity：0</p><p><strong>opacity：00</strong>，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发<br><strong>visibility:hidden</strong>，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件<br><strong>display:none</strong>， 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉<br><strong>z-index=-1</strong>，置于其他元素下面</p><h1 id="实现一个块从左到右的移动"><a href="#实现一个块从左到右的移动" class="headerlink" title="实现一个块从左到右的移动"></a>实现一个块从左到右的移动</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  div &#123;</span><br><span class="line">       width: <span class="number">100</span>px;</span><br><span class="line">        height: <span class="number">100</span>px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    div:hover &#123;</span><br><span class="line">        transition: <span class="number">2</span>s;</span><br><span class="line">        transform: <span class="built_in">translateX</span>(<span class="number">100</span>px);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="animation的参数，怎样实现一个动画？"><a href="#animation的参数，怎样实现一个动画？" class="headerlink" title="animation的参数，怎样实现一个动画？"></a>animation的参数，怎样实现一个动画？</h1><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0258957c82844836b6830344825b041c~tplv-k3u1fbpfcp-zoom-1.image" alt="animation"></p><p>使用animation，定义一个函数，以及相关参数，在通过@keyframe规则，创建动画</p><h1 id="CSS和JS实现动画的方式"><a href="#CSS和JS实现动画的方式" class="headerlink" title="CSS和JS实现动画的方式"></a>CSS和JS实现动画的方式</h1><p><strong>JS实现动画的方式</strong>：setInterval，requestAnimationFrame（类似setInterval）</p><p>它的主要思想是通过setInterval或setTimeout方法的回调函数来持续调用改变某个元素的CSS样式以达到元素样式变化的效果。</p><p>rAF：requestAnimationFrame是另一种Web API，原理与setTimeout和setInterval类似，都是通过javascript持续循环的方法调用来触发动画动作。但是requestAnimationFrame是浏览器针对动画专门优化形成的APi，在性能上比另两者要好。</p><p><strong>CSS实现动画</strong></p><p>1.css3的<code>transition</code>–设置样式的属性值是如何从一种状态平滑过渡到另外一种状态</p><p>2.css3的<code>transform</code>–应用于元素的2D或3D转换，可以用来设置元素的形状改变，如：rotate（旋转）、scale（缩放）、skew（扭曲）、translate（移动）和matrix（矩阵变形）<br>通常transform变化 和 transition过渡 是组合使用的<br>t；<br>3.css3的<code>animation</code>（animation属性+@keyframes）–由属性keyframes来完成逐帧动画的。通过对关键帧和循环次数的控制，页面标签元素会根据设定好的样式改变进行平滑过渡。而且关键帧状态的控制是通过百分比来控制的。</p><p>下面是一个动画示例：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>:red;</span><br><span class="line"><span class="attribute">position</span>:relative;</span><br><span class="line"><span class="attribute">animation</span>:myfirst <span class="number">5s</span>;</span><br><span class="line">-moz-<span class="attribute">animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Firefox */</span></span><br><span class="line">-webkit-<span class="attribute">animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">-o-<span class="attribute">animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> myfirst</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0%</span>   &#123;<span class="attribute">background</span>:red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line"><span class="number">25%</span>  &#123;<span class="attribute">background</span>:yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line"><span class="number">50%</span>  &#123;<span class="attribute">background</span>:blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line"><span class="number">75%</span>  &#123;<span class="attribute">background</span>:green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line"><span class="number">100%</span> &#123;<span class="attribute">background</span>:red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-moz-keyframes</span> myfirst /* Firefox */</span><br><span class="line">&#123;<span class="comment">/* 内容同上 */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> myfirst /* Safari <span class="keyword">and</span> Chrome */</span><br><span class="line">&#123;<span class="comment">/* 内容同上 */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-o-keyframes</span> myfirst /* Opera */</span><br><span class="line">&#123;<span class="comment">/* 内容同上 */</span>&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ddb0c7f919b415b8dc6de62d3affbb6~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>🚀🚀 更多基础知识总结可以⭐️关注我，后续会持续更新面试题总结和面筋~</p><p>⭐️⭐️ 最后祝各位正在准备秋招补招和春招的小伙伴面试顺利<del>，收割offer，我们一起加油吧🤝！还有就是快春节了，提前祝你新年快乐</del>❤ ❤ </p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「计算机网络」前端必备知识，看到就是赚到系列（下）</title>
      <link href="/posts/10112/"/>
      <url>/posts/10112/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络之应用层-HTTP、HTPS、DNS-下篇"><a href="#计算机网络之应用层-HTTP、HTPS、DNS-下篇" class="headerlink" title="计算机网络之应用层-HTTP、HTPS、DNS-下篇"></a>计算机网络之应用层-HTTP、HTPS、DNS-下篇</h1><p>⭐️⭐️这篇文章是一个我计算机网络复习的大汇总，由于内容太多了我把它分成了上下两篇来写，上一篇将传输层协议TCP、UDP，这一篇讲的是应用层协议HTTP、HTPS、DNS~~</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eec69c5ce8684475bbe0701e243ea716~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>  HTTP 是一个在客户端和服务器之间传输文字、图片、音频、视频等超文本数据的约定和规范。默认使用 80 端口，它使用 TCP 作为传 输层协议，保证了数据传输的可靠性。</p><h3 id="HTTP的特点？它有什么缺点？"><a href="#HTTP的特点？它有什么缺点？" class="headerlink" title="HTTP的特点？它有什么缺点？"></a>HTTP的特点？它有什么缺点？</h3><blockquote><p>特点： 端对端， 灵活可拓展，可靠， 无状态， 持久连接</p></blockquote><ul><li><p>HTTP协议是一种端对端的协议，也是一种请求/响应模式的协议。</p></li><li><p>灵活可扩展：一个是语义上的自由，只规定了基本格式，其它的各部分没有严格的限制；第二个它允许传输任意类型的数据对象，例如文本、图片、音频等，传输的类型由Content-Type加以标记。</p></li><li><p>可靠传输，HTTP 基于 TCP/IP，因此把这一特性继承了下来。</p></li><li><p>无状态，也就是说HTTP请求不具备保存之前发送过的请求或响应的功能，每一次请求都是独立无关的。</p></li><li><p>持久连接，HTTP1.1 以后默认采用的是持续的连接，持续连接下，TCP 连接默认不关闭，可以被多个请求复用，目前对于同一个域，大多数浏览器支持 同时建立 6 个持久连接。</p><blockquote><p>缺点：可能被窃听,篡改,遭遇伪装,无状态,队头阻塞</p></blockquote><ul><li><p>明文传输(不加密)，内容可能被窃听。</p></li><li><p>无法验证报文的完整性，内容可能被篡改。</p></li><li><p>不验证通信方的身份，有可能遭遇伪装。</p></li><li><p>无状态，它是缺点也是优点吧，分不同的场景。</p></li><li><p>队头阻塞。HTTP2多路复用解决问题</p></li><li><ul><li>HTTP/2 实现了多路复用，在一个连接里，客户端和服务器都可以同时发送多个请求或回 应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。</li></ul></li><li><ul><li>根源源于二进制分针：报文格式如今被拆分成了一个个二进制的帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。乱序的二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的<strong>请求报文</strong>和<strong>响应报文</strong>。</li></ul></li></ul></li></ul><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>  HTTP 请求报文（响应报文）的第一行叫做请求行（响应行），后面跟的首部字段，首部后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。</p><p>  请求行字段：方法字段、URL 字段和 HTTP 版本字段。</p><h3 id="方法字段"><a href="#方法字段" class="headerlink" title="方法字段"></a>方法字段</h3><p>  一般有 GET、POST、HEAD、PUT 和 DELETE<br>  GET：获取资源，幂等操作<br>  HEAD：获取报文首部，和GET很像但是不返回报文主体，幂等操作<br>  POST: 创建或更新资源，非幂等操作<br>  PUT: 创建或更新资源本身，幂等操作<br>  PATCH：对资源进行局部更新，非幂等操作<br>  DELETE：删除资源，和PUT功能相反，幂等操作<br>  OPTIONS：查询服务器端支持的HTTP方法种类<br>  CONNECT：建立连接隧道，用于代理服务器，幂等操作<br>  TRACE：追踪请求，查询发出去的请求是怎样被加工/篡改的，幂等操作。容易引发XST跨站追踪攻击。</p><h3 id="Post-和-Get-的区别？"><a href="#Post-和-Get-的区别？" class="headerlink" title="Post 和 Get 的区别？"></a>Post 和 Get 的区别？</h3><p>  （1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。</p><p>  （2）从缓存的角度，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</p><p>  （3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</p><p>  （4）从参数的角度上说，GET一般放在URL上传递参数，POST放在请求体里，更适合传递敏感信息。（还有就是 post 的参数传递支持更多的数据类型。GET 只能进行 URL 编码）</p><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p>响应行字段：版本号、状态码和原因短语</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>1xx: 表示目前是协议处理的中间状态，还需要后续操作。<code>101 Switching Protocols</code></p><p>2xx: 表示成功状态。<code>200 OK</code> <code>204 No Content</code> <code>206 Partial Content</code></p><p>3xx: 重定向状态，资源位置发生变动，需要重新请求。<code>301 Moved Permanently</code>  <code>302 Found</code>  <code>303 See Other</code>  <code>304 Not Modefied</code>  <code>307 Temprary Redirect</code></p><blockquote><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码又出来了两个303和307。303明确表示客户端应当采用get方法获取资源，他会把POST请求变为GET请求进行重定向。307会遵照浏览器标准，不会从post变为get。</p></blockquote><p>4xx: 请求报文有误。<code>400 Bad Request</code>  <code>401 Unauthorized</code>  <code>403 Forbidden</code>  <code>404 Not Found</code></p><p>5xx: 服务器端发生错误。<code>500 Internal Server Error</code>  <code>501 Not Implemented</code>  <code>502 Bad GateWay</code>  <code>503 Service Unavailable</code></p><h3 id="HTTP的部首"><a href="#HTTP的部首" class="headerlink" title="HTTP的部首"></a>HTTP的部首</h3><p>HTTP的部首挺多的，都记下来没必要，我只挑了比较重点的列出来：</p><p>通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部</p><ul><li>Cache-Control  控制缓存 </li><li>Connection 连接管理、逐条首部 </li><li>Transfor-Encoding 报文主体的传输编码格式 </li></ul><p>请求首部字段（Reauest Header Fields）:客户端向服务器发送请求的报文时使用的首部</p><ul><li>Accept 客户端或者代理能够处理的媒体类型 </li><li>If-Match 比较实体标记（ETage） </li><li>If-None-Match 比较实体标记（ETage）与 If-Match相反 </li><li>If-Modified-Since 比较资源更新时间（Last-Modified）</li><li>If-Unmodified-Since比较资源更新时间（Last-Modified），与 If-Modified-Since相反 </li><li>If-Rnages 资源未更新时发送实体byte的范围请求</li><li>Range 实体的字节范围请求 </li><li>Authorization web的认证信息 </li><li>Host 请求资源所在服务器 </li><li>User-Agent 客户端程序信息 </li></ul><p>响应首部字段（Response Header Fields）:从服务器向客户端响应时使用的字段</p><ul><li>Accept-Ranges 能接受的字节范围</li><li>Location 令客户端重定向的URI </li><li>ETag 能够表示资源唯一资源的字符串 </li><li>Server 服务器的信息 </li></ul><p>实体首部字段（Entiy Header Fields）:针对请求报文和响应报文的实体部分使用首部</p><ul><li>Allow 资源可支持http请求的方法 </li><li>Last-Modified 资源最后的修改资源 </li><li>Expires 实体主体的过期资源 </li></ul><h3 id="HTTP-2协议"><a href="#HTTP-2协议" class="headerlink" title="HTTP/2协议"></a>HTTP/2协议</h3><blockquote><p> HTTP/2的新特性:二进制协议、 多路复用、数据流、 头信息压缩、服务器推送</p></blockquote><p>  <strong>二进制协议</strong><br>  HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</p><p>  <strong>多路复用</strong><br>  HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回 应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。</p><p>  <strong>数据流</strong><br>  HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每 个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p><p>  <strong>头信息压缩</strong><br>  HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是 重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。</p><p>  <strong>服务器推送</strong><br>  HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。</p><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>  其实也就是弥补了HTTP的缺点：<br>  数据隐私性，内容经过加密；（加解密）<br>  数据完整性，内容经过完整性校验；（数字签名）<br>  身份认证，第三方无法伪装客户端/服务器的身份（数字证书）</p><h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><p>  HTTPS标准端口443，HTTP是80<br>  HTTPS在浏览器上会显示绿色的安全锁，而HTTP没有<br>  弥补了HTTP的缺点，数据的隐私性、完整性、身份验证。也就是更加安全。</p><h3 id="混合加密机制-HTTPS采用的方式"><a href="#混合加密机制-HTTPS采用的方式" class="headerlink" title="混合加密机制(HTTPS采用的方式)"></a>混合加密机制(HTTPS采用的方式)</h3><p>  结合两种加密方式的优点，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段使用对称加密方式。</p><p>  流程：发送密文的一方使用”对方的公钥”进行加密处理”对称的密钥”，然后对方接收到之后使用自己的私钥进行解密得到”对称的密钥”，这就达到了确保交换的密钥是安全的前提下使用对称加密方式进行通信。</p><h3 id="数字签名、数字证书流程（两张图搞定）"><a href="#数字签名、数字证书流程（两张图搞定）" class="headerlink" title="数字签名、数字证书流程（两张图搞定）"></a>数字签名、数字证书流程（两张图搞定）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d324ec2bcd244b70a3a7af69ecb18fa7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e6f97b3291649fa81b9d4115181464c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="主流TLS1-2版本的握手，即ECDHE握手过程？"><a href="#主流TLS1-2版本的握手，即ECDHE握手过程？" class="headerlink" title="主流TLS1.2版本的握手，即ECDHE握手过程？"></a>主流TLS1.2版本的握手，即ECDHE握手过程？</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">A：client_random、<span class="variable constant_">TSL</span>版本号、加密套件列表-&gt;B</span><br><span class="line">B：确认版本号后，server_random、server_params、需使用的加密套件、以及自己的证书-&gt;A</span><br><span class="line">A：证书验证，成功则client_params -&gt;B</span><br><span class="line">A：与此同时，计算出一个pre_random，<span class="title function_">ECDHE</span>(client_params, server_params) = per_random</span><br><span class="line">A：将得到的三个随机数通过一个伪随机函数计算得出最终的secret，后续通信所要用的对称密钥,并发送收尾信息给B</span><br><span class="line">B：服务器也会使用和客户端一样的方式生成secret，并且也会发送一个收尾消息给客户端。</span><br><span class="line"><span class="variable constant_">AB</span>：都收到收尾消息并验证成功后，握手就结束了。后面开始用这个secret对称密钥加密报文进行传输。、</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细过程：</p><ol><li><p>客户端在第一次发送HTTPS请求的时候，会把 client_random、TSL版本号、加密套件列表发送给服务器</p></li><li><p>服务器在接收到之后确认TSL的版本号，同时发送 server_random、server_params、需要使用的加密套件、以及自己的证书给客户端</p><ol start="3"><li>客户端在收到这些信息之后，首先是会对服务器的证书进行验证(也就是题目7)，若是验证成功则会传递一个 client_params 给服务器</li></ol></li><li><p>与此同时客户端会通过ECDHE算法计算出一个pre_random，其中是传入了两个参数，一个是 client_params，还一个是 server_params。(也就是说：ECDHE(client_params, server_params) = per_random)</p><ol start="5"><li><p>这时候客户端就同时拥有了 client_random、server_random、pre_random，它会将这三个参数通过一个伪随机函数计算得出最终的secret，这个secret就是它们后续通信所要用的对称密钥。</p></li><li><p>而在客户端生成完secret之后，会给服务器发送一个收尾消息，告诉服务器之后都要用对称加密，且对称加密的算法是用第一次约定好的。</p></li><li><p>服务器它在接收到刚刚传递过来的client_params之后，也会使用和客户端一样的方式生成secret，并且也会发送一个收尾消息给客户端。</p></li><li><p>当双方都收到收尾消息并验证成功之后，握手就结束了。后面开始用这个secret对称密钥加密报文进行传输。</p></li></ol></li></ol><h3 id="描述RSA握手"><a href="#描述RSA握手" class="headerlink" title="描述RSA握手"></a>描述RSA握手</h3><ol><li><p>客户端首先向服务端发送一个HTTPS请求</p></li><li><p>服务端会把事先配置好的公钥证书随着其它的信息返回给客户端</p></li><li><p>客户端在收到服务端发来的证书之后进行验证，验证的过程参考数字证书验证，会得到服务端的信息以及它的公钥</p></li><li><p>验证成功之后会用伪随机函数计算出一个加密所需要的对称密钥(secret)，并且用服务端的公钥加密这个对称密钥发送给服务端</p></li><li><p>服务端再用自己的私钥解密刚刚的消息，得到里面的对称密钥。此时服务端和客户端都有了对称密钥。</p></li><li><p>后面的传输都会用这个 secret 进行对称密钥加解密传输</p></li></ol><blockquote><p>与TLS握手的区别？<br>最主要的：RSA不具备向前安全性，ECDHE有；一次破解并不影响历史信息的性质就是向前安全性。</p></blockquote><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>可能还有一些我参考到的忘记了，我把我记得的都列出来，再次感谢~</p><blockquote><ul><li><strong>一百个Chocolate</strong> ：<a href="https://github.com/Chocolate1999">https://github.com/Chocolate1999</a></li><li><strong>CavsZhouyou</strong>：<a href="https://github.com/CavsZhouyou">https://github.com/CavsZhouyou</a></li><li><strong>神三元</strong>：（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</li><li><strong>LinDaiDai_霖呆呆</strong>：Shutdown HTTP系列文章</li><li><strong>寻找海蓝96</strong>:面试官（9）：可能是全网最全的http面试答案</li></ul></blockquote><p>⭐️⭐️ 都看到这了，求一个赞不过分吧 ，能一键三连的话那就更好啦 ❀ ，你的支持是我继续写作的动力 ❀</p><p>⭐️ 后续应该会补上遇到的网络面试题，可能也会出一些小知识点的总结比如cookie，反正这篇下不是终点啦~</p><p>最后祝大家身体健康，天天开心，事事顺心，心想事成，暴富暴富~~</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「计算机网络」前端必备知识，看到就是赚到系列（上）</title>
      <link href="/posts/521/"/>
      <url>/posts/521/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-传输层协议专项复习-上"><a href="#计算机网络-传输层协议专项复习-上" class="headerlink" title="计算机网络-传输层协议专项复习(上)"></a>计算机网络-传输层协议专项复习(上)</h1><p>⭐️⭐️这篇文章是一个我计算机网络复习的大汇总，参考了许多文章，也非常感谢大佬对我这篇文章的帮助，由于内容太多了我把它分成了上下两篇来写，这一篇将传输层协议TCP、UDP</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c7ecd88d5c845779a8ef4c00a788b35~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><blockquote><p>以上是这篇文章的思维导图，个人建议复习的小伙伴都可以搞一个，方便自己复习用~</p></blockquote><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>首先</p><ul><li><strong>TCP是面向连接的、可靠的、基于字节流</strong>的传输层协议</li><li><strong>UDP是一个面向无连接</strong>的传输层协议</li></ul><p><strong>详细的区别：</strong></p><p>1、tcp是基于连接的，可靠性高；udp是基于无连接的，可靠性较低；</p><p>2、由于tcp是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差；由于协议所致，安全性较高；而udp无连接，无建立连接的过程，因而实时性较强，安全略差；</p><p>3、在传输相同大小的数据时，tcp首部开销20字节；udp首部开销只有8个字节，tcp报头比udp复杂，故实际包含的用户数据较少。tcp无丢包，而udp有丢包，故tcp开销大，udp开销较小；</p><p>4、每条tcp连接只能是点到点的；udp支持一对一、一对多、多对一、多对多的交互通信。</p><p><strong>应用场景的区别：</strong></p><ul><li>由于TCP和UDP的特点，如果对实时性要求高和高速传输的场景下需要使用UDP；</li><li>如果需要传输大量数据且对数据可靠性要求高的场景使用TCP；</li><li>在可靠性要求低追求效率的情况使用UDP；</li></ul><h2 id="TCP三大核心："><a href="#TCP三大核心：" class="headerlink" title="TCP三大核心："></a>TCP三大核心：</h2><ul><li><strong>面向连接</strong>；所谓面向连接，指的是客户端与服务端的连接，在双方互相通信之前，TCP需要三次握手简历连接，而UDP没有相应的简历连接的过程<ul><li><strong>可靠性</strong>；TCP可靠性主要体现在<strong>1有状态2可控制</strong></li><li><strong>面向字节流</strong>；UDP数据传输基于数据报，仅仅是继承了IP层的特性，而TCP为维护状态，将IP包变成了字节流</li></ul></li></ul><blockquote><p><strong>有状态</strong>；TCP会精准记录哪些数据发送了，被对方接受了，哪些没有，而保证数据按序到达，不允许差错<br><strong>可控制</strong>；意识到丢包或者网络环境差，TCP根据具体情况调整自己的行为，控制自己发送速度或重发</p></blockquote><p><code>而UDP不可靠原因：无状态，不可控</code></p><hr><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><blockquote><p>一次握手过程及变化、为什么不是两次、为什么不是四次、握手过程中可以携带数据吗、同时发起挥手会怎样</p></blockquote><h2 id="TCP三次握手的过程"><a href="#TCP三次握手的过程" class="headerlink" title="TCP三次握手的过程"></a>TCP三次握手的过程</h2><p>三次握手要确认双方的两样能力：发送能力与接收的能力。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25e6385d6e244d1184e29e765b91edb6~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>最开始双方都属于CLOSED状态。然后服务器开始监听某个端口，进入LISTEN状态。</p><ul><li>客户端注重发起连接，发送SYN，自己变成了SYN-SENT状态</li><li>服务端收到，返回SYN和ACK（对应客户端发来的SYN），自己变成了SYN-RECD</li><li>客户端再发送ACK给服务端，自己变成ESTABLISHED（established）状态；服务端收到ACK之后，也变成这个状态</li></ul><h2 id="为什么不是两次？"><a href="#为什么不是两次？" class="headerlink" title="为什么不是两次？"></a>为什么不是两次？</h2><p>根本原因：无法确认客户端的接收能力。<br>可能出现的问题是，两次握手，服务端只要接收到然后发送相应的数据包，就  <code>默认连接</code> 了 ，但是事实上现在客户端可能已经断开连接了，这样也就带来了连接资源的浪费<br>``</p><h2 id="为什么不是四次？"><a href="#为什么不是四次？" class="headerlink" title="为什么不是四次？"></a>为什么不是四次？</h2><p>因为三次已经足够确认双方的发送和接收的能力了，四次以及四次以上当然就没必要啦</p><h2 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h2><p>可以，但是只有第三次，此时的<code>established</code>状态相对安全并且够确认服务器的接收发送能力。</p><p>而不能在第一次握手携带数据是为了防止黑客在<code>syn</code>中放入大量数据造成服务器资源的消耗。</p><hr><h1 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h1><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79d7cbfd9ffd47a595c4ece46858c040~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><ul><li>首先客户端主动关闭，向服务器发<code>FIN</code>报文</li><li>服务端接收后通知应用进程并向客户端发送<code>ACK</code>确认<ul><li>服务端处理完后被动关闭再次向客户端发送<code>FIN</code>以及<code>ACK</code>，进入<code>LAST-ACK</code>状态，</li></ul></li><li>客户端收到服务端发来的<code>FIN</code>后，发送 <code>ACK</code> 给服务端。在等待<code>2MSL</code>后进入<code>CLOSED</code>状态</li></ul><blockquote><p>注意了，这个时候，客户端需要等待两个 <code>MSL</code>(Maximum Segment Lifetime，报文最大生存时间),在这段时间内如果客户端没有收到服务端的重发请求，那么表示 <code>ACK</code>成功到达，挥手结束，否则客户端重发 ACK。</p></blockquote><h3 id="为什么要等待-2-MSL"><a href="#为什么要等待-2-MSL" class="headerlink" title="为什么要等待 2 MSL?"></a>为什么要等待 2 MSL?</h3><ul><li>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端</li><li>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</li></ul><h2 id="为什么是四次挥手而不是三次？"><a href="#为什么是四次挥手而不是三次？" class="headerlink" title="为什么是四次挥手而不是三次？"></a>为什么是四次挥手而不是三次？</h2><ul><li>因为服务端在接收到<code>FIN</code>, 往往不会立即返回<code>FIN</code>, 必须等到服务端所有的报文都发送完毕了，才能发<code>FIN</code>。</li><li>因此先发一个ACK表示已经收到客户端的<code>FIN</code>，延迟一段时间才发<code>FIN</code>。这就造成了四次挥手。<br><code>如果是三次挥手会有什么问题？</code><br>等于说服务端将<code>ACK</code>和<code>FIN</code>的发送合并为一次挥手，长时间的延迟可能会导致客户端误以为<code>FIN</code>没有到达客户端，从而让客户端不断的重发<code>FIN</code>。</li></ul><h2 id="同时发起挥手"><a href="#同时发起挥手" class="headerlink" title="同时发起挥手"></a>同时发起挥手</h2><p>在发送方给接收方发SYN报文的同时，接收方也给发送方发SYN报文<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1abf3cf575147bbaee5f628f93680b9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>上图就是解释同时打开情况下的状态变迁。</p><ul><li>发完SYN，两者的状态都变为SYN-SENT。</li><li>在各自收到对方的SYN后，两者状态都变为SYN-REVD。</li><li>接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。</li></ul><h1 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h1><blockquote><p>半连接队列、全连接队列、SYN Flood攻击过程、如何应对这种攻击</p></blockquote><h4 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h4><p>当客户端发送<code>SYN</code>到服务端，服务端收到以后回复<code>ACK</code>和<code>SYN</code>，状态由<code>LISTEN</code>变为<code>SYN_RCVD</code>，此时这个连接就被推入了<strong>SYN队列</strong>，也就是半连接队列。</p><h4 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h4><p>当客户端返回<code>ACK</code>, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。</p><h4 id="SYN-Flood-攻击原理"><a href="#SYN-Flood-攻击原理" class="headerlink" title="SYN Flood 攻击原理"></a>SYN Flood 攻击原理</h4><p>SYN Flood 属于<strong>典型的 DoS/DDoS 攻击</strong>。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:</p><ul><li>处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。</li><li>由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。</li></ul><h4 id="如何应对-SYN-Flood-攻击？"><a href="#如何应对-SYN-Flood-攻击？" class="headerlink" title="如何应对 SYN Flood 攻击？"></a>如何应对 SYN Flood 攻击？</h4><ol><li><strong>增加 SYN 连接</strong>，也就是增加半连接队列的容量。</li><li><strong>减少 SYN + ACK 重试次数</strong>，避免大量的超时重发。 </li><li><strong>利用 SYN Cookie技术</strong>，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证Cookie 合法之后才分配连接资源。</li></ol><h2 id="半连接队列和-SYN-Flood-攻击的关系"><a href="#半连接队列和-SYN-Flood-攻击的关系" class="headerlink" title="半连接队列和 SYN Flood 攻击的关系"></a>半连接队列和 SYN Flood 攻击的关系</h2><ul><li>三次握手前，服务端的状态从<code>CLOSED</code>变为<code>LISTEN</code>, 同时在内部创建了两个队列：<br>半连接队列和全连接队列，即SYN队列和ACCEPT队列。</li><li>半连接队列是当客户端发送<code>SYN</code>到服务端，服务端收到以后回复<code>ACK</code>和<code>SYN</code>，状态由<code>LISTEN</code>变为<code>SYN_RCVD</code>，此时这个连接就被推入了<strong>SYN队列</strong></li><li>SYN Flood在短时间内伪造大量不存在的 IP地址，并向服务端疯狂发送SYN。处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。</li></ul><hr><h1 id="剖析TCP报文首部字段"><a href="#剖析TCP报文首部字段" class="headerlink" title="剖析TCP报文首部字段"></a>剖析TCP报文首部字段</h1><blockquote><p>源端口、目标端口、序列号、ISN：ISN是如何计算的，为什么、确认号标记位窗口大小校验和可选项</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36da4a268c894963aa3c3e959d8cc4a5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><ul><li>源端口、目标端口</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如何标识唯一标识一个连接？答案是 TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。</span><br><span class="line"></span><br><span class="line">那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。</span><br></pre></td></tr></table></figure><ul><li>序列号<br>即Sequence number, 指的是本报文段第一个字节的序列号。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">序列号在 TCP 通信的过程中有两个作用:</span><br><span class="line"></span><br><span class="line">在 SYN 报文中交换彼此的初始序列号。</span><br><span class="line">保证数据包按正确的顺序组装。</span><br></pre></td></tr></table></figure><ul><li>ISN</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">即Initial Sequence Number（初始序列号）,在三次握手的过程当中，双方会用过SYN报文来交换彼此的 ISN。</span><br><span class="line">ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？</span><br><span class="line">如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。</span><br><span class="line">而动态增长的 ISN 大大提高了猜测 ISN 的难度。</span><br></pre></td></tr></table></figure><ul><li><p>确认号<br>即ACK(Acknowledgment number)。用来<strong>告知对方下一个期望接收的序列号</strong>，小于ACK的所有字节已经全部收到。</p></li><li><p>标记位<br>常见的标记位有SYN,ACK,FIN,RST,PSH。</p></li></ul><ul><li><p>SYN 和 ACK 已经在上文说过，后三个解释如下:<br><strong>FIN</strong>： 即 Finish，表示发送方准备断开连接。<br><strong>RST</strong>：即 Reset，用来强制断开连接。<br><strong>PSH</strong>： 即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。</p></li><li><p>窗口大小<br>占用两个字节，实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。</p></li><li><p>校验和<br>占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。</p></li><li><p>可选项<br>常用的可选项有以下几个:<br>TimeStamp: TCP 时间戳，后面详细介绍。<br>MSS: 指的是 TCP 允许的从对方接收的最大报文段。<br>SACK: 选择确认选项。<br>Window Scale： 窗口缩放选项。</p></li></ul><p><code>不要死记，只要有个印象就行</code></p><hr><h2 id="TCP快速打开（TFO）原理"><a href="#TCP快速打开（TFO）原理" class="headerlink" title="TCP快速打开（TFO）原理"></a>TCP快速打开（TFO）原理</h2><blockquote><p>首轮三次握手、之后的三次握手、TFO优势</p></blockquote><h2 id="TFO-流程"><a href="#TFO-流程" class="headerlink" title="TFO 流程"></a>TFO 流程</h2><h4 id="首轮三次握手"><a href="#首轮三次握手" class="headerlink" title="首轮三次握手"></a>首轮三次握手</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">就是第二次握手的时候不是立即返回SYN+ACK了，</span><br><span class="line">而是返回计算得到的`SYN cookie`,</span><br><span class="line">放在TCP报文的Fast Open（快速打开）选项中，</span><br><span class="line">客户端拿到cookie将其缓存</span><br></pre></td></tr></table></figure><ul><li>首先客户端<strong>发送SYN</strong>给服务端，服务端接收到。</li><li><code>注意哦！现在服务端不是立刻回复 SYN + ACK</code>，而是通过<strong>计算</strong>得到一个<strong>SYN Cookie</strong>, 将这个Cookie放到 TCP 报文的 <strong>Fast Open</strong>选项中，然后才给客户端返回。</li><li>客户端拿到这个 <strong>Cookie 的值缓存</strong>下来。后面正常完成三次握手。</li></ul><p>首轮三次握手就是这样的流程。而后面的三次握手就不一样啦！</p><h4 id="后面的三次握手"><a href="#后面的三次握手" class="headerlink" title="后面的三次握手"></a>后面的三次握手</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">客户端发送Cookie+SYN+HTTP请求，</span><br><span class="line">服务端验证合法，先确认，返回SYN+ACK，`返回HTTP响应`</span><br><span class="line">客户端传ACK</span><br></pre></td></tr></table></figure><ul><li><p>在后面的三次握手中，客户端会将之前<strong>缓存的 Cookie、SYN 和HTTP请求</strong>(是的，你没看错)发送给服务端，服务端<strong>验证</strong>了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回SYN + ACK。</p></li><li><p><code>重点来了，现在服务端能向客户端发 HTTP 响应了！</code>这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。</p></li><li><p>当然，客户端的ACK还得正常传过来，不然怎么叫三次握手嘛。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a8b21059b324777808046492d1bfdce~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><code>注意: 客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。</code></p></li></ul><p><strong>TFO 的优势</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">拿到Cookie验证通过就能返回HTTP请求了，</span><br><span class="line">利用了1个往返时延`RTT`提前进行数据传输</span><br></pre></td></tr></table></figure><p>TFO 的优势并不在与首轮三次握手，而<strong>在于后面的握手</strong>，在拿到客户端的 Cookie 并验证通过以后，可以<strong>直接返回 HTTP 响应</strong>，充分利用了1 个<strong>RTT</strong>(Round-Trip Time，往返时延)的时间<strong>提前进行数据传输</strong>，积累起来还是一个比较大的优势。</p><hr><h2 id="TCP时间戳作用"><a href="#TCP时间戳作用" class="headerlink" title="TCP时间戳作用"></a>TCP时间戳作用</h2><ul><li>计算往返时延RTT</li><li>防止序列号回绕的问题</li></ul><hr><h2 id="TCP超时重传算法"><a href="#TCP超时重传算法" class="headerlink" title="TCP超时重传算法"></a>TCP超时重传算法</h2><ul><li>经典方法</li><li>Jacobson / Karels 算法</li></ul><hr><h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><blockquote><p>TCP滑动窗口概念、流量控制过程</p></blockquote><p>流量控制要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。</p><p>具体是如何做的呢？举个例子：</p><ul><li>首先双方三次握手，初始化各自的窗口大小，均为 <strong>200</strong> 个字节。</li><li>假如当前发送端给接收端发送 <strong>100</strong> 个字节，那么此时对于发送端而言，<strong>可用窗口减少了 100</strong> 个字节。</li><li>现在这 100 个到达了接收端，被放到<strong>接收端的缓冲队列</strong>中。不过此时由于大量负载的原因，接收端处理不了这么多字节，<strong>只能处理 40</strong> 个字节，剩下的 <strong>60</strong> 个字节被<strong>留在了缓冲队列</strong>中。</li><li>上述是处理能力不够用啦的情况，意思你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，<strong>缩小 60</strong> 个字节，由 200 个字节变成了 140 字节，因为<strong>缓冲队列留下 60</strong>个字节没被拿走。</li><li>因此，<strong>接收端会在 ACK 的报文首部</strong>带上缩小后的滑动窗口 <strong>140</strong> 字节，发送端<strong>对应地调整</strong>发送窗口的大小为 <strong>140</strong> 个字节。</li><li>此时发送端情况是，<strong>已经发送且确认的部分增加 40</strong> 字节，<strong>右移 40</strong> 个字节，同时<strong>发送窗口缩小为 140</strong> 个字节。</li><li>下图：<strong>滑动窗口</strong>结构（发送端）<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3cd654efd1648978acd5ac69c0a7212~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br><code>还是搞不清，那你写一下画一下就想得明白了</code></li></ul><hr><h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><blockquote><p>慢启动、 拥塞避免、快速重传和快速恢复、基于丢包的拥塞控制点产生的问题–Google的BBR拥塞控制算法</p></blockquote><h2 id="说说-TCP-的拥塞控制？"><a href="#说说-TCP-的拥塞控制？" class="headerlink" title="说说 TCP 的拥塞控制？"></a>说说 TCP 的拥塞控制？</h2><ul><li>流量控制发生在发送端跟接收端之间</li><li>而TCP 的拥塞控制主要处理的问题是，整个网络环境，网络特别差，特别容易丢包的情况。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b60490e22384af8ae44753d9834ae60~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h6 id="对于拥塞控制来说，TCP每条连接都需要维护两个核心状态"><a href="#对于拥塞控制来说，TCP每条连接都需要维护两个核心状态" class="headerlink" title="对于拥塞控制来说，TCP每条连接都需要维护两个核心状态:"></a><code>对于拥塞控制来说，TCP每条连接都需要维护两个核心状态:</code></h6><ul><li><strong>拥塞窗口</strong>（Congestion Window，cwnd）:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">是指目前自己还能传输的数据量大小;</span><br><span class="line">接收窗口(rwnd)是接收端给的限制</span><br><span class="line">拥塞窗口(cwnd)是发送端的限制 发送窗口大小 = min(rwnd, cwnd)</span><br></pre></td></tr></table></figure><ul><li><strong>慢启动阈值</strong>（Slow Start Threshold，ssthresh）</li></ul><h6 id="涉及到的算法有这几个"><a href="#涉及到的算法有这几个" class="headerlink" title="涉及到的算法有这几个:"></a><code>涉及到的算法有这几个:</code></h6><ul><li><strong>慢启动</strong></li></ul><p>采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动;</p><p>过程：<br>1.首先，三次握手，双方宣告自己的接收窗口大小</p><p>2.双方初始化自己的拥塞窗口(cwnd)大小</p><p>3.在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，拥塞窗口 翻倍。</p><p>如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，拥塞窗口 变为 20，<br>第二轮变为 40，第三轮变为 80，依次类推。直到达到慢启动阈值</p><ul><li><strong>拥塞避免</strong></li></ul><p>达阈值后，如何来控制拥塞窗口的大小；<br>原来每收到一个 ACK，拥塞窗口加1，现在到达阈值了，拥塞窗口只能加: 1/拥塞窗口<br>以前一轮 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。</p><p><code>慢启动和拥塞避免是一起作用的，是一体的。</code></p><ul><li><strong>快速重传和快速恢复</strong></li></ul><p><strong>快速重传</strong><br>如果发生了丢包，数据不是按序到达，接收端则重复发送之前的ACK<br>比如第5个包丢了，即使第6、7个包到达的接收端，接收端也一律返回第4个包的ACK。<br>收到 3 个重复的 ACK ，意识到丢包，马上重传；<br><strong>选择性重传</strong><br>ACK 报文SACK属性，通过left edge和right edge已经收到区间<br><strong>快速恢复</strong><br>发送端收到三次重复ACK之后，发现丢包觉得现网络已经有些拥塞了，会进入快速恢复阶段<br>发送端如下改变：<br>拥塞阈值降低为 cwnd 的一半、cwnd 的大小变为拥塞阈值、cwnd 线性增加</p><h3 id="结合图片更好理解："><a href="#结合图片更好理解：" class="headerlink" title="结合图片更好理解："></a>结合图片更好理解：</h3><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee7c226270b64ce0906de02128b76e02~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><blockquote><p>首先慢开始，拥塞窗口买次翻倍直到达到慢启动阈值，进入拥塞避免，拥塞窗口每次加一，遇到超时的情况进入快速重传，拥塞阈值降为拥塞窗口的一半，重新慢启动和拥塞避免，当再收到三个重复的ack时会进入块恢复阶段</p></blockquote><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>可能还有一些我参考到的忘记了，我把我记得的都列出来，再次感谢~</p><blockquote><ul><li><strong>一百个Chocolate</strong> ：<a href="https://github.com/Chocolate1999">https://github.com/Chocolate1999</a></li><li><strong>CavsZhouyou</strong>：<a href="https://github.com/CavsZhouyou">https://github.com/CavsZhouyou</a></li><li><strong>神三元</strong>：(建议收藏)TCP协议灵魂之问，巩固你的网路底层基础、(建议收藏)TCP协议灵魂之问，巩固你的网路底层基础</li><li><strong>LinDaiDai_霖呆呆</strong>：Shutdown HTTP系列文章</li></ul></blockquote><p>⭐️⭐️ 都看到这了，求一个赞不过分吧 ，能一键三连的话那就更好啦 ❀ ，你的支持是我继续写作的动力<br>最后再附上我的迟到的新年祝福：祝大家身体健康，天天开心，事事顺心，心想事成，暴富暴富~~</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JS刷题之路-递归回溯（上篇）」和我一起系统的刷题吧（内附思维导图）</title>
      <link href="/posts/656/"/>
      <url>/posts/656/</url>
      
        <content type="html"><![CDATA[<h1 id="JS刷题之路-递归回溯（上篇）"><a href="#JS刷题之路-递归回溯（上篇）" class="headerlink" title="JS刷题之路-递归回溯（上篇）"></a>JS刷题之路-递归回溯（上篇）</h1><p><font color=#999AAA >递归与回溯的题就不像栈的题那么好刷了，差点就鸽了，看到有催更，这不我啪的一下赶出了递归与回溯的JS上篇；递归与回溯是基础，有了基础才好在下一篇刷二叉树~</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e1df2cb1fe94ee3858d02dfc229599a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p> 获取高清PDF，请在微信公众号【小狮子前端】回复【LeetCode】，一起刷题或者交流学习可以加Q群【666151691】</p><p><font color=#999AAA>思维导图相较于上篇我在递归与回溯上加了分类，获得原作者的许可了；在这一篇呢讲的相对于简单一些，后续持续加更下一篇，递归与回溯（下）进阶~~<br></font></p></blockquote><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><p><font color=#999AAA >先搞几道开胃小菜，热热身</p><h1 id="一、热身题"><a href="#一、热身题" class="headerlink" title="一、热身题"></a>一、热身题</h1><h2 id="16-11-跳水板"><a href="#16-11-跳水板" class="headerlink" title="16.11.跳水板"></a>16.11.跳水板</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/diving-board-lcci/">16.11.跳水板</a></li></ul><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p><p>返回的长度需要从小到大排列。</p><p>示例 1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter = 1</span><br><span class="line">longer = 2</span><br><span class="line">k = 3</span><br><span class="line">输出： [3,4,5,6]</span><br><span class="line">解释：</span><br><span class="line">可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt; shorter &lt;= longer</span><br><span class="line">0 &lt;= k &lt;= 100000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>总有k+1个结果，结果就是短板长度*k-i+长版长度i<br>以题目示例<code>shorter</code> = 1  <code>longer</code>= 2  <code>k</code> = 3</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">k=<span class="number">3</span>   res[i]  =  结果计算</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span>   <span class="number">0</span>     <span class="number">1</span>*<span class="number">3</span> + <span class="number">2</span>*<span class="number">0</span>    <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span>   <span class="number">1</span>     <span class="number">1</span>*<span class="number">2</span> + <span class="number">2</span>*<span class="number">1</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span>   <span class="number">2</span>     <span class="number">1</span>*<span class="number">1</span> + <span class="number">2</span>*<span class="number">2</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span>   <span class="number">4</span>     <span class="number">1</span>*<span class="number">0</span> + <span class="number">2</span>*<span class="number">3</span>    <span class="number">6</span></span><br><span class="line">     </span><br></pre></td></tr></table></figure><p>挺简单的：只需要注意这个特殊情况：<br>1<br>1<br>100000</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">shorter</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">longer</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> divingBoard = <span class="keyword">function</span> (<span class="params">shorter, longer, k</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * k=3     res</span></span><br><span class="line"><span class="comment">     * 1 1 1   0     1*3 + 2*0    3</span></span><br><span class="line"><span class="comment">     * 1 1 2   1     1*2 + 2*1    4</span></span><br><span class="line"><span class="comment">     * 1 2 2   2     1*1 + 2*2    5</span></span><br><span class="line"><span class="comment">     * 2 2 2   4     1*0 + 2*3    6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">if</span> (shorter === longer &amp;&amp; k) &#123;</span><br><span class="line">        res[<span class="number">0</span>] = k * shorter;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            res[i] = shorter * (k - i) + longer * i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1291-顺次数"><a href="#1291-顺次数" class="headerlink" title="1291.顺次数"></a>1291.顺次数</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/sequential-digits/">1291.顺次数</a></li></ul><p>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。</p><p>请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：low = 100, high = 300</span><br><span class="line">输出：[123,234]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：low = 1000, high = 13000</span><br><span class="line">输出：[1234,2345,3456,4567,5678,6789,12345]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 &lt;= low &lt;= high &lt;= 10^9</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一：穷举<br>注意：出来的结果是要排序的<br><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">low</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">high</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sequentialDigits = <span class="keyword">function</span> (<span class="params">low, high</span>) &#123;</span><br><span class="line">    <span class="comment">// return low.toString().split(&#x27;&#x27;);</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示：10 &lt;= low &lt;= high &lt;= 10^9</span></span><br><span class="line"><span class="comment">     * 「顺次数」不是很多，穷举吧</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> res = [],</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> n = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            n = n * <span class="number">10</span> + j;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= low &amp;&amp; n &lt;= high) &#123;</span><br><span class="line">                res[index++] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a-b;&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：<br>来自<a href="https://github.com/Chocolate1999">Chocolate</a>：上面的方法虽然说也没有遍历太多数但是还是太耗时了，并且有很多没有必要遍历，可以剪枝</p><p>先求出最小值和最大值对应字符串的长度，即求出我们能枚举的数字的长度范围。</p><p>然后我们的起点的最小值从 1 开始，起点的最大值从 10-len 开始。</p><blockquote><p>为什么是 10-len？举例说明，示例1给的是 [100,300]范围的值，那么可枚举的长度 len 为 3，起点的最大值就位 10 - 3 = 7。那么此时顺次数为 789 但是不在我们区间范围内，舍弃。然后8、9开头的数字就不需要枚举了。 这样，我们就能剪掉一部门数据了。</p></blockquote><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">low</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">high</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sequentialDigits = <span class="keyword">function</span>(<span class="params">low, high</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">let</span> lowLen = low.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> highLen = high.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=lowLen;i&lt;=highLen;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">let</span> num = j</span><br><span class="line">            str += num</span><br><span class="line">            <span class="keyword">let</span> k = i-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">                num++</span><br><span class="line">                str += num</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> ans = <span class="built_in">parseInt</span>(str)</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;=low &amp;&amp; ans&lt;=high)&#123;</span><br><span class="line">                res.<span class="title function_">push</span>(ans)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、矩阵"><a href="#二、矩阵" class="headerlink" title="二、矩阵"></a>二、矩阵</h1><h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a>59. 螺旋矩阵 II</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></li></ul><p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>解题关键：边界思想<br>首先定义上下左右四个边界</p><p>从左边界往右边界走（<code>123</code>）上边界下移（<code>up++</code>）</p><p>然后从上往下走（<code>45</code>）（此时没有3是因为<code>up</code>加后变成1了）右边界左移（<code>right- -</code>）</p><p>然后从右往左走（<code>67</code>）（没5因为right- -了）下边界上移（<code>down- -</code>）</p><p>然后从下往上走（<code>8</code>）（没7没1因为上下边界）左边界右移（<code>left++</code>）</p><p>最后跳出循环条件：值小于等于n*n</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 0  1(0,0) 2(0,1) 3(0,2)   </span></span><br><span class="line"><span class="comment">     * 1  8(1,0) 9(1,1) 4(1,2)</span></span><br><span class="line"><span class="comment">     * 2  7(2,0) 6(2,1) 5(2,2)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> up = <span class="number">0</span>,</span><br><span class="line">        down = n - <span class="number">1</span>,</span><br><span class="line">        left = <span class="number">0</span>,</span><br><span class="line">        right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= n * n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123; <span class="comment">//左到右 最上添加一行数据-&gt;  上边界改变</span></span><br><span class="line">            res[up][i] = cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        up++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = up; i &lt;= down; i++) &#123; <span class="comment">//从上到下 -&gt; 改变右边界</span></span><br><span class="line">            res[i][right] = cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt;= left; i--) &#123; <span class="comment">//从右到左 -&gt; 改变下边界</span></span><br><span class="line">            res[down][i] = cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        down--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = down; i &gt;= up; i--) &#123; <span class="comment">//从上到下 -&gt; 改变左边界</span></span><br><span class="line">            res[i][left] = cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></li></ul><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>看懂上一题之后，这道题就很简单了</p><p>按上题的方法遍历，用res储存值。</p><p>注意的是：m与n不相等可能造成它会多走，分析一下为什么，以示例2为例：</p><p>走到7是可以的（此时up为1，right为2，down为1，而<code>left</code>为1），接着还会走到6，可以想象一下边界走向，7往左碰壁，往下碰壁往右遍历到6，往上碰壁，然后跳出循环</p><p>为了解决这个问题可以有很多解决方法（这里写两个）：</p><ol><li>暴力—-我直接把多的在最终时去除</li><li>在循环里加if条件语句：if(res.length === n*m) break  可以在每个位置都加，也可以找到关键位置加，由于最后一项都是多的一行或者一列，所以加在第二段之后</li></ol><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="keyword">function</span> (<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [],</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> n = matrix.<span class="property">length</span>,</span><br><span class="line">        m = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> up = <span class="number">0</span>,</span><br><span class="line">        down = n - <span class="number">1</span>,</span><br><span class="line">        left = <span class="number">0</span>,</span><br><span class="line">        right = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; n * m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            res[index++] = matrix[up][i];</span><br><span class="line">        &#125;</span><br><span class="line">        up++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = up; i &lt;= down; i++) &#123;</span><br><span class="line">            res[index++] = matrix[i][right];</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// if(res.length === n*m) break</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt;= left; i--) &#123;</span><br><span class="line">            res[index++] = matrix[down][i];</span><br><span class="line">        &#125;</span><br><span class="line">        down--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = down; i &gt;= up; i--) &#123;</span><br><span class="line">            res[index++] = matrix[i][left];</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(&quot;res:&quot;+res);</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">splice</span>(<span class="number">0</span>, n * m);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// console.log(&quot;return:&quot;+spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]]));</span></span><br></pre></td></tr></table></figure><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">54. 螺旋矩阵</a></li></ul><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>进阶:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</span><br><span class="line">一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</span><br><span class="line">你能想出一个常数空间的解决方案吗？</span><br></pre></td></tr></table></figure><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>解题关键：希望你使用原地算法使用常数空间解决问题</p><p>用常数空间解决意味着<code>不能使用额外空间</code></p><p>首先看一下使用额外空间的代码<br>首先找到0的行列，再将其行列置零。这并不是一个好方法，因为这意味着你必须用一个额外的空间去存0，不管是用什么数据结构。</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> setZeroes = <span class="keyword">function</span> (<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> m = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> across = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">var</span> vertical = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="comment">// 遍历每一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span>) &#123; <span class="comment">//找到0</span></span><br><span class="line">                across.<span class="title function_">add</span>(i);</span><br><span class="line">                vertical.<span class="title function_">add</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> across) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            matrix[k][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> vertical) &#123;</span><br><span class="line">        <span class="comment">//竖轴置零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[j][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>符合题目要求的原地算法：</p><blockquote><p>友情提示：Object.is不会对NaN，-0和进行类型转换，也不会进行特殊处理+0（使其具有与===那些特殊数值相同的行为）</p></blockquote><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> setZeroes = <span class="keyword">function</span> (<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">is</span>(matrix[i][j], <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">// 对行进行操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; matrix.<span class="property">length</span>; k++)</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="title class_">Object</span>.<span class="title function_">is</span>(matrix[k][j], <span class="number">0</span>) &amp;&amp; k !== i) matrix[k][j] = -<span class="number">0</span></span><br><span class="line">                <span class="comment">// 对列进行操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; matrix[<span class="number">0</span>].<span class="property">length</span>; k++)</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="title class_">Object</span>.<span class="title function_">is</span>(matrix[i][k], <span class="number">0</span>) &amp;&amp; k !== j) matrix[i][k] = -<span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="三、排列"><a href="#三、排列" class="headerlink" title="三、排列"></a>三、排列</h1><h2 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784.字母大小写全排列"></a>784.字母大小写全排列</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/letter-case-permutation/">784.字母大小写全排列</a></li></ul><p>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;a1b2&quot;</span><br><span class="line">输出：[&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br><span class="line"></span><br><span class="line">输入：S = &quot;3z4&quot;</span><br><span class="line">输出：[&quot;3z4&quot;, &quot;3Z4&quot;]</span><br><span class="line"></span><br><span class="line">输入：S = &quot;12345&quot;</span><br><span class="line">输出：[&quot;12345&quot;]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S 的长度不超过12。</span><br><span class="line">S 仅由数字和字母组成。</span><br></pre></td></tr></table></figure><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>一图胜千言，以a1b2为例图解：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c9807ce5e442eaa56bb5e8aeed1e02~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">S</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCasePermutation = <span class="keyword">function</span> (<span class="params">S</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">t, str</span>) =&gt; &#123; <span class="comment">//t是字母之前字符串，str是之后的</span></span><br><span class="line">        <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> res.<span class="title function_">push</span>(t); <span class="comment">//结束条件为遍历到最后一个字符，最后一个字符的str为&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> ch = str[<span class="number">0</span>]; <span class="comment">//保存一下当前值</span></span><br><span class="line">        <span class="keyword">let</span> nextStr = str.<span class="title function_">substr</span>(<span class="number">1</span>); <span class="comment">//传一个值，表示当前值的右边字符串</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(ch)) &#123;</span><br><span class="line">            <span class="comment">//为字母   分为两个分支  大写  小写</span></span><br><span class="line">            <span class="title function_">dfs</span>(t + ch.<span class="title function_">toLowerCase</span>(), nextStr); <span class="comment">//小写</span></span><br><span class="line">            <span class="title function_">dfs</span>(t + ch.<span class="title function_">toUpperCase</span>(), nextStr); <span class="comment">//大写</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//为数字  拼接一下就好了</span></span><br><span class="line">            <span class="title function_">dfs</span>(t + ch, nextStr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(<span class="string">&#x27;&#x27;</span>, S); <span class="comment">//刚开始 t=&#x27;&#x27; str=S</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></li></ul><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>经典的全排列问题，首先介绍经典解法，这里是另外一道题的全排列状态树，换汤不换药：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4d43fcace1e443db85ed8e8b055178a~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br> <strong>递归分析</strong>：<br>• 用一个数组a[n]来保存<code>1~ n</code>之间的<code>n</code>个自然数，对于i=1~ n，每次用<code>a[1]与a[i]交换</code>后，对<code>a[2]~a[n]</code>中的<code>n-1</code>个元素进行全排列，然后再<code>交换a[1]与a[i]</code>的值，使它<code>恢复</code>到此次排列前的状态<br>• 对于<code>a[3]~a[n]</code>区间内的<code>n-2</code>个元素进行全排列，然后再把交换的元素<code>交换回来</code>；<br>• 依次类推，直到对a[n]进行全排列时，输出整个数组的值，即得到一种排列结果。</p><p>还不懂的话可以看<a href="https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/">LeetCode官方题解</a>，不想跳过去看的我把关键的图拿过来了：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52ffc2579b9a4842bca15886a785ff98~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">swp</span> = (<span class="params">str, i, j</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> t = str[i];</span><br><span class="line">        str[i] = str[j];</span><br><span class="line">        str[j] = t;</span><br><span class="line">    &#125; <span class="comment">//swp</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">str, cur</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur === str.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.<span class="title function_">push</span>(str.<span class="title function_">slice</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = cur; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title function_">swp</span>(str, cur, i);</span><br><span class="line">            <span class="title function_">dfs</span>(str, cur + <span class="number">1</span>);</span><br><span class="line">            <span class="title function_">swp</span>(str, cur, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解法二：</strong><br>来自<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">LeetCode作者liweiwei1419</a></p><ul><li>先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；</li><li>再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；</li><li>最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。</li><li>注意需要保存状态，已经选择的数字在 当前 要选择的数字中不能出现。</li></ul><p>图解：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ec55cd8bdd14e02bb18932100104b62~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> vis = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">t</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="property">length</span> == nums.<span class="property">length</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            t.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            <span class="title function_">dfs</span>(t.<span class="title function_">slice</span>());</span><br><span class="line">            t.<span class="title function_">pop</span>();</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></li></ul><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 8</span><br><span class="line">-10 &lt;= nums[i] &lt;= 10</span><br></pre></td></tr></table></figure><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>一图胜千言：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e8eebaef398412ab8196fc8a8b6c355~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permuteUnique = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> visited = [];</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">t</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="property">length</span> === nums.<span class="property">length</span>) <span class="keyword">return</span> res.<span class="title function_">push</span>(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>; <span class="comment">//访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">//上一个没访问，且上一个值等于当前值</span></span><br><span class="line">            t.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">dfs</span>(t.<span class="title function_">slice</span>());</span><br><span class="line">            t.<span class="title function_">pop</span>();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permuteUnique</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]));</span><br></pre></td></tr></table></figure><h1 id="四、子集"><a href="#四、子集" class="headerlink" title="四、子集"></a>四、子集</h1><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a><br>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</li></ul><p>说明：解集不能包含重复的子集。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>子集树如图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee7a1d4ac6a841a2a65a1e6ba3819a15~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>这道题可以巧妙的运用选与不选构造一个更深的递归树，这是我们想要看到的</p></blockquote><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> t=[];</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">cur</span>) =&gt; &#123; <span class="comment">//当前层数</span></span><br><span class="line">        <span class="keyword">if</span> (cur === nums.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="comment">// console.log(t);</span></span><br><span class="line">            <span class="keyword">return</span> res.<span class="title function_">push</span>(t.<span class="title function_">slice</span>()); <span class="comment">//当前层数等于数组长度</span></span><br><span class="line">        &#125; </span><br><span class="line">        t.<span class="title function_">push</span>(nums[cur]); <span class="comment">//选当前层数的数字</span></span><br><span class="line">        <span class="title function_">dfs</span>(cur + <span class="number">1</span>);</span><br><span class="line">        t.<span class="title function_">pop</span>(); <span class="comment">//不选当前层数的数字</span></span><br><span class="line">        <span class="title function_">dfs</span>(cur + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subsets</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">t, start</span>) =&gt; &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            t.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            <span class="title function_">dfs</span>(t.<span class="title function_">slice</span>(), i + <span class="number">1</span>);</span><br><span class="line">            t.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subsets</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a><br>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</li></ul><p>说明：解集不能包含重复的子集。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>上一道题可以用讨巧的方法来回溯，但是这道题就不可以了。而这道题的解决方法与思路是可以解决上一道题的。话不多说，来分析题目：</p><p>不同于上题，很明显需要剪枝，但是刚看完题目不知道怎么剪，那么我们先画一个<code>子集树</code>，理清思路：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b495d1ae6dd943fcadca982ab75febdc~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>代码思路：<br>注意：巧妙使用sort，可以使相等元素相邻</p><p>关键：</p><ol><li>使用i指向当前元素，判断当前元素与前一元素是否相等，及判断<code>num[i - 1]===num[i]</code></li><li>剪枝不能将不同层的剪枝，如图中的[1,2,2] <code>i=start</code>是不同层重复(start相当于第几层），应该剪枝[1,2]<code>i=2,start=1·</code>不同层</li></ol><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsetsWithDup = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">t, start</span>) =&gt; &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 同层重复，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            t.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            <span class="title function_">dfs</span>(t.<span class="title function_">slice</span>(), i + <span class="number">1</span>);</span><br><span class="line">            t.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// console.log(subsetsWithDup([4,4,4,1,4]))</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每个人的解题方式都是不太一样的， 但是解题思路是可以相互借鉴的，这篇文章还是画了不少图的，也没有那么多文字，应该还是比较好理解的，最后希望这篇文章对你有用~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果对某题还有疑问LeetCode上基本也有不错的解答哦</span><br></pre></td></tr></table></figure><p>后续文章会持续更新，下一篇：递归与回溯（下），和我一起刷题吧~</p><blockquote><p>点个赞再走吧 ~ 求求了 ❀❀❀ 能一键三连的话那就更好啦~，你的支持是我继续写作的动力⭐️</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JS刷题之路-栈」和我一起系统的刷题吧（内附思维导图）</title>
      <link href="/posts/653/"/>
      <url>/posts/653/</url>
      
        <content type="html"><![CDATA[<h1 id="JS刷题之路-栈"><a href="#JS刷题之路-栈" class="headerlink" title="JS刷题之路-栈"></a>JS刷题之路-栈</h1><p><font color=#999AAA >⭐️最近一直在刷题，所以鸽了，这不我快马加鞭赶出了栈相关的JS题；题不在多，掌握了思维就会发现万变不离其宗（其实我觉着和刷数学题是差不多的感觉哈哈）</p><hr style=" border:solid; width:100%; height:1px;" color=#000000 size=1"><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7bc2287be1f41969edd4914a206a376~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p> 获取高清PDF，请在微信公众号【小狮子前端】回复【LeetCode】，一起刷题或者交流学习可以加Q群【666151691】</p><p><font color=#999AAA>上述刷题路径呢是前辈【一百个Chocolate】总结的，我个人觉得按照这样在LeetCode上刷题挺好的；在这一篇呢只讲栈，后续持续加更，等我刷完差不多就总结完了~<br></font></p></blockquote><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><p><font color=#999AAA >来，第一题搞个开胃小菜，往后逐渐加大力度</p><h1 id="LeetCode-栈"><a href="#LeetCode-栈" class="headerlink" title="LeetCode-栈"></a>LeetCode-栈</h1><h2 id="一、20-有效的括号"><a href="#一、20-有效的括号" class="headerlink" title="一、20.有效的括号"></a>一、20.有效的括号</h2><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/valid-parentheses/">20.有效的括号</a></li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个只包括’(‘，’)’，’{‘，’}’，’[‘，’]’的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>处在后面的左括号要最先匹配到对应的右括号，用栈的后进先出的思想，后进匹配弹出，接着匹配下一左括号；</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//奇数肯定是false，直接返回节省时间</span></span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> obj = &#123; <span class="comment">//存一个键值对，同理也可以用map存，也可以不存，不存的话就会多几个if匹配语句</span></span><br><span class="line">        <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>,</span><br><span class="line">        <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&quot;(&quot;</span> || s[i] === <span class="string">&#x27;[&#x27;</span> || s[i] === <span class="string">&quot;&#123;&quot;</span>) &#123; <span class="comment">//匹配左括号</span></span><br><span class="line">            stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack[stack.<span class="property">length</span> - <span class="number">1</span>] === obj[s[i]]) &#123; <span class="comment">//匹配右括号</span></span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><font color=#999AAA >不存的话会快一点，代码也更清晰明了，但如果括号类型多了的话代码就会有点冗余了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是奇数，不可能匹配成功，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span> || s[i] === <span class="string">&#x27;&#123;&#x27;</span> || s[i] === <span class="string">&#x27;[&#x27;</span>) stack.<span class="title function_">push</span>(s[i])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] === <span class="string">&#x27;(&#x27;</span>) stack.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] === <span class="string">&#x27;&#123;&#x27;</span>) stack.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;]&#x27;</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] === <span class="string">&#x27;[&#x27;</span>) stack.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h2 id="二、946-验证栈序列"><a href="#二、946-验证栈序列" class="headerlink" title="二、946. 验证栈序列"></a>二、946. 验证栈序列</h2><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/validate-stack-sequences/">946. 验证栈序列</a><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</li></ul><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= pushed.length == popped.length &lt;= 1000</span><br><span class="line">0 &lt;= pushed[i], popped[i] &lt; 1000</span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>借助一个新栈来存放从pushed加入栈的元素，然后每次和popped的元素进行比对，如果匹配成功出栈，如果这个新栈为空，那么代表这个栈入栈和出栈序列是合理的，返回 true，否则返回false；</p><p><font color=#999AAA >这题比上一题难一丢丢，但还是挺简单的吧，我就不画栈图了，简单的示意，聪明的你肯定能明白的~</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**题解：</span></span><br><span class="line"><span class="comment"> * stack      popped</span></span><br><span class="line"><span class="comment"> * 1          4</span></span><br><span class="line"><span class="comment"> * 12         4 </span></span><br><span class="line"><span class="comment"> * 123        4</span></span><br><span class="line"><span class="comment"> * 1234       4   相等弹出 popped下标++    </span></span><br><span class="line"><span class="comment"> *   123      5</span></span><br><span class="line"><span class="comment"> * 1235       5   相等弹出 popped下标++</span></span><br><span class="line"><span class="comment"> *   123      3</span></span><br><span class="line"><span class="comment"> *   12       2</span></span><br><span class="line"><span class="comment"> *   1        1</span></span><br><span class="line"><span class="comment"> * 栈空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">pushed</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">popped</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = <span class="keyword">function</span> (<span class="params">pushed, popped</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> j=<span class="number">0</span>;<span class="comment">//索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> cur <span class="keyword">of</span> pushed) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(cur); <span class="comment">//存</span></span><br><span class="line">        <span class="keyword">while</span> (stack[stack.<span class="property">length</span> - <span class="number">1</span>] === popped[j] &amp;&amp; stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123; <span class="comment">//匹配弹出</span></span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h2 id="三、921-使括号有效的最少添加"><a href="#三、921-使括号有效的最少添加" class="headerlink" title="三、921.使括号有效的最少添加"></a>三、921.使括号有效的最少添加</h2><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/">921.使括号有效的最少添加</a><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3>给定一个由 ‘(‘ 和 ‘)’ 括号组成的字符串 S，我们需要添加最少的括号（ ‘(‘ 或是 ‘)’，可以在任何位置），以使得到的括号字符串有效。</li></ul><p>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：</p><p>它是一个空字符串，或者<br>它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者<br>它可以被写作 (A)，其中 A 是有效字符串。<br>给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;())&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;(((&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;()&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;()))((&quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S.length &lt;= 1000</span><br><span class="line">S 只包含 &#x27;(&#x27; 和 &#x27;)&#x27; 字符。</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>分析示例4 ：    输入：<code>&quot;()))((&quot;</code>    输出：4<br>第一个左括号匹配到第一个右括号</p><p>接下来的两个没办法匹配到左括号（栈为空）于是加入栈中（虽然说它也没机会被匹配到了）</p><p>接下来遇到两个左括号同样的道理加入栈中。</p><p>可以用很多方法来存括号，但是用栈做更方便，这里用栈来做，匹配弹出，剩下不匹配的长度就是我们要加的括号</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">S</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minAddToMakeValid = <span class="keyword">function</span> (<span class="params">S</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> cur <span class="keyword">of</span> S)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur === <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack[stack.<span class="property">length</span>-<span class="number">1</span>] === <span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">//当前值为右括号且栈顶为左括号则弹出</span></span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(cur);<span class="comment">//否则加入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h2 id="前置知识（四五题的）"><a href="#前置知识（四五题的）" class="headerlink" title="前置知识（四五题的）"></a>前置知识（四五题的）</h2><h3 id="首先什么是单调栈"><a href="#首先什么是单调栈" class="headerlink" title="首先什么是单调栈"></a>首先什么是单调栈</h3><p>顾名思义单调栈就是维护一个单调递减或递增的栈；</p><blockquote><p>单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小<br>单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大</p></blockquote><p>如果记不住，或者容易搞混，<code>栈底大就是递增，栈底小就是递减</code>会好记一些</p><h3 id="如何使用单调栈"><a href="#如何使用单调栈" class="headerlink" title="如何使用单调栈"></a>如何使用单调栈</h3><p>举例单调递增栈：<br>例如，栈中自顶向下的元素为  10,20,30,40,50  ，插入元素 25 时为了保证单调性需要依次弹出元素  ，操作后栈变为  25,30,40,50  。</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert x</span><br><span class="line">while !sta.empty() &amp;&amp; sta.top()&lt;x</span><br><span class="line">    sta.pop()</span><br><span class="line">sta.push(x)</span><br></pre></td></tr></table></figure><h3 id="什么题适合用单调栈来做呢？"><a href="#什么题适合用单调栈来做呢？" class="headerlink" title="什么题适合用单调栈来做呢？"></a>什么题适合用单调栈来做呢？</h3><p>总结可能不会太全面，清谅解：</p><ol><li>求最长的单调上升、递减区间</li><li>针对每个数，寻找它和它左 / 右边第一个比它大 / 小的数的值，以及相距多少个数。</li><li>左右配对</li><li>多个区间中的最值 / 某个数为最值的最长区间<hr>有了这些前置知识我们再来看看这道题</li></ol><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h2 id="四、901-股票价格跨度"><a href="#四、901-股票价格跨度" class="headerlink" title="四、901. 股票价格跨度"></a>四、901. 股票价格跨度</h2><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/online-stock-span/">901. 股票价格跨度</a><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3>编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</li></ul><p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">输出：[null,1,1,1,2,1,4,6]</span><br><span class="line">解释：</span><br><span class="line">首先，初始化 S = StockSpanner()，然后：</span><br><span class="line">S.next(100) 被调用并返回 1，</span><br><span class="line">S.next(80) 被调用并返回 1，</span><br><span class="line">S.next(60) 被调用并返回 1，</span><br><span class="line">S.next(70) 被调用并返回 2，</span><br><span class="line">S.next(60) 被调用并返回 1，</span><br><span class="line">S.next(75) 被调用并返回 4，</span><br><span class="line">S.next(85) 被调用并返回 6。</span><br><span class="line"></span><br><span class="line">注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格</span><br><span class="line">(包括今天的价格 75) 小于或等于今天的价格。</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li>调用 StockSpanner.next(int price) 时，将有 1 &lt;= price &lt;= 10^5。</li><li>每个测试用例最多可以调用  10000 次 StockSpanner.next。 </li><li>在所有测试用例中，最多调用 150000 次。</li><li>StockSpanner.next。 此问题的总时间限制减少了 50%。</li></ol><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>题意关键：求价格小于或等于今天价格的最大连续日数（往前数）<br>这道题非常适合用单调栈来做，以题目 [100, 80, 60, 70, 60, 75, 85]为例，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。</p><p>用两个栈一个用来存价格，一个用来存跨度；<br>维护一个单调递增的栈，大的加进来，小的弹出去；<br>分析过程：<br>首先栈为空，加入100，w初始为1</p><p>下一个值，<code>80</code>，栈顶值不是小于等于它，于是加入，<code>w</code>初始为<code>1</code>入栈，同理<code>60</code>也是</p><p>下一个值：<code>70</code>，此时<code>栈中[100,80,60]</code>,<code>大于</code>栈顶<code>60</code>，将栈顶元素<code>弹出</code>，并计算w，w=<code>初始1+w(60)</code>=1+1=2加入w栈，其中w（60）其实就是栈顶的w（因为是同步的）</p><p>下一个值：<code>60</code>，与80的原理</p><p>下一个值：<code>75</code>，此时<code>栈中[100,80,70,60]</code>，计算w，为<code>1+w(60)+w(70)</code>=1+1+2=<code>4</code>，加入跨度栈w</p><p>下一个值：<code>85</code>，w=<code>1+w(75)+w(80)</code>=1+4+1=<code>6</code> 结束</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">StockSpanner</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prices</span>=[];<span class="comment">//存价格</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">weights</span>=[];<span class="comment">//存跨度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">price</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">StockSpanner</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">next</span> = <span class="keyword">function</span>(<span class="params">price</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> w = <span class="number">1</span>;<span class="comment">//初始</span></span><br><span class="line">    <span class="comment">//当prices栈不为空 且 栈顶小于输入价格  -&gt; 维护单调栈（弹出小于价格的并累加W）</span></span><br><span class="line">    <span class="comment">//以[100, 80, 60, 70, 60, 75, 85]为例，单调栈如下：</span></span><br><span class="line">    <span class="comment">//100           w=1  </span></span><br><span class="line">    <span class="comment">//100,80        w=1   lala</span></span><br><span class="line">    <span class="comment">//100,80,60     w=1</span></span><br><span class="line">    <span class="comment">//100,80,70     w=2  1+1</span></span><br><span class="line">    <span class="comment">//100,80,70,60  w=1  </span></span><br><span class="line">    <span class="comment">//100,80,75     w=4  1+1+2</span></span><br><span class="line">    <span class="comment">//100,85        w=6  1+4+1</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">prices</span>.<span class="property">length</span>&gt;<span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">prices</span>[<span class="variable language_">this</span>.<span class="property">prices</span>.<span class="property">length</span>-<span class="number">1</span>] &lt;=price)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">prices</span>.<span class="title function_">pop</span>();</span><br><span class="line">        w+=<span class="variable language_">this</span>.<span class="property">weights</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prices</span>.<span class="title function_">push</span>(price);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">weights</span>.<span class="title function_">push</span>(w);</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new StockSpanner()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.next(price)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h2 id="五、739-每日温度"><a href="#五、739-每日温度" class="headerlink" title="五、739. 每日温度"></a>五、739. 每日温度</h2><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</li></ul><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目关键在于：求解要想观测到<code>更高</code>的气温，<code>至少需要等待</code>的天数。后续没有温度更高结果为0。</p><p>以[73, 74, 75, 71, 69, 72, 76, 73]为例：</p><p>第一天<code>73</code>：  栈为空将73的下标加入栈中;</p><p>第二天<code>74</code>： 74大于栈顶元素值，73弹出，73的结果res[0]值为74的下标减去73的下标，res[0]=1-0=1;</p><p>第三天<code>75</code>： 75大于栈顶元素74，74弹出，同理res[1]=2-1=1，栈空75加入；</p><p>第四天<code>71</code>，第五天<code>69</code>：  小于栈顶加入栈，此时栈：<code>[2（75）,3（71）,4（69）]</code>栈存的下标;</p><p>第六天<code>72</code>：  大于栈顶元素值，69先弹出，<code>69</code>的结果res[4]值为72的下标减去69的下标，<code>res[4]=5-4=1</code>;循环73还大于现栈顶元素71，71先弹出，<code>71</code>的结果res[3]值为72的下标减去71的下标，<code>res[3]=5-3=2</code>；小于栈顶75，将72加入栈中，此时栈<code>[2（75），5（72）]</code>;</p><p>第七天<code>76</code>：同上述步骤72 res[5]=6-5=1, 75 res[2]=6-2=4  栈为[76];</p><p>第八天<code>73</code>：小于栈顶加入栈中</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">T</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="keyword">function</span> (<span class="params">T</span>) &#123;</span><br><span class="line">    <span class="comment">//[73, 74, 75, 71, 69, 72, 76, 73]</span></span><br><span class="line">    <span class="comment">//74(1)           73-&gt;1-0=1</span></span><br><span class="line">    <span class="comment">//75              74-&gt;2-1=1</span></span><br><span class="line">    <span class="comment">//75,72(71,69)    69-&gt;5-4=1  71-&gt;5-3=2</span></span><br><span class="line">    <span class="comment">//76              72-&gt;6-5=1  75-&gt;6-2=4</span></span><br><span class="line">    <span class="comment">//76,73</span></span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(T.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">//运用fill方法为数组填0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; T.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.<span class="property">length</span> &amp;&amp; T[i] &gt; T[stack[stack.<span class="property">length</span> - <span class="number">1</span>]]) &#123; <span class="comment">//循环条件当前值大于栈顶元素值（栈中存的是下标值）</span></span><br><span class="line">            number[stack[stack.<span class="property">length</span> - <span class="number">1</span>]] = i - stack.<span class="title function_">pop</span>(); <span class="comment">//弹出栈的元素的跨度等于当前值下标减去弹出（栈顶）下标  </span></span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h2 id="六、907-子数组的最小值之和"><a href="#六、907-子数组的最小值之和" class="headerlink" title="六、907. 子数组的最小值之和"></a>六、907. 子数组的最小值之和</h2><ul><li><input disabled="" type="checkbox"> 题目链接：<a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3></li></ul><p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。</p><p>由于答案可能很大，因此返回答案模 10^9 + 7。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 </span><br><span class="line">最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= A &lt;= 30000<br>1 &lt;= A[i] &lt;= 30000</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>关键在于：求子数组中最小值的和，就是求 以 A[i] 作为最小数能构成的数组有多少个。</p><p>以<code>[3,1,2,4]</code>为例 ,以<code>1</code> 为最小数，能构成的数组数为 <code>(1+1)*(2+1)</code> ，左边3比它大，右边2、4比它大。</p><p>用单调栈求出 arr[i] 对应的左（右）最近比 arr[i] 小的数的索引  leftStack（rightStack），arr[i] 为最小数能形成的数组的个数为：<code>leftStack[i]*rightStack[i]</code></p><p>知道个数再乘以值累加，得到结果；</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">arr</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumSubarrayMins = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> leftStack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.<span class="property">length</span> &amp;&amp; arr[stack[stack.<span class="property">length</span> - <span class="number">1</span>]] &gt;= arr[i]) &#123; <span class="comment">//左边设置大于等于了，右边就只能是大于了，不然会重复计算</span></span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈为空，即左边都比自己大，则返回i+1，否则返回i减栈顶元素（栈保存下标值）</span></span><br><span class="line">        leftStack[i] = stack.<span class="property">length</span> ? i - stack[stack.<span class="property">length</span> - <span class="number">1</span>] : i + <span class="number">1</span></span><br><span class="line">        stack.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    stack = [];</span><br><span class="line">    <span class="keyword">let</span> rightStack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.<span class="property">length</span> &amp;&amp; arr[stack[stack.<span class="property">length</span> - <span class="number">1</span>]] &gt; arr[i]) &#123;</span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈为空，即右边都比自己大，则返回arr.length-i，否则返回栈顶元素（即保存的下标值）-i</span></span><br><span class="line">        rightStack[i] = stack.<span class="property">length</span> ? stack[stack.<span class="property">length</span> - <span class="number">1</span>] - i : arr.<span class="property">length</span> - i</span><br><span class="line">        stack.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 以arr[i] 为最小值的子数组的组合共有leftStack[i]*rightStack[i]种情况，那么和的话乘以arr[i]累加即可</span></span><br><span class="line">        res += (leftStack[i] * rightStack[i] * arr[i]);</span><br><span class="line">        res %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h2 id="七、1190-反转每对括号间的子串"><a href="#七、1190-反转每对括号间的子串" class="headerlink" title="七、1190. 反转每对括号间的子串"></a>七、1190. 反转每对括号间的子串</h2><ul><li><input disabled="" type="checkbox"> 题目链接：1190. <a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/">反转每对括号间的子串</a><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3>给出一个字符串 s（仅含有小写英文字母和括号）。</li></ul><p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p><p>注意，您的结果中 不应 包含任何括号。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(abcd)&quot;</span><br><span class="line">输出：&quot;dcba&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(u(love)i)&quot;</span><br><span class="line">输出：&quot;iloveu&quot;</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(ed(et(oc))el)&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a(bcdefghijkl(mno)p)q&quot;</span><br><span class="line">输出：&quot;apmnolkjihgfedcbq&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= s.length &lt;= 2000</span><br><span class="line">s 中只有小写英文字母和括号</span><br><span class="line">我们确保所有括号都是成对出现的</span><br></pre></td></tr></table></figure><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目关键：括号内到外，逐层反转每对匹配括号中的字符串，理解到底是怎么匹配的<br>提示中关键：括号都是成对的</p><p>以示例 3：s = “(ed(et(oc))el)”为例，为了更清楚直观，我写一下下标：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">(    e    d    (    e    t    (    o    c    )    )   e   l    )</span><br><span class="line"><span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span>    <span class="number">5</span>    <span class="number">6</span>    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span>   <span class="number">11</span>  <span class="number">12</span>  <span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pair</span>:<span class="comment">//左右括号一一对应</span></span><br><span class="line"><span class="number">13</span>   <span class="number">10</span>   <span class="number">9</span>   </span><br><span class="line"><span class="number">0</span>    <span class="number">3</span>    <span class="number">6</span></span><br></pre></td></tr></table></figure><p>首先用一个for循环和栈，将左右配对的括号存起来</p><p>第一个遇到的左括号<code>0</code>：0<code>-&gt;13</code>找到右括号，<code>逆序</code> i- -输出12 11（<code>l e</code>），<code>直到遇到下一个括号</code>10；</p><p>第二个遇到的右括号<code>10</code>:10<code>-&gt;3</code>，<code>i++</code>输出 4 5（<code>et</code>），遇到6；</p><p>第三个遇到括号<code>6</code>：6<code>-&gt;9</code>，<code>i- -</code>，8 7 （<code>c o</code>),遇到6；</p><p>第四个遇到括号<code>6</code>：6-<code>&gt;9</code>，<code>i++</code>，遇到10；</p><p>第五个遇到括号<code>10</code>：10<code>-&gt;3</code>，<code>i- -</code>，2 1 （<code>d e</code>),遇到0；</p><p>第六个遇到括号<code>0</code>：0-<code>&gt;13</code>，<code>i++</code>，13&gt;len  <code>结束</code>；</p><p>输出：”leetcode”</p><p>i++和i–可以用一个参数储存方向，遇到括号就匹配反向；</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0-&gt;13    12 11  10  le</span></span><br><span class="line"><span class="comment"> * 10-&gt;3    4 5    6   et</span></span><br><span class="line"><span class="comment"> * 6-&gt;9     8 7    10  co</span></span><br><span class="line"><span class="comment"> * 10-&gt;3    2 1    0   de</span></span><br><span class="line"><span class="comment"> * 0-&gt;13    14     (end)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseParentheses = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">//匹配括号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(i)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> j = stack.<span class="title function_">pop</span>();</span><br><span class="line">            pair[i] = j; <span class="comment">//相当于键值存储，a[0]=13,a[13]=0</span></span><br><span class="line">            pair[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [],</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, direction = <span class="number">1</span>; i &lt; s.<span class="property">length</span>; i += direction) &#123;<span class="comment">//i=i+direction反转方向  i++或i--</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span> || s[i] === <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            i = pair[i]; <span class="comment">//找匹配的括号并修改i的下标为匹配括号下标 0-&gt;13  i=13</span></span><br><span class="line">            direction = -direction; <span class="comment">//反向</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[r] = s[i];</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">//去逗号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果上个方法没看懂？再说一个的方法吧</p><h3 id="第二种解题思路"><a href="#第二种解题思路" class="headerlink" title="第二种解题思路"></a>第二种解题思路</h3><p>初始化栈，栈顶元素为 “ “ 遇到 ‘(‘: 向栈顶压入空字符串 遇到 ‘)’: 把栈顶的最后一个元素翻转 + 栈顶倒数第二个元素 遇到 字符: 直接将栈顶最后一个元素与它拼上</p><p>参考<code>tuotuoli</code> 大佬解题思路</p><p>样例栈数组操作示意：</p><p>样例：a(bcdefghijkl(mno)p)q</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a [&#x27;a&#x27;]</span><br><span class="line">( [&#x27;a&#x27;, &#x27;&#x27;]</span><br><span class="line">b [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line">c [&#x27;a&#x27;, &#x27;bc&#x27;]</span><br><span class="line">d [&#x27;a&#x27;, &#x27;bcd&#x27;]</span><br><span class="line">e [&#x27;a&#x27;, &#x27;bcde&#x27;]</span><br><span class="line">f [&#x27;a&#x27;, &#x27;bcdef&#x27;]</span><br><span class="line">g [&#x27;a&#x27;, &#x27;bcdefg&#x27;]</span><br><span class="line">h [&#x27;a&#x27;, &#x27;bcdefgh&#x27;]</span><br><span class="line">i [&#x27;a&#x27;, &#x27;bcdefghi&#x27;]</span><br><span class="line">j [&#x27;a&#x27;, &#x27;bcdefghij&#x27;]</span><br><span class="line">k [&#x27;a&#x27;, &#x27;bcdefghijk&#x27;]</span><br><span class="line">l [&#x27;a&#x27;, &#x27;bcdefghijkl&#x27;]</span><br><span class="line">( [&#x27;a&#x27;, &#x27;bcdefghijkl&#x27;, &#x27;&#x27;]</span><br><span class="line">m [&#x27;a&#x27;, &#x27;bcdefghijkl&#x27;, &#x27;m&#x27;]</span><br><span class="line">n [&#x27;a&#x27;, &#x27;bcdefghijkl&#x27;, &#x27;mn&#x27;]</span><br><span class="line">o [&#x27;a&#x27;, &#x27;bcdefghijkl&#x27;, &#x27;mno&#x27;]</span><br><span class="line">) [&#x27;a&#x27;, &#x27;bcdefghijklonm&#x27;]</span><br><span class="line">p [&#x27;a&#x27;, &#x27;bcdefghijklonmp&#x27;]</span><br><span class="line">) [&#x27;apmnolkjihgfedcb&#x27;]</span><br><span class="line">q [&#x27;apmnolkjihgfedcbq&#x27;]</span><br></pre></td></tr></table></figure><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseParentheses = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> ch = s[i]</span><br><span class="line">    <span class="keyword">if</span>(ch === <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch === <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> str = stack.<span class="title function_">pop</span>()</span><br><span class="line">      <span class="keyword">let</span> tmp = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      stack[stack.<span class="property">length</span>-<span class="number">1</span>] += tmp</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      stack[stack.<span class="property">length</span>-<span class="number">1</span>] += ch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后一道简单题：</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="八、1249-移除无效的括号"><a href="#八、1249-移除无效的括号" class="headerlink" title="八、1249.移除无效的括号"></a>八、1249.移除无效的括号</h1><ul><li><input disabled="" type="checkbox"> 题目链接：1249.<a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/">移除无效的括号</a></li></ul><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。</p><p>你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 任意一条 要求：</p><p>空字符串或只包含小写字母的字符串<br>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」<br>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;lee(t(c)o)de)&quot;</span><br><span class="line">输出：&quot;lee(t(c)o)de&quot;</span><br><span class="line">解释：&quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; 也是一个可行答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a)b(c)d&quot;</span><br><span class="line">输出：&quot;ab(c)d&quot;</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;))((&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：空字符串也是有效的</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(a(b(c)d)&quot;</span><br><span class="line">输出：&quot;a(b(c)d)&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 10^5</span><br><span class="line">s[i] 可能是 &#x27;(&#x27;、&#x27;)&#x27; 或英文小写字母</span><br></pre></td></tr></table></figure><h1 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h1><p>解题关键：匹配到的括号保留，没匹配删除</p><p><font color=#999AAA >代码如下（示例）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minRemoveToMakeValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [...s];</span><br><span class="line">    <span class="comment">//栈匹配括号，剩下括号删除</span></span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">delete</span>(res[i]); <span class="comment">//栈为空，没有左括号，把当前右括号删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123; <span class="comment">//删除栈顶元素直到栈空</span></span><br><span class="line">        <span class="title function_">delete</span>(res[stack.<span class="title function_">pop</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每个人的解题方式都是不太一样的， 但是解题思路是可以相互借鉴的，希望这篇文章对你有用~</p><p>后续文章会持续更新，下一篇：递归与回溯，和我一起刷题吧~</p><blockquote><p>点个赞再走吧 ~ 求求了 ❀❀❀   能一键三连的话那就更好啦~~，你的支持是我继续写作的动力⭐️</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「导航渲染流程」你真的知道从输入URL到页面展示发生了什么吗？（内附思维导图）</title>
      <link href="/posts/643/"/>
      <url>/posts/643/</url>
      
        <content type="html"><![CDATA[<h2 id="导航渲染流程"><a href="#导航渲染流程" class="headerlink" title="导航渲染流程"></a>导航渲染流程</h2><p><font color=#999AAA >通过这篇文章当你被问到从URL输入到页面展示都发生了什么的时候，基本都能对答如流，甚至可以一直深入的说，说到面试官闭麦哈哈哈~</p><hr style=" border:solid; width:100; height:1px;" color=#000000 size=1"><p>以下是本文的思维导图，直接拿图<strong>点个赞</strong>再走吧 ~ 求求了 ❀❀❀<br></font><br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/110d2319bfc94cb7bbf7389e6f93d4e8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端】回复【导航渲染流程】</p></blockquote><p>从输入到页面渲染这个过程其实可以说得非常复杂，我这里总结的只是我通过在某网站上学习的课程【浏览器】所总结出来的，包括了两大步骤，一个是导航流程另一个是渲染流程；</p><hr><h1 id="一、导航流程"><a href="#一、导航流程" class="headerlink" title="一、导航流程"></a>一、导航流程</h1><h2 id="1-用户输入URL"><a href="#1-用户输入URL" class="headerlink" title="1.用户输入URL"></a>1.用户输入URL</h2><p>不考虑用户输入搜索关键字的情况，<br>如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL</p><h2 id="2-loading状态"><a href="#2-loading状态" class="headerlink" title="2.loading状态"></a>2.loading状态</h2><p>用户输入完内容，按下回车键，浏览器导航栏显示<code>loading</code>状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获取到。</p><h2 id="3-浏览器请求"><a href="#3-浏览器请求" class="headerlink" title="3.浏览器请求"></a>3.浏览器请求</h2><p>浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP1.1</span><br></pre></td></tr></table></figure><h2 id="4-网络进程处理"><a href="#4-网络进程处理" class="headerlink" title="4.网络进程处理"></a>4.网络进程处理</h2><p>网络进程接收到<code>url</code>请求后检查本地缓存是否缓存了该请求资源：</p><ul><li>如果有缓存文件<ul><li><input disabled="" type="checkbox"> 拦截请求，直接200返回</li></ul></li><li>无缓存文件<ul><li><input disabled="" type="checkbox"> 进入网络请求过程</li></ul></li></ul><p>请求DNS（返回对应IP端口）</p><ul><li>缓存过当前域名信息<ul><li><input disabled="" type="checkbox"> 直接返回缓存信息</li></ul></li><li>未缓存<ul><li><input disabled="" type="checkbox"> 发起请求获取根据域名解析出来的IP和端口号</li></ul></li></ul><h2 id="5-TCP三次握手建立连接"><a href="#5-TCP三次握手建立连接" class="headerlink" title="5.TCP三次握手建立连接"></a>5.TCP三次握手建立连接</h2><p>Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。</p><p>TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输http请求加上TCP头部向下传输<br><a href="https://blog.csdn.net/qq_41147507/article/details/109593886">三次握手建立连接详细过程</a></p><h2 id="6-数据传输过程"><a href="#6-数据传输过程" class="headerlink" title="6.数据传输过程"></a>6.数据传输过程</h2><p><strong>网络层、传输层</strong><br>在数据包上加上IP头部，继续向下传输到底层，底层通过物理网络传输给目的服务器主机</p><ul><li><input disabled="" type="checkbox"> 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层</li></ul><p><strong>目的服务器主机</strong></p><ul><li>网络层，解析出IP头部，识别出数据部分</li><li>传输层获取到数据包，解析出TCP头部，识别端口</li></ul><p><strong>应用层HTTP解析请求头和请求体</strong><br>应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态<code>code301</code>或者<code>302</code>，同时在请求头的<code>Location</code>字段中附上重定向地址，浏览器会根据<code>code</code>和<code>Location</code>进行重定向操作；</p><p>如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；</p><p>否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：Cache-Control:Max-age=2000</p><ul><li>重定向<pre><code>HTTP直接返回HTTP响应数据的状态`code301`或者`302`同时在请求头的Location字段中附上重定向地址</code></pre></li><li>不是重定向<pre><code>`If-None-Match`,没有更新，就返回`304`状态码;否则，返回新数据，`200`的状态码`Cache-Control`,想要浏览器缓存数据</code></pre></li></ul><p><strong>响应数据</strong>又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到<strong>网络进程</strong></p><h2 id="7-传输完成，TCP四次挥手"><a href="#7-传输完成，TCP四次挥手" class="headerlink" title="7.传输完成，TCP四次挥手"></a>7.传输完成，TCP四次挥手</h2><h2 id="8-网络进程（数据包解析）"><a href="#8-网络进程（数据包解析）" class="headerlink" title="8.网络进程（数据包解析）"></a>8.网络进程（数据包解析）</h2><p><strong>Content-type</strong></p><p>网络进程将获取到的数据包进行解析，根据响应头中的<code>Content-type</code>来判断响应数据的类型</p><ul><li><p>如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行</p></li><li><p>如果是text/html类型，就通知浏览器进程获取到文档准备渲染</p></li></ul><h2 id="9-渲染进程（渲染进程的主进程）"><a href="#9-渲染进程（渲染进程的主进程）" class="headerlink" title="9.渲染进程（渲染进程的主进程）"></a>9.渲染进程（渲染进程的主进程）</h2><p>浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程</p><ul><li>网络进程建立传输数据的“管道”</li><li>确认提交给浏览器进程</li></ul><h2 id="10-浏览器（更新页面状态）"><a href="#10-浏览器（更新页面状态）" class="headerlink" title="10.浏览器（更新页面状态）"></a>10.浏览器（更新页面状态）</h2><p>浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页</p><p>此时的web页面是空白页，以下列举了三种状态更新</p><ul><li>安全状态</li><li>地址栏的 URL</li><li>前进后退的历史状态</li></ul><h1 id="二、渲染流程（可以看成步骤9的补充）"><a href="#二、渲染流程（可以看成步骤9的补充）" class="headerlink" title="二、渲染流程（可以看成步骤9的补充）"></a>二、渲染流程（可以看成步骤9的补充）</h1><p>导航被提交后又会怎么样呢？就进入了渲染阶段。<br><br></p><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><h3 id="1-DOM树"><a href="#1-DOM树" class="headerlink" title="1.DOM树"></a>1.DOM树</h3><p>HTML通过HTML解析器解析输出DOM树。<br>下面的HTML代码会被解析成上面这种浏览器可以理解的DOM树结构：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fb1faef6dbe44ccb7e05597d2905a5b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="2-Style样式计算"><a href="#2-Style样式计算" class="headerlink" title="2.Style样式计算"></a>2.Style样式计算</h3><ul><li><p>把 CSS 转换为浏览器能够理解的结构–<strong>styleSheets</strong>。<br>这里一CSDN为例可以看到它最新的styleSheets，会包含引用的外部 CSS 文件、&lt;/style&gt;标记内的 CSS、以及内嵌的 CSS；<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc3bc5b7fa9040baba42c8a76c810b01~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p></li><li><p>标准化样式表属性值<br>将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。    <code>1em</code> 被解析成 <code>1px</code>，<code>red</code> 被解析成了 <code>rgb(255,0,0)</code>等等。</p></li><li><p>计算 DOM 树每个节点的具体样式<br>最终的样式可以通过控制台element的Computed查看，关于是怎么计算，涉及继承规则和层叠规则，这里就不细讲了。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/604405f0902448309469567637a1301d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="3-Layout-布局树"><a href="#3-Layout-布局树" class="headerlink" title="3.Layout 布局树"></a>3.Layout 布局树</h3></li><li><p>创建布局树：遍历 DOM 树中的所有可见节点，加到布局树中。对<code>display：none</code>的就忽略不加。</p></li><li><p>布局计算：计算布局树节点的坐标位置。</p></li></ul><h3 id="4-layer-图层绘制列表"><a href="#4-layer-图层绘制列表" class="headerlink" title="4.layer 图层绘制列表"></a>4.layer 图层绘制列表</h3><p>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><p>进入Layer页面，操作按钮从左至右功能依次为：平移、旋转、复位。见图：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f46e7899c8c4eb8926d5f5d944b72db~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-Pain-图层绘制"><a href="#5-Pain-图层绘制" class="headerlink" title="5.Pain 图层绘制"></a>5.Pain 图层绘制</h3><p>可以想象你画画，先画远处再画近处，图层绘制也是这种原理。图层绘制阶段，输出待绘制列表。</p><h2 id="合成线程"><a href="#合成线程" class="headerlink" title="合成线程"></a>合成线程</h2><h3 id="6-栅格化（tiles图块、raster光栅化）"><a href="#6-栅格化（tiles图块、raster光栅化）" class="headerlink" title="6.栅格化（tiles图块、raster光栅化）"></a>6.栅格化（tiles图块、raster光栅化）</h3><p>在有些情况下，有的图层很大，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><p>也是因为这个原因，合成线程会将图层进行分块划分为<strong>图块</strong>然后再<strong>栅格化</strong>，将图块转换为位图，而渲染进程通常不做或者做不来格栅化，需要跨进程，使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><h3 id="7-Display-合成和显示"><a href="#7-Display-合成和显示" class="headerlink" title="7.Display 合成和显示"></a>7.Display 合成和显示</h3><p>图块都被光栅化，合成线程就会生成一个绘制图块的命令——“<strong>DrawQuad</strong>”提交给浏览器进程。</p><p>浏览器进程接收 DrawQuad 命令，根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><p>至此页面就被渲染出来了~~完结撒花❀❀❀</p><hr style=" border:solid; width:100%; height:1px;" color=#000000 size=1"><h2 id="渲染流程总结"><a href="#渲染流程总结" class="headerlink" title="渲染流程总结"></a>渲染流程总结</h2><blockquote><p>贴心的我又对上述难理解的知识做了总结，并且还准备了图，确定不点个赞⭐️支持一下嘛~</p></blockquote><p>渲染页面主要做的事：</p><ul><li>1.将浏览器无法直接理解和使用的HTML，转换为浏览器能够理解的结构–<strong>DOM 树</strong>。</li><li>2.把 CSS 转换为浏览器能够理解的结构–<strong>styleSheets</strong>，并转换样式表中的属性值，使其标准化，计算出 DOM 树中每个节点的具体样式（根据继承规则和层叠规则）。</li><li>3.确定DOM 元素的几何位置信息–<strong>布局树</strong>，遍历 DOM 树中的所有可见节点，加入到布局树（display：none不包含），并计算布局树节点的坐标位置。</li><li>4.如果页面有复杂的效果，如常见的页面滚动，或者使用 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的<strong>图层树</strong>（LayerTree）。</li><li>5.图层绘制，把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个<strong>待绘制列表</strong>（联想自己画画）。</li><li>6.tiles：将图层转换成图块。</li><li>7.光栅化：通过进程实现图块转换成位图。</li><li>8.display：浏览器进程拿到DrawQuad信息生成页面显示。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</span><br></pre></td></tr></table></figure><p>贴心的我也为你们做了一张图：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0ea137c7ad41b9849755c2171431cc~tplv-k3u1fbpfcp-zoom-1.image" alt="渲染流程"></p><blockquote><p><strong>点个赞</strong>再走吧 ~ 求求了 ❀❀❀ 能一键三连的话那就更好啦~，你的支持是我继续写作的动力⭐️</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「浏览器安全」你可能需要的一份浏览器安全的总结（内附思维导图）</title>
      <link href="/posts/643/"/>
      <url>/posts/643/</url>
      
        <content type="html"><![CDATA[<p><font color=#999AAA >通过这篇文章你可以了解到同源策略、跨站脚本攻击（xss）、跨域请求伪造（CSRF）以及安全沙箱相关知识；</p><p>以下是本文的思维导图，直接拿图点个赞吧<del>：<br></font><br>![](<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b43751d5a6e4f01b3b3fc468faf2e05">https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b43751d5a6e4f01b3b3fc468faf2e05</a></del>tplv-k3u1fbpfcp-zoom-1.image)</p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端】回复【浏览器安全】</p></blockquote><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h1 id="一、什么是同源策略"><a href="#一、什么是同源策略" class="headerlink" title="一、什么是同源策略"></a>一、什么是同源策略</h1><p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p><ul><li>DOM 层面：限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</li><li>数据层面：限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。</li><li>网络层面：限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。<h1 id="二、安全和便利性的权衡"><a href="#二、安全和便利性的权衡" class="headerlink" title="二、安全和便利性的权衡"></a>二、安全和便利性的权衡</h1></li></ul><ol><li>页面中可以嵌入第三方资源。-&gt;XSS攻击</li></ol><ul><li>为了解决 XSS 攻击，浏览器中引入了<strong>内容安全策略</strong>，称为 CSP。</li><li>CSP 的<strong>核心思想</strong>是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。</li><li>通过这些手段就可以大大减少 XSS 攻击。</li></ul><ol start="2"><li>跨域资源共享</li></ol><ul><li><p>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。</p></li><li><p><strong>跨域资源共享（CORS）</strong>，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p></li></ul><ol start="3"><li>跨文档消息机制</li></ol><ul><li>两个不同源的DOM是不能互相操纵的，因此浏览器又实现了<strong>跨文档消息机制</strong>，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</li></ul><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="同源策略、CSP、CROS之间的关系？"><a href="#同源策略、CSP、CROS之间的关系？" class="headerlink" title="同源策略、CSP、CROS之间的关系？"></a>同源策略、CSP、CROS之间的关系？</h3><p>同源策略就是说通院的页面可以互相操作，但是不同源之间只能通过浏览器提供的手段来操作，比如：</p><ul><li>读取数据和操作DOM要跨文档机制</li><li>跨域请求要用CROS机制</li><li>引用第三方资源要用SCP</li></ul><h3 id="为什么XMLHttpRequest不能跨域请求资源？"><a href="#为什么XMLHttpRequest不能跨域请求资源？" class="headerlink" title="为什么XMLHttpRequest不能跨域请求资源？"></a>为什么XMLHttpRequest不能跨域请求资源？</h3><ul><li>存在同源策略，不同源的资源请求会被制止。</li><li>使用 XMLHttpRequest 是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。<h1 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h1><h2 id="一、XSS-can-do"><a href="#一、XSS-can-do" class="headerlink" title="一、XSS can do"></a>一、XSS can do</h2></li><li>可以窃取 Cookie 信息</li><li>可以监听用户行为</li><li>可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息</li><li>还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验</li></ul><h2 id="二、恶意脚本是怎么注入的？"><a href="#二、恶意脚本是怎么注入的？" class="headerlink" title="二、恶意脚本是怎么注入的？"></a>二、恶意脚本是怎么注入的？</h2><ul><li><strong>存储型 XSS 攻击</strong>：黑客将恶意代码储存到存在漏洞的服务器，浏览器访问含有恶意代码的页面，浏览器上传用户信息到而已服务器。</li><li><strong>反射型XSS攻击</strong>：用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。</li><li><strong>基于 DOM 的 XSS 攻击</strong>：不牵涉到页面 Web 服务器，在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。<br>   比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的。</li></ul><h2 id="三、如何阻止-XSS-攻击？"><a href="#三、如何阻止-XSS-攻击？" class="headerlink" title="三、如何阻止 XSS 攻击？"></a>三、如何阻止 XSS 攻击？</h2><ol><li>服务器对输入脚本进行<strong>过滤或转码</strong></li><li>充分利用 <strong>CSP</strong><ul><li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li><li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li><li>禁止执行内联脚本和未授权的脚本；</li><li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li></ul></li><li>使用 <strong>HttpOnly</strong> 属性</li><li><strong>验证码</strong><ul><li>防止脚本冒充用户提交危险操作</li></ul></li><li><strong>限制长度</strong><ul><li>对于一些不受信任的输入，还可以限制其输入长度</li></ul></li></ol><h1 id="跨域请求伪造（CSRF）攻击"><a href="#跨域请求伪造（CSRF）攻击" class="headerlink" title="跨域请求伪造（CSRF）攻击"></a>跨域请求伪造（CSRF）攻击</h1><p><code>陌生链接不要随便点</code></p><h3 id="一、什么是-CSRF-攻击"><a href="#一、什么是-CSRF-攻击" class="headerlink" title="一、什么是 CSRF 攻击?"></a>一、什么是 CSRF 攻击?</h3><p>黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</p><ol><li>自动发起 Get 请求</li><li>自动发起 POST 请求</li><li>引诱用户点击链接</li></ol><p>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p><h3 id="二、如何防止-CSRF-攻击"><a href="#二、如何防止-CSRF-攻击" class="headerlink" title="二、如何防止 CSRF 攻击?"></a>二、如何防止 CSRF 攻击?</h3><p><strong>CSRF 攻击的三个必要条件?</strong><br>1.目标站点一定要有 CSRF 漏洞；<br>2.用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；<br>3.需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛；</p><p><strong>1.充分利用好 Cookie 的 SameSite 属性</strong><br>SameSite的三种属性：</p><ul><li>Strict 最为严格，浏览器会完全禁止第三方 Cookie。</li><li>Lax 相对宽松一点。链接打开、 Get 方式的表单携带 Cookie。</li><li>None ，在任何情况下都会发送 Cookie 数据。</li></ul><p><strong>2. 验证请求的来源站点</strong><br>Post请求时的Origin信息（以CSDN为例）<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/143c941c7d6f491e8d599c351c0e2f8a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>3. CSRF Token</strong></p><ul><li>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。</li><li>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。</li></ul><p><strong>4.X-FRAME-OPTIONS</strong></p><ul><li>DENY，表示页面不允许通过iframe方式展示</li><li>SAMEORIGIN，相同域名可以·通过ifame展示</li><li>ALLOW-FROM，可以在指定来源中的iframe展示</li></ul><h1 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h1><p>是页面和系统之间的隔离墙<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/507763ac9b5448458844b909dcbf9a0d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="一、安全沙箱是如何影响到各个模块功能的呢？"><a href="#一、安全沙箱是如何影响到各个模块功能的呢？" class="headerlink" title="一、安全沙箱是如何影响到各个模块功能的呢？"></a>一、安全沙箱是如何影响到各个模块功能的呢？</h2><p><strong>持久存储</strong><br>现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。</p><p><strong>网络访问</strong><br>浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL。<br>比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</p><p><strong>用户交互</strong></p><ul><li>渲染进程不能直接访问窗口句柄。</li><li>限制渲染进程有监控到用户输入事件的能力</li></ul><h2 id="二、站点隔离（Site-Isolation）"><a href="#二、站点隔离（Site-Isolation）" class="headerlink" title="二、站点隔离（Site Isolation）"></a>二、站点隔离（Site Isolation）</h2><p>所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>⭐️文章产出不易，请毫不留情的三连吧~</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/693e30e23f3b4751b1682a0aa59270f3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
